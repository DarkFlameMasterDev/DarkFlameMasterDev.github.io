[{"title":"Android Studio Gradle 版本兼容性适配（理论篇）","url":"/2025/03/05/Android-Studio-Gradle-%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9%E6%80%A7%E9%80%82%E9%85%8D%EF%BC%88%E7%90%86%E8%AE%BA%E7%AF%87%EF%BC%89/","content":"AGP 是什么\nGradle 的专用插件\nAGP 是一个 Gradle 插件，专门为 Android 项目定制，添加了 Android 特有的构建能力（如编译资源、生成 APK/AAB 文件）\n\nGradle扩展\ngradle plugin 是基于 Gradle 构建系统的扩展工具，是辅助 gradle 主程序构建项目的\n\n所以，不同类型的项目有不同的插件，例如 Android 有 com.android.application，java 有 java 和 java-library，spring boot 有 org.springframework.boot 等等\nAndroid 项目的构建入口\n通过在 build.gradle 中应用 com.android.application 或 com.android.library 插件，告诉 Gradle “这是一个 Android 项目”，并启用对应的构建规则。\n封装 Android 构建逻辑\nAGP 内部封装了 Android SDK 的构建工具链（如 aapt、dx、zipalign），简化开发者配置。\n\n所以你看，Gradle 就像一个机器的空壳子，你往里面加什么配件，他就会出现不同的工作机制\n\n基于 Gradle 构建的项目发展历程\n在我记忆里，最早的 基于 Gradle 构建的项目一共有三个样子，我们现在只考虑后两种，也就是有了 kotlin 之后的两种\nAGP 7.0之前\n\n\nAndroid Studio 2020.3.1 patch3（AGP 7.0.3）\n先看 build.gradle(Project)\n其中两个 classpath 是 plugin 的版本，一个是 AGP，另一个是 KGP\n\nKGP\nKGP 是 Kotlin Gradle plugin\nGradle 要给所有需要编译的语言添加扩展。\n以前用的是 java 的时候，需要添加 Java Gradle plugin。\n使用 Compose 的时候，需要添加 Compose Gradle plugin\n\n\n然后看 build.gradle(app)\n\nplugins\n在 AGP 7.0+ 时，使用的 plugins，而是之前是 apply plugin\n这是版本更新后的语法变更，不用过多在意\n\n\n\n\nAndroid Studio Ladybug Feature Drop | 2024.2.2 Patch 1 （AGP 8.8.1）\n这个是出现在 gradle 使用 kotlin dsl 之后\n还是先看 build.gradle(project)\n\n这里的 alias 是引用了 /ProjectRootPath/gradle/libs.versions.toml 里面设置的变量，如图所示\n\n官方文档里提到了，您可以在 Android Studio 的 File &gt; Project Structure &gt; Project 菜单中指定插件版本，专指 AGP\n\nbuild.gradle(app)\n这里使用的还是 alias 引用的还是 /ProjectRootPath/gradle/libs.versions.toml 里面设置的变量\n\n\n\nAGP Gradle 的兼容性列表\n看过了 Gradle 配置项的变化之后，你应该明白了 Gradle 配置的关键在于 AGP 以及 KGP 的版本\n而且你可能听过，不要随便升级 Gradle 的建议，而且 Gradle 更新比较频繁，甚至有时候 Android Studio 新创建的项目还有兼容性配置的问题，所以了解兼容性列表必不可少\n详细内容可以查看官网 国际链接 国内链接\n\n\n\n插件版本\n所需的最低 Gradle 版本\n\n\n\n\n8.9\n8.11.1\n\n\n8.8\n8.10.2\n\n\n8.7\n8.9\n\n\n8.6\n8.7\n\n\n8.5\n8.7\n\n\n8.4\n8.6\n\n\n8.3\n8.4\n\n\n8.2\n8.2\n\n\n8.1\n8.0\n\n\n8.0\n8.0\n\n\n7.4\n7.5\n\n\n7.3\n7.4\n\n\n7.2\n7.3.3\n\n\n7.1\n7.2\n\n\n7.0\n7.0\n\n\n4.2.0+\n6.7.1\n\n\n4.1.0+\n6.5+\n\n\n4.0.0+\n6.1.1+\n\n\n3.6.0 - 3.6.4\n5.6.4+\n\n\n3.5.0 - 3.5.4\n5.4.1+\n\n\n3.4.0 - 3.4.3\n5.1.1+\n\n\n3.3.0 - 3.3.3\n4.10.1+\n\n\n3.2.0 - 3.2.1\n4.6+\n\n\n3.1.0+\n4.4+\n\n\n3.0.0+\n4.1+\n\n\n2.3.0+\n3.3+\n\n\n2.1.3 - 2.2.3\n2.14.1 - 3.5\n\n\n2.0.0 - 2.1.2\n2.10 - 2.13\n\n\n1.5.0\n2.2.1 - 2.13\n\n\n1.2.0 - 1.3.1\n2.2.1 - 2.9\n\n\n1.0.0 - 1.1.3\n2.2.1 - 2.3\n\n\n\nAndroid Gradle 插件和 Android Studio 兼容性\n\n\n\nAndroid Studio 版本\n所需的 AGP 版本\n\n\n\n\nMeerkat （2024.3.1）\n3.2-8.9\n\n\nLadybug 功能更新（2024.2.2）\n3.2-8.8\n\n\nLadybug （2024.2.1）\n3.2-8.7\n\n\nKoala 功能更新 （2024.1.2）\n3.2-8.6\n\n\nKoala （2024.1.1）\n3.2-8.5\n\n\nJellyfish （2023.3.1）\n3.2-8.4\n\n\nIguana （2023.2.1）\n3.2-8.3\n\n\nHedgehog （2023.1.1）\n3.2-8.2\n\n\nGiraffe （2022.3.1）\n3.2-8.1\n\n\nFlamingo （2022.2.1）\n3.2-8.0\n\n\n\nGradle JDK 兼容列表\nGradle JDK 指的是运行 Gradle 所需的 JDK 环境，不是 build.gradle 里设置的 java 版本\n在最新的 Android Studio 版本里，Gradle JDK 的设置步骤如下：\n\n步骤一：打开 File → Settings\n步骤二：在左侧导航栏选择 Build, Execution, Deployment → Build Tools → Gradle。\n步骤三：在右侧的 Gradle JDK 选项中，点击下拉菜单或右侧的文件夹图标，选择已安装的 JDK 路径（如 JetBrains Runtime (JBR) 或自定义 JDK）\n\n对于 Gradle JDK 的详细解释，可以查看 官网的这篇文章\n\n官网的建议\n在大多数情况下，我们建议使用 GRADLE_LOCAL_JAVA_HOME，这是新创建的项目的默认值。这样，您无需先打开项目，即可定义特定于项目的 JDK。\nGRADLE_LOCAL_JAVA_HOME：使用 .gradle/config.properties 文件中的 java.home 属性，默认为 JetBrains 运行时（JBR）。\njdk 配置存储在项目的 .idea/gradle.xml 文件中的 gradleJvm 选项中，其 JDK 路径解析用于在通过 Android Studio 启动时运行 Gradle。\n\n\n超级提示\n我特别烦恼在选择 jdk 的时候，有重复的项目\n\n\n你可以在下面地址找到重复项并删除 `~/Library/Application Support/Google/AndroidStudio[版本号]/options/jdk.table.xml`\n\n\n\n\nAndroid\nJava\n支持的 API 和语言功能\n\n\n\n\n14（API 34）\n17\n核心库\n\n\n13 (API 33)\n11\n核心库\n\n\n12（API 32）\n11\nJava API\n\n\n\n\nJDK\n在一开始的时候，我以为 Android 的 jdk 是和 java 项目一样，需要指定 jdk 地址的，但后来才知道，Android SDK 里包含定制的 jdk\n\n","tags":["Android","Gradle","JDK","Android Studio"]},{"title":"Android 里的 Bitmap、Drawable、Mipmap（没写完）","url":"/2023/11/07/Android-%E9%87%8C%E7%9A%84-Bitmap-Drawable-Mipmap%EF%BC%88%E6%B2%A1%E5%86%99%E5%AE%8C%EF%BC%89/","content":"Drawable 是什么？\nDrawable并不是图\nDrawable是一个抽象类，用于表示可绘制对象。本身是一个绘制工具，更像一个只专注于绘制的 View，所以一个 Drawable 显示什么，取决于它绘制什么\npackage android.graphics.drawablepublic abstract class Drawable &#123;    ...    public abstract void draw(@NonNull Canvas canvas);    ...&#125;\n-Drawable\n提供了一种通用的方式来处理不同类型的可绘制资源，无论是静态图像、矢量图形、渐变或其他形式的绘制内容。它使开发人员可以轻松地切换和管理不同类型的可绘制资源，以便用于UI\n设计。\n-Android提供了许多不同类型的Drawable子类，如BitmapDrawable（用于显示位图图像）、ShapeDrawable\n（用于绘制基本形状）、VectorDrawable（用于显示矢量图形）等\nBitmap 是什么？\nbitmap又叫位图，在Android里，它代表一个像素矩阵，含有一个图片 完整的、未压缩的 像素数据。\n既然，Bitmap是一个包含所有像素信息的矩阵，而每个像素所占空间是你固定的，所以————只要不改变 Bitmap 的尺寸，或者说只要不改变分辨率，那么 Bitmap 的占的内存就不会变，也就是说，Bitmap 的内存占用只和图片的尺寸（分辨率）有关\npackage android.graphics;public final class Bitmap implements Parcelable &#123;    ...&#125;\nMipmap 是什么？\nMipmap（多级纹理映射）是一种用于优化计算机图形中纹理映射的技术。\n纹理映射是一种在三维图形渲染中将二维图像（称为纹理）映射到三维模型表面的方法。\nMipmap 是为了提高图形性能和视觉质量而设计的。\nDrawable Bitmap 互转？？？\n了解了 Drawable 和 Bitmap 是什么，那么就回到这个老生常谈的问题了，Drawable 和 Bitmap 如何互转？？？\n其实根本没有什么互转，Bitmap 是一个包含像素信息的矩阵，而 Drawable 根本没有像素信息，那么我们如果想让 Bitmap “转为” Drawable 呢？\n只能用 Drawable 将Bitmap 画出来了，而 BitmapDrawable 就是这个工具\nval bitmapDrawable = BitmapDrawable(resource, bitmap)\n反之，如何将 Drawable “转成” Bitmap 呢？\nDrawable 并没有像素信息，但是需要用像素信息将 Bitmap 填满，该怎么办呢？\n只能将 Drawable 的信息用 canvas 绘制出来了\nfun drawableToBitmap(drawable: Drawable): Bitmap &#123;  val bitmap: Bitmap  if (drawable is BitmapDrawable) &#123;    return drawable.bitmap  &#125;  bitmap = if (drawable.intrinsicWidth &lt;= 0 || drawable.intrinsicHeight &lt;= 0) &#123;    Bitmap.createBitmap(1, 1, Bitmap.Config.ARGB_8888)  &#125; else &#123;    Bitmap.createBitmap(      drawable.intrinsicWidth,      drawable.intrinsicHeight,      Bitmap.Config.ARGB_8888    )  &#125;  val canvas = Canvas(bitmap)  drawable.setBounds(0, 0, canvas.width, canvas.height)  drawable.draw(canvas)  return bitmap&#125;\n使用 Drawable\n通过资源图片创建 Drawable\n您可以通过引用项目资源中的图片文件向应用添加图形。支持的文件类型包括 PNG（首选）、JPG（可接受）和 GIF（不建议）\n将文件添加到项目的res/drawable/目录。进入项目后，您可以从代码或 XML 布局中引用图片资源。\n注意\n在构建过程中，aapt工具可能会使用无损图片压缩功能自动优化位于res/drawable/目录中的图片资源。\n例如，可以通过调色板将不需要超过 256 种颜色的真彩色 PNG 转换为 8 位 PNG。这样做会生成质量相同但内存占用量更小的图片。\n因此，此目录中的映像二进制文件可能会在构建时发生变化。如果您打算以比特流的形式读取图片，进而将其转换为位图，请改为将图片放在res/raw/\n文件夹中，aapt工具不会修改这些图片。\n下面kotlin代码展示两种在代码里直接用 resId 引用资源的方式\nval i = ImageView(this).apply &#123;    setImageResource(R.drawable.my_image)&#125;val myImage: Drawable = ResourcesCompat.getDrawable(context.resources, R.drawable.my_image, null)\n警告\n项目中的每个唯一资源只能保留一种状态，无论您为其实例化多少个不同的对象都是如此。\n例如，如果您实例化同一图片资源中的两个 Drawable 对象，并更改一个对象的属性（例如 alpha），那么另一个对象也会受到影响。\n在处理某个图片资源的多个实例时，应执行补间动画\n，而不是直接转换 Drawable 对象。\n下面xml代码段展示了如何在XML布局中向ImageView添加可绘制资源：\n&lt;ImageView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:src=&quot;@drawable/my_image&quot;        android:contentDescription=&quot;@string/my_image_desc&quot; /&gt;\n如需详细了解如何使用项目资源，请参阅应用资源指南\n注意\n使用图片资源作为可绘制对象的来源时，请确保图片尺寸适合各种像素密度。\n如果图片不正确，系统会将其放大以匹配图片，这可能会导致可绘制对象出现伪影。\n如需了解详情，请参阅支持不同的像素密度。\n通过 XML 资源创建可绘制对象\n通过 XML 创建可绘制对象最大的好处就是，你可以设置一些可变化的属性来控制它，这样会更加灵活，也更加方便\n使用 XML 定义Drawable后，将文件保存在项目的res/drawable/目录中。\n以下示例展示了定义从Drawable\n继承的 TransitionDrawable 资源的\nXML：\n&lt;!-- res/drawable/expand_collapse.xml --&gt;&lt;transition xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;item android:drawable=&quot;@drawable/image_expand&quot;/&gt;    &lt;item android:drawable=&quot;@drawable/image_collapse&quot;/&gt;&lt;/transition&gt;\n然后，通过调用Resources#getDrawable()并传递 XML 文件的资源 ID 来检索并实例化该对象。\n所有有inflate()的 Drawable 子类，都可以在\nXML 中定义并由您的应用实例化。\n\n  \n    \n      重要提示\n\n    \n    \n      继承 Drawable 子类的自定义类，必须重写 getConstantState()方法。\n请参阅下面的自定义可绘制对象中的要点。\n\n    \n  \n以下代码会实例化 TransitionDrawable\n并将其设置为ImageView对象的内容：\nval transition= ResourcesCompat.getDrawable(        context.resources,        R.drawable.expand_collapse,        null) as TransitionDrawableval image: ImageView = findViewById(R.id.toggle_image)image.setImageDrawable(transition)// 对图片初始状态的内容描述image.contentDescription = resources.getString(R.string.collapsed)// 调用 transition 的方法transition.startTransition(1000)// 转换完成后，更改图片的内容描述// 反映新状态。\n\n  \n    \n      提示\n\n    \n    \n      TransitionDrawable  继承自 LayerDrawables，可以让我们在两层图像中设置淡入淡出效果\n\n    \n  \nShape drawables\nShape Drawable  继承自 Drawable 可以让你通过写代码的方式绘制一个图形\n\n  \n    \n      提示\n\n    \n    \n      Shape Drawable 并不算是矢量图，因为它可以设置具体的像素大小\n\n    \n  \n由于具有自己的draw()方法，因此你可以在自定义View的onDraw()事件期间调用ShapeDrawable的draw()方法。\n如下面的代码示例所示：\nclass CustomDrawableView(context: Context) : View(context) &#123;    private val drawable: ShapeDrawable = run &#123;        val x = 10        val y = 10        val width = 300        val height = 50        contentDescription = context.resources.getString(R.string.my_view_desc)        ShapeDrawable(OvalShape()).apply &#123;            // If the color isn&#x27;t set, the shape uses black as the default.            paint.color = 0xff74AC23.toInt()            // If the bounds aren&#x27;t set, the shape can&#x27;t be drawn.            setBounds(x, y, x + width, y + height)        &#125;    &#125;    override fun onDraw(canvas: Canvas) &#123;        drawable.draw(canvas)    &#125;&#125;\n然后就像使用任何其他自定义View一样\nprivate lateinit var customDrawableView: CustomDrawableViewoverride fun onCreate(savedInstanceState: Bundle?) &#123;    super.onCreate(savedInstanceState)    customDrawableView = CustomDrawableView(this)    setContentView(customDrawableView)&#125;\n&lt;com.example.shapedrawable.CustomDrawableView        android:layout_width=&quot;wrap_parent&quot;        android:layout_height=&quot;wrap_content&quot;/&gt;\nNinePatch drawables(.9图片)\nNinePatchDrawable\n图形是可拉伸的位图图像，可用作视图的背景。\nAndroid会自动调整图形大小以适应视图的内容。\nNinePatch 图像的一个示例是标准 Android 按钮使用的背景，按钮必须拉伸以容纳各种长度的字符串。\nNinePatch 图形是标准的 PNG 图像，其中包含额外的 1 像素边框。\n它必须与9.png扩展名一起保存在项目res/drawable/目录中，并且还需要删除原图像，否则会报重复错误。\n绘制方法\n\n通过在边框的左侧和顶部绘制一条（或多条）1 像素宽的黑线来指示可拉伸部分（其他边框像素应为完全透明或白色）\n在右侧绘制一条线，在底部绘制一条线来定义图像的可绘制部分（实际上是填充线）。也就是你设置text填充的地方\n\n\nCustom drawables（自定义 Drawable）\n自定义Drawable类似于 自定义View\n下面的代码显示了绘制圆圈的简单自定义Drawable\nclass MyDrawable : Drawable() &#123;    private val redPaint: Paint = Paint().apply &#123; setARGB(255, 255, 0, 0) &#125;    override fun draw(canvas: Canvas) &#123;        // Get the drawable&#x27;s bounds        val width: Int = bounds.width()        val height: Int = bounds.height()        val radius: Float = Math.min(width, height).toFloat() / 2f        // Draw a red circle in the center        canvas.drawCircle((width / 2).toFloat(), (height / 2).toFloat(), radius, redPaint)    &#125;    override fun setAlpha(alpha: Int) &#123;            &#125;    override fun setColorFilter(colorFilter: ColorFilter?) &#123;            &#125;    // PixelFormat.UNKNOWN, TRANSLUCENT, TRANSPARENT, 或者 OPAQUE    override fun getOpacity(): Int = PixelFormat.OPAQUE&#125;\nAdd tint to drawables（为可绘制对象添加色调）\n对于 Android 5.0（API 级别 21）及更高版本，您可为位图和定义为 Alpha 蒙版的位图和九宫格着色。\n您可以使用颜色资源或解析为颜色资源（例如?android:attr/colorPrimary）的主题属性为其着色。通常，您只需创建一次这些资源，然后自动为其着色以与您的主题相符。\n您可以使用setTint()方法对BitmapDrawable、NinePatchDrawable或VectorDrawable对象着色。\n您还可以使用android:tint和android:tintMode属性在布局中设置色调颜色和模式。\n详细信息请看样式和主题背景\n从图片中萃取突出颜色\nAndroid 支持库包含Palette类，可让您从图片中提取突出颜色。\n您可以将可绘制对象作为Bitmap加载，并将其传递给Palette\n以获取其颜色。如需了解详情，请参阅使用 Palette API 选择颜色。\nVector drawables（矢量图）\n\nVector drawable 是一种矢量图形，在 XML 文件中定义为一组点、线条和曲线及其关联的颜色信息。\nVector drawable 可缩放，这意味着，可在不降低显示质量的情况下调整大小。因此，它们是 Android 应用的理想选择，有助于缩减 APK\n文件的大小并提升性能。\n您可以在 Android Studio 中创建矢量可绘制对象，方法是右键点击项目中的可绘制对象文件夹，然后依次选择“New”&gt;“Vector\nAsset”。您还可以将 SVG 文件作为矢量可绘制对象导入 Android Studio。\n\n关于 VectorDrawable 类\nVectorDrawable定义静态可绘制对象。与 SVG 格式类似，每个矢量图形被定义为一个树层次结构，由path和group\n对象组成。每个path都包含对象轮廓的几何图形，group包含转换的详细信息。所有路径的绘制顺序均与它们在 XML 文件中显示的顺序相同。\n\nVector Asset Studio 工具提供了一种将矢量图形作为\nXML 文件添加到项目中的简单方法。\n示例\n以下VectorDrawableXML 文件示例会渲染充电模式下电池的图片。\n&lt;!-- res/drawable/battery_charging.xml --&gt;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;        android:height=&quot;24dp&quot;        android:width=&quot;24dp&quot;        android:viewportWidth=&quot;24.0&quot;        android:viewportHeight=&quot;24.0&quot;&gt;    &lt;group            android:name=&quot;rotationGroup&quot;            android:pivotX=&quot;10.0&quot;            android:pivotY=&quot;10.0&quot;            android:rotation=&quot;15.0&quot;&gt;        &lt;path                android:name=&quot;vect&quot;                android:fillColor=&quot;#FF000000&quot;                android:pathData=&quot;M15.67,4H14V2h-4v2H8.33C7.6,4 7,4.6 7,5.33V9h4.93L13,7v2h4V5.33C17,4.6 16.4,4 15.67,4z&quot;                android:fillAlpha=&quot;.3&quot;/&gt;        &lt;path                android:name=&quot;draw&quot;                android:fillColor=&quot;#FF000000&quot;                android:pathData=&quot;M13,12.5h2L11,20v-5.5H9L11.93,9H7v11.67C7,21.4 7.6,22 8.33,22h7.33c0.74,0 1.34,-0.6 1.34,-1.33V9h-4v3.5z&quot;/&gt;    &lt;/group&gt;&lt;/vector&gt;\n此 XML 会渲染以下图片：\n\n关于 AnimatedVectorDrawable 类\nAnimatedVectorDrawable用于为矢量图形的属性添加动画。您可以将动画矢量图形定义为三个单独的资源文件或定义整个可绘制对象的单个\nXML 文件。\n为了更好地理解，我们来看看这两种方法：多个 XML 文件\n和单个 XML 文件。\n多个 XML 文件\n使用此方法，您可以定义三个单独的 XML 文件：\n\n一个VectorDrawableXML 文件。\n-AnimatedVectorDrawableXML 文件，用于定义目标VectorDrawable\n、要添加动画效果的目标路径和组、属性，以及定义为ObjectAnimator对象或AnimatorSet对象的动画。\n一个 Animator XML 文件。\n\n\n  \n    \n      示例\n\n    \n    \n      The following XML files demonstrate the animation of a vector graphic.\n以下 XML 文件演示矢量图形的动画。\n\nVectorDrawable 的 XML 文件：vd.xml\n\n &lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;   android:height=&quot;64dp&quot;   android:width=&quot;64dp&quot;   android:viewportHeight=&quot;600&quot;   android:viewportWidth=&quot;600&quot; &gt;   &lt;group      android:name=&quot;rotationGroup&quot;      android:pivotX=&quot;300.0&quot;      android:pivotY=&quot;300.0&quot;      android:rotation=&quot;45.0&quot; &gt;      &lt;path         android:name=&quot;vectorPath&quot;         android:fillColor=&quot;#000000&quot;         android:pathData=&quot;M300,70 l 0,-70 70,70 0,0 -70,70z&quot; /&gt;   &lt;/group&gt;&lt;/vector&gt;\n\nAnimatedVectorDrawable 的 XML 文件：avd.xml\n\n &lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;   android:drawable=&quot;@drawable/vd&quot; &gt;     &lt;target         android:name=&quot;rotationGroup&quot;         android:animation=&quot;@anim/rotation&quot; /&gt;     &lt;target         android:name=&quot;vectorPath&quot;         android:animation=&quot;@anim/path_morph&quot; /&gt;&lt;/animated-vector&gt;\n\nAnimatedVectorDrawable 的 XML 文件中使用的 Animator XML 文件：rotation.xml以及path_morph.xml\n\n &lt;objectAnimator   android:duration=&quot;6000&quot;   android:propertyName=&quot;rotation&quot;   android:valueFrom=&quot;0&quot;   android:valueTo=&quot;360&quot; /&gt;\n &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;   &lt;objectAnimator      android:duration=&quot;3000&quot;      android:propertyName=&quot;pathData&quot;      android:valueFrom=&quot;M300,70 l 0,-70 70,70 0,0   -70,70z&quot;      android:valueTo=&quot;M300,70 l 0,-70 70,0  0,140 -70,0 z&quot;      android:valueType=&quot;pathType&quot;/&gt;&lt;/set&gt;\n\n    \n  \n单个 XML 文件\n通过使用此方法，可以通过 XML 捆绑格式将相关的 XML 文件合并到单个 XML 文件中。\n在构建应用时，aapt标记会创建单独的资源，并在动画矢量中引用它们。\n此方法需要生成工具 24 或更高版本，并且输出向后兼容。\n\n  \n    \n      示例\n\n    \n    \n      &lt;animated-vector        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;        xmlns:aapt=&quot;http://schemas.android.com/aapt&quot;&gt;    &lt;aapt:attr name=&quot;android:drawable&quot;&gt;        &lt;vector                android:width=&quot;24dp&quot;                android:height=&quot;24dp&quot;                android:viewportWidth=&quot;24&quot;                android:viewportHeight=&quot;24&quot;&gt;            &lt;path                    android:name=&quot;root&quot;                    android:strokeWidth=&quot;2&quot;                    android:strokeLineCap=&quot;square&quot;                    android:strokeColor=&quot;?android:colorControlNormal&quot;                    android:pathData=&quot;M4.8,13.4 L9,17.6 M10.4,16.2 L19.6,7&quot;/&gt;        &lt;/vector&gt;    &lt;/aapt:attr&gt;    &lt;target android:name=&quot;root&quot;&gt;        &lt;aapt:attr name=&quot;android:animation&quot;&gt;            &lt;objectAnimator                    android:propertyName=&quot;pathData&quot;                    android:valueFrom=&quot;M4.8,13.4 L9,17.6 M10.4,16.2 L19.6,7&quot;                    android:valueTo=&quot;M6.4,6.4 L17.6,17.6 M6.4,17.6 L17.6,6.4&quot;                    android:duration=&quot;300&quot;                    android:interpolator=&quot;@android:interpolator/fast_out_slow_in&quot;                    android:valueType=&quot;pathType&quot;/&gt;        &lt;/aapt:attr&gt;    &lt;/target&gt;&lt;/animated-vector&gt;\n\n    \n  \n矢量可绘制对象向后兼容解决方案\n为了在运行平台版本低于 Android 5.0（API 级别 21）的设备上支持矢量可绘制对象和添加动画效果的矢量可绘制对象，或使用低于\nAndroid 7.0（API 级别 24）的fillColor、fillType和strokeColor功能，VectorDrawableCompat\n和AnimatedVectorDrawableCompat可通过两个支持库分别通过support-vector-drawable和animated-vector-drawable获得。\nAndroid Studio 1.4 通过在构建时生成 PNG 文件引入了对矢量可绘制对象的有限兼容性支持。不过，矢量可绘制对象和动画矢量可绘制对象支持库既灵活又具有广泛的兼容性，它是一个支持库，因此您可以在低至\nAndroid 2.1（API 级别 7 及更高级别）的所有 Android 平台版本中使用它。如需将应用配置为使用矢量支持库，请将vectorDrawables\n元素添加到应用模块的build.gradle文件中。\n使用以下代码段配置vectorDrawables元素：\n// For Gradle Plugin 2.0+android &#123;    defaultConfig &#123;        vectorDrawables.useSupportLibrary = true    &#125;&#125;\n// For Gradle Plugin 1.5 or belowandroid &#123;    defaultConfig &#123;        // Stops the Gradle plugin’s automatic rasterization of vectors        generatedDensities()    &#125;    // Flag notifies aapt to keep the attribute IDs around    aaptOptions &#123;        additionalParameters(&quot;--no-version-vectors&quot;)    &#125;&#125;\n您可以在搭载 Android 4.0（API 级别 14）及更高版本的所有设备上使用VectorDrawableCompat\n和AnimatedVectorDrawableCompat。\nAndroid 加载可绘制对象的方式（而不是每个接受可绘制对象 ID 的地点（例如 XML 文件中）都支持加载矢量可绘制对象。\nandroid.support.v7.appcompat软件包添加了许多功能，以便轻松使用矢量可绘制对象。\n首先，当您将android.support.v7.appcompat软件包与ImageView或ImageButton和FloatingActionButton\n等子类一起使用时，可以使用新的app:srcCompat属性来引用矢量可绘制对象以及android:src可用的任何其他可绘制对象：\n&lt;ImageView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        app:srcCompat=&quot;@drawable/ic_add&quot;/&gt;\n\n\n要在运行时更改可绘制对象，您可以像以前一样使用setImageResource()\n方法。要将矢量可绘制对象集成到应用中，使用AppCompat和app:srcCompat是最万无一失的方法。\n支持库 25.4.0 及更高版本支持以下功能：\n\n路径变形（PathType 评估器）：用于将一条路径变形为另一个路径。\n路径插值：用于定义灵活的插值器（表示为路径），而不是系统定义的插值器（如 LinearInterpolator）。\n支持库 26.0.0-beta1 及更高版本支持以下功能：\n沿路径移动：几何图形对象可以在动画中沿着任意路径四处移动。\n\n\n\n使用支持库的多个 XML 文件的示例\n\n\n以下 XML 文件演示了使用多个 XML 文件为矢量图形添加动画效果的方法。\n\nVectorDrawable 的 XML 文件：vd.xml\n\n &lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;   android:height=&quot;64dp&quot;   android:width=&quot;64dp&quot;   android:viewportHeight=&quot;600&quot;   android:viewportWidth=&quot;600&quot; &gt;   &lt;group      android:name=&quot;rotationGroup&quot;      android:pivotX=&quot;300.0&quot;      android:pivotY=&quot;300.0&quot;      android:rotation=&quot;45.0&quot; &gt;      &lt;path         android:name=&quot;vectorPath&quot;         android:fillColor=&quot;#000000&quot;         android:pathData=&quot;M300,70 l 0,-70 70,70 0,0 -70,70z&quot; /&gt;   &lt;/group&gt;&lt;/vector&gt;\n\nAnimatedVectorDrawable 的 XML 文件：avd.xml\n\n &lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;   android:drawable=&quot;@drawable/vd&quot; &gt;     &lt;target         android:name=&quot;rotationGroup&quot;         android:animation=&quot;@anim/rotation&quot; /&gt;&lt;/animated-vector&gt;\n\nAnimator XML file that is used in the AnimatedVectorDrawable’s XML file:rotation.xml\n\n &lt;objectAnimator   android:duration=&quot;6000&quot;   android:propertyName=&quot;rotation&quot;   android:valueFrom=&quot;0&quot;   android:valueTo=&quot;360&quot; /&gt;\n以下 XML 文件演示了使用单个 XML 文件为矢量图形添加动画效果的方法。构建应用时，aapt标记会创建单独的资源，并在动画矢量中引用这些资源。此方法需要\nBuild Tools 24 或更高版本，并且输出可向后兼容。\n\n单个 XML 文件的示例\n\n&lt;animated-vector        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;        xmlns:aapt=&quot;http://schemas.android.com/aapt&quot;&gt;    &lt;aapt:attr name=&quot;android:drawable&quot;&gt;        &lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;                android:width=&quot;64dp&quot;                android:height=&quot;64dp&quot;                android:viewportWidth=&quot;600&quot;                android:viewportHeight=&quot;600&quot;&gt;            &lt;group                    android:name=&quot;rotationGroup&quot;                    android:pivotX=&quot;300&quot;                    android:pivotY=&quot;300&quot;                    android:rotation=&quot;45.0&quot;&gt;                &lt;path                        android:name=&quot;vectorPath&quot;                        android:fillColor=&quot;#000000&quot;                        android:pathData=&quot;M300,70 l 0,-70 70,70 0,0 -70,70z&quot;/&gt;            &lt;/group&gt;        &lt;/vector&gt;    &lt;/aapt:attr&gt;    &lt;target android:name=&quot;rotationGroup&quot;&gt;        &lt;aapt:attr name=&quot;android:animation&quot;&gt;            &lt;objectAnimator                    android:propertyName=&quot;rotation&quot;                    android:valueFrom=&quot;0&quot;                    android:valueTo=&quot;360&quot;                    android:duration=&quot;6000&quot;                    android:interpolator=&quot;@android:interpolator/fast_out_slow_in&quot;/&gt;        &lt;/aapt:attr&gt;    &lt;/target&gt;&lt;/animated-vector&gt;\n使用 Bitmap\n位深和色深\n首先我们需要理解两个概念：位深和色深\n\n可以看到其实这是一个非常有歧义的概念\n\n  \n    \n      重要提示\n\n    \n    \n      通常说 8bit 图指的是每个颜色通道占 8 位，也就也是 28=255位2^8 = 255\\text{位}28=255位（0 ~ 255）\n如果是 RGB 格式，那总共就占 3×8=24 位，RGBA 格式总共就占 4×8=32 位\n不用太过于纠结这两个概念，只要能清楚描述每个像素的占用就行\n包括买显示器的时候也要注意，不要看话术，关键在于像素排列，每个像素占几位（也就是色彩范围）\n\n    \n  \n接下来我们看看 Bitmap 的创建，处理，序列化\n存储格式\n就位图的存储格式而言，我们会想到 PNG，JPG\n当然，Android 也确实给了我们这些格式\n// android.graphics.Bitmappublic enum CompressFormat &#123;    JPEG          (0),    PNG           (1),    @Deprecated    WEBP          (2),    WEBP_LOSSY    (3),    WEBP_LOSSLESS (4);    CompressFormat(int nativeInt) &#123;        this.nativeInt = nativeInt;    &#125;    final int nativeInt;&#125;\n\n\n\n枚举值\nBitmap.CompressFormat\n\n\n\n\nJPEG\n压缩为 JPEG 格式。\n\n\nPNG\nCompress to the PNG format.  压缩为 PNG 格式。\n\n\nWEBP\n此字段在 API 级别 30 中已弃用。赞成更明确的CompressFormat#WEBP_LOSSY和CompressFormat#WEBP_LOSSLESS.*\n\n\nWEBP_LOSSLESS\n压缩为 WEBP 无损格式。\n\n\nWEBP_LOSSY\n压缩为 WEBP 有损格式。\n\n\n\n色彩格式\n同样，图片他肯定会有色彩格式，什么 256色，8位色，RGB，RGBA\n这个 Android 肯定也给了\npublic enum Config &#123;    ALPHA_8(1),    RGB_565(3),    @Deprecated    ARGB_4444(4),    ARGB_8888(5),    RGBA_F16(6),    HARDWARE(7),    RGBA_1010102(8);    @UnsupportedAppUsage    final int nativeInt;    private static Config sConfigs[] = &#123;        null, ALPHA_8, null, RGB_565, ARGB_4444, ARGB_8888, RGBA_F16, HARDWARE, RGBA_1010102    &#125;;    Config(int ni) &#123;        this.nativeInt = ni;    &#125;    @UnsupportedAppUsage    static Config nativeToConfig(int ni) &#123;        return sConfigs[ni];    &#125;&#125;\n\n\n\n枚举值\nBitmap.Config\n\n\n\n\nALPHA_8\n每个像素都存储为单个半透明 （alpha） 通道，每个像素占一个字节。\n\n\nARGB_4444\nRGBA 组成，每部分占 4 位，共 16 位。每个像素占 2 字节此字段在 API 级别 29 中已弃用。由于此配置的质量较差，建议改用ARGB_8888。*\n\n\nARGB_8888\nRGBA 组成，每部分占 8 位，共 32 位。每个像素占 4 字节。\n\n\nHARDWARE\n特殊配置，当位图仅存储在图形内存中时。\n\n\nRGBA_1010102\n每个像素占 4 字节。\n\n\nRGBA_F16\n每个像素占 8 字节。\n\n\nRGB_565\n每个像素占 2 字节，仅对 RGB 通道进行编码：红色 5 位，绿色 6 位，蓝色 5 位。\n\n\n\n一般情况下，我们不会使用 ALPHA_8,他只存储透明度，没啥用处。\n对于 ARGB_4444，它的画质又太感人了。\nARGB_8888 画质高但是太占内存。\nRGB_565 还行，就是不可以设置透明度。\n注意以下三点即可：\n\n一般情况下用 ARGB_8888 格式存储 Bitmap\nARGB_4444 画面惨不忍睹，被弃用\n假如对图片没有透明度要求，可以使用 RGB_565，比 ARGB_8888 节省一半的内存开销\n\n创建方法\nBitmapFactory\n\n可见 BitmapFactory 有很多方便我们将图片加载成 Bitmap 的方法，并且还有一个 Options 类来方便我们进行一些其他的配置\n接下来我们看看 bitmapFactory.Options\n\n可以看到有很多成员变量，根据前缀可以将他们分为，in 开头和 out 开头\n\n\nin 前缀：这些成员变量是用作输入参数，在调用 decode 方法时，你可以设置这些选项来影响图像的加载方式。\n例如，inSampleSize 用于指定图像的采样率，inPreferredConfig 用于指定图像的颜色配置，inJustDecodeBounds 用于仅获取图像的尺寸信息而不加载整个图像等等。这些选项用于控制图像的加载行为和内存使用情况。\n\n\nout 前缀：这些成员变量在调用 decode 方法后会被填充和更新，用于返回有关加载图像的信息。\n例如，outWidth 和 outHeight 用于存储解码后图像的宽度和高度信息，outMimeType 用于存储解码后图像的 MIME 类型，outColorSpace 用于存储解码后图像的色彩空间等等。这些选项用于获取解码后图像的信息而无需加载整个图像。\n\n\nBitmap\n\n这里的方法都是创建空白的 Bitmap 或者需要自己绘制的 Bitmap\n压缩\n计算 Bitmap 大小\n\n我们加载这个漂亮的（实际文件大小是 192309 字节）\n根据我们的了解，如果我们加载这张图片， 应该是 1920 × 1080×4 = 8294400 byte\n我们计算验证一下\nval bitmap = BitmapFactory.decodeResource(resources, resId)Log.i(  &quot;lucas&quot;,  &quot;bitmap=$&#123;bitmap.byteCount&#125;\\n宽度=$&#123;bitmap.width&#125;\\n高度=$&#123;bitmap.height&#125;&quot;)\nbitmap=62726400宽度=5280高度=2970\n这三个数是怎么来的呢？\n首先宽度和高度，需要经过 dp 和 px 的换算，获取 desity 为 2.75，而这个 density 就是 Bitmap 的密度，当然你也可以自定义密度，但默认用的是系统自己的密度\n宽度 = 1920×2.75 = 5280\n高度 = 1080×2.75 = 2970\nbitmap 的 ByteCount = 4 × 宽度 × 高度 = 62726400（4 是因为 ARGB_8888 一个像素占 4字节）\n62726400 byte ≈ 59.82 MB\n可以看到，62726400 ÷ 192309 ≈ 326.175 加载这个图片会直接放大 326 倍\n这个占用可以说是非常恐怖了\n质量压缩\n对于一张图片，我们在不改变分辨率的情况下，改变它的像素的占用，或者将效果不明显的像素删除以方便压缩至更小体积，这就是质量压缩\n质量压缩不会改变 Bitmap 的内存占用（因为 Bitmap 的内存占用只和尺寸有关），但会改变序列化到硬盘里的图片文件大小\nByteArrayOutputStream baos = new ByteArrayOutputStream();int quality = Integer.valueOf(editText.getText().toString());bit.compress(CompressFormat.JPEG, quality, baos);byte[] bytes = baos.toByteArray();bm = BitmapFactory.decodeByteArray(bytes, 0, bytes.length);\n尺寸压缩\n尺寸压缩，顾名思义，就是将尺寸缩小（或者说分辨率降低），以此来压缩图片\n尺寸压缩会直接缩小 Bitmap 的内存占用，也会压缩输出到硬盘的图片文件大小\n\n\n改变 inSampleSize\nfun decodeSampleBitmapFromResource(  res: Resources,  resId: Int,  reqWidth: Int,  reqHeight: Int): Bitmap &#123;  // 获取图片的原始宽高  val options = BitmapFactory.Options()  options.inJustDecodeBounds = true  BitmapFactory.decodeResource(res, resId, options)  // 计算缩放比例  options.inSampleSize = calculateInSampleSize(options,    reqWidth, reqHeight)  options.inJustDecodeBounds = false  return BitmapFactory.decodeResource(res, resId, options)&#125;private fun calculateInSampleSize(  options: BitmapFactory.Options,  reqWidth: Int,  reqHeight: Int): Int &#123;  val height = options.outHeight  val width = options.outWidth  var inSampleSize = 1  if (height &gt; reqHeight || width &gt; reqWidth) &#123;    val halfHeight = height / 2    val halfWidth = width / 2    while (halfHeight / inSampleSize &gt;= reqHeight &amp;&amp; halfWidth /   inSampleSize &gt;= reqWidth) &#123;      inSampleSize *= 2    &#125;  &#125;  return inSampleSize&#125;\n\n\n改变 inDensity\n这个变量就是改变 Bitmap 密度的\n如果你将\n\n\n","tags":["Android","Bitmap","Drawable","Mipmap","图片处理"]},{"title":"Android小技巧01-长按持续输出","url":"/2023/12/02/Android%E5%B0%8F%E6%8A%80%E5%B7%A701-%E9%95%BF%E6%8C%89%E6%8C%81%E7%BB%AD%E8%BE%93%E5%87%BA/","content":"问题\n如果你要做一个功能：有 4 个按钮，按着按钮的时候，间隔 500ms 循环调用某个函数（比如打印一条 log，或者改某个数值），并且按下每个按钮，也不能影响其他按钮的按下状态，该怎么做？\n解决思路\n你当然会直接想到 setOnTouchListener ，但是很快就会发现，按钮的按下事件只会回调一次\n\n  \n    \n      与多次回调的区别\n\n    \n    \n      如果你调用过 C++ 的 glfw 或者 Java 的 JFrame KeyListener\n你一定知道，按键是会一直回调的，当你按下一个按键的时候，他会一直给你回调输入的按键，频率基于采样率\nif (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;  glfwSetWindowShouldClose(window, true);&#125;\n我们可以直接判断回调事件，然后在每次事件后调用我们上面提到的“某个函数”\n\n    \n  \n但我们在 Android 这种只回调一次的情况该怎么办呢？\n新开子线程\n每个按钮设置一个标志位，按下的时候，将标志位设为按下状态，然后再子线程里，循环输出这个结果\n@Volatilevar is1Pressing = falsevar is2Pressing = falsevar is3Pressing = falsevar is4Pressing = falseval ttt = Thread &#123;  while (true) &#123;    if (is1Pressing || is2Pressing || is3Pressing || is4Pressing)      when &#123;        is1Pressing -&gt; &#123;          log(&quot;thread name = $&#123;Thread.currentThread().name&#125;  button 1 is pressed&quot;)        &#125;        is2Pressing -&gt; &#123;          log(&quot;thread name = $&#123;Thread.currentThread().name&#125;  button 2 is pressed&quot;)        &#125;        is3Pressing -&gt; &#123;          log(&quot;thread name = $&#123;Thread.currentThread().name&#125;  button 3 is pressed&quot;)        &#125;        is4Pressing -&gt; &#123;          log(&quot;thread name = $&#123;Thread.currentThread().name&#125;  button 4 is pressed&quot;)        &#125;      &#125;    Thread.sleep(500)  &#125;&#125;\n代码结构就是这样，按下那个按钮，就更改哪个按键的状态\n使用主线程Handler\n我们可以使用 postDelay 函数\nprivate fun startPress(btn: Button) &#123;  pressStateSet(btn, true)  handler.post(object : Runnable &#123;    override fun run() &#123;      log(&quot;isPressing = $&#123;pressStateGet(btn)&#125; time second = $&#123;System.currentTimeMillis() / 1000 % 3600&#125;&quot;)      if (pressStateGet(btn)) &#123;        btnActionMap[btn.id]?.let &#123;          cameraBinding.cameraGLSurfaceView.processIn(it)        &#125;        handler.postDelayed(this, 500)      &#125;    &#125;  &#125;)&#125;private fun stopPress(btn: Button) &#123;  pressStateSet(btn, false)&#125;\nsetOnTouchListener 传入 ACTION_DOWN 事件时，就调用这个函数，这个函数第 10 行，会把 runnable 自身 post 过去，除非 pressState 为 false\n模仿实现重复回调\n\n  \n    \n      如果你需要实现重复回调的操作\n\n    \n    \n      如果你需要实现多次回调的操作，就跟 C++ glfw 或者 Java Jframe 的样子，只需要将间隔书改为 16.6 ms（1s/60 ≈ 16.6ms）\n当然，如果你的硬件刷新率为 120hz，也可以设成 8.8ms\n\n    \n  \n","tags":["Android","线程","thread","kotlin","handler"]},{"title":"Android 里的 dpi dp px","url":"/2023/11/08/Android-%E9%87%8C%E7%9A%84-dpi-dp-px/","content":"概念\nDpi (Dots Per Inch)\n每英寸点数，原本是从打印机过来的概念，对于显示屏幕，用 ppi\n很多刚接触Android开发的小伙伴，对于这个dp一脸懵逼，百度了很久，也是一些计算dpi的方法，根本没有讲到点子上！\n我们需要先了解一下这个DisplayMetrics类\n里面有几个常用的常量\nLog.d(&quot;lucas&quot;, &quot;density = $&#123;resources.displayMetrics.density&#125;&quot;)Log.d(&quot;lucas&quot;, &quot;densityDpi = $&#123;resources.displayMetrics.densityDpi&#125;&quot;)Log.d(&quot;lucas&quot;, &quot;heightPixels = $&#123;resources.displayMetrics.heightPixels&#125;&quot;)Log.d(&quot;lucas&quot;, &quot;widthPixels = $&#123;resources.displayMetrics.widthPixels&#125;&quot;)Log.d(&quot;lucas&quot;, &quot;xdpi = $&#123;resources.displayMetrics.xdpi&#125;&quot;)Log.d(&quot;lucas&quot;, &quot;ydpi = $&#123;resources.displayMetrics.ydpi&#125;&quot;)\n// 显示的逻辑密度，也就是一个比例。// 其中 1 DIP等于一个屏幕密度为160 DPI的屏幕上的一个物理像素，提供系统显示的基线。// 因此，在 160dpi 屏幕上，此密度值将为 1；在 120 dpi 的屏幕上，它将是 0.75。// 此值并不完全遵循实际屏幕大小（由 xdpi 和 ydpi给出），而是用于根据显示 dpi 的粗略变化分步缩放整个 UI 的大小。// 例如，即使 240x320 屏幕的宽度为 1.8 英寸、1.3 英寸等，其密度也将为 1。// 但是，如果屏幕分辨率增加到 320x480，但屏幕尺寸仍为 1.5“x2”，则密度将增加（可能增加到 1.5）。density = 2.75// 就是屏幕密度以每英寸点数表示densityDpi = 440// 可用显示大小的绝对高度（以像素为单位）heightPixels = 2250// 可用显示大小的绝对宽度（以像素为单位）widthPixels = 1080// X 维度中每英寸屏幕的确切物理像素数。xdpi = 386.366// Y 维度中每英寸屏幕的确切物理像素数。ydpi = 386.701\n\n  \n    \n      DIP???\n\n    \n    \n      DIP（Density-Independent Pixel 密度无关像素）：\n这个就是我们平时用的 dp\ndp 要和 px 转化，要用到Android里面的density\n公式是：1dp=density×1px1dp=density×1px1dp=density×1px\ndensity 并不会完全按照 dpi 进行非常紧密的比例变化，而是会有几个等级，\n\n    \n  \n\n\n\n密度限定符\ndensity\n说明\n\n\n\n\nldpi\n0.75\n适用于低密度 (ldpi) 屏幕 (~ 120dpi) 的资源。\n\n\nmdpi\n1.0\n适用于中密度 (mdpi) 屏幕 (~ 160dpi) 的资源（这是基准密度）。\n\n\nhdpi\n1.5\n适用于高密度 (hdpi) 屏幕 (~ 240dpi) 的资源。\n\n\nxhdpi\n2.0\n适用于加高 (xhdpi) 密度屏幕 (~ 320dpi) 的资源。\n\n\nxxhdpi\n3.0\n适用于超超高密度 (xxhdpi) 屏幕 (~ 480dpi) 的资源。\n\n\nxxxhdpi\n4.0\n适用于超超超高密度 (xxxhdpi) 屏幕 (~ 640dpi) 的资源。\n\n\nnodpi\n1.0\n适用于所有密度的资源。这些是与密度无关的资源。无论当前屏幕的密度是多少，系统都不会缩放以此限定符标记的资源。\n\n\ntvdpi\n\n适用于密度介于 mdpi 和 hdpi 之间的屏幕（约 213dpi）的资源。这不属于“主要”密度组。它主要用于电视，而大多数应用都不需要它。对于大多数应用而言，提供 mdpi 和 hdpi 资源便已足够，系统将视情况对其进行缩放。如果您发现有必要提供 tvdpi 资源，应按一个系数来确定其大小，即 1.33*mdpi。例如，如果某张图片在 mdpi 屏幕上的大小为 100px x 100px，那么它在 tvdpi 屏幕上的大小应该为 133px x 133px。\n\n\n\n网上通常是下面的转换方式\nfun Context.dpToPx(dp: Float): Float &#123;  val density: Float = this.resources.displayMetrics.density  return (dp * density)&#125;fun Context.pxToDp(px: Float): Float &#123;  val density: Float = this.resources.displayMetrics.density  return (px / density)&#125;\n又或者这种\nfun Float.toPx(): Float &#123;  return TypedValue.applyDimension(    TypedValue.COMPLEX_UNIT_DIP,    this,    Resources.getSystem().displayMetrics  )&#125;@RequiresApi(34)fun Float.toDp(): Float &#123;  return TypedValue.deriveDimension(    TypedValue.COMPLEX_UNIT_DIP,    this,    Resources.getSystem().displayMetrics  )&#125;\n第一种需要 Context，第二种 Api 有兼容性问题，因为deriveDimension是在 api34 才添加进来的\n所以我们只要用Resources.getSystem().displayMetrics.density就没有了以上的问题\nfun Float.toPx(): Float &#123;  val density: Float = Resources.getSystem().displayMetrics.density  return (this * density)&#125;fun Float.toDp(): Float &#123;  val density: Float = Resources.getSystem().displayMetrics.density  return (this / density)&#125;\nadb 命令中 wm density 这里的数值 指的是 dpi 并不是刚才提到的那个比例\nadb shell wm density 160\n\n  \n    \n      提问：分辨率相同、尺寸不同的屏幕，将density设为相同的值，显示效果看起来是否一致的呢？\n\n    \n    \n      答案是：不一致！\n因为相同分辨率下，屏幕的物理尺寸越大，像素块的物理尺寸就会越大\n如果屏幕的像素块的物理尺寸是不一样的，那显示效果是不一致的\n也就是同样 100px 的大小，像素块的物理尺寸是不同的，所以实际显示的尺寸也是不一样的\n\n    \n  \n","tags":["Android","dpi","dp","px"]},{"title":"Android自定义View02 - 绘制流程","url":"/2023/12/08/Android%E8%87%AA%E5%AE%9A%E4%B9%89View02-%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/","content":"概述\nAndroid 坐标系都是以左上角为原点，并且 view、canvas、Camera 是一个独立的坐标系\n所以在进行绘制的时候，比如：自定义 Drawable 或者自定义 View，该如何去思考这个绘制流程呢？\n如过你看过扔物线的视频或者文章，又或者在网上搜索过，一定知道 “倒着写绘制流程” 这种方法，但为什么要倒着写呢？？？\n今天我来讲解更详细的内部原理\n原理\n原理就是，Android 里面使用的都是 列矩阵右乘\n也就是说，你需要反着写绘制流程才会正常的矩阵变换流程\n\n  \n    本文内容需要对矩阵的左乘右乘有一定的理解，比如列矩阵左乘是对被乘物体的变换。\n这些知识应该是很容易就可以在网上搜索到的，如果你之前已经了解了一些，那往下看也许会帮你回想起来一些\n\n  \n左乘\n按理说，如果我们想要对一个坐标系里的物体进行变换，如果我们使用的是列向量，我们应该用变换矩阵左乘它\n比如我们有一个向量 A\n对它进行变换，比如位移，我们会这样\nmatrixTranslate⋅A    matrixTranslate \\cdot A\nmatrixTranslate⋅A\n然后我们再对它进行旋转\nmatrixRotate⋅matrixTranslate⋅A    matrixRotate \\cdot matrixTranslate \\cdot A\nmatrixRotate⋅matrixTranslate⋅A\n最后我们对它进行缩放\nmatrixScale⋅matrixRotate⋅matrixTranslate⋅A    matrixScale \\cdot matrixRotate \\cdot matrixTranslate \\cdot A\nmatrixScale⋅matrixRotate⋅matrixTranslate⋅A\n我们用代码模拟一下，使用我写的一个小工具\nimplementation(&quot;io.github.darkflamemasterdev:MatrixKotlin:1.1.1&quot;)\n// 3行1列 的 1维列向量val a = Matrix(  3, 1,  1f,  1f,  1f)// 3行3列 的 位移矩阵val matrixTranslate = Matrix(  3, 3,  1f, 0f, 7f,  0f, 1f, 8f,  0f, 0f, 1f)// 3行3列 的 旋转矩阵（绕 0 点）val matrixRotate = Matrix(  3, 3,  0.8660254f, -0.5f, 0f,  0.5f, 0.8660254f, 0f,  0f, 0f, 1f)// 3行3列 的 缩放矩阵val matrixScale = Matrix(  3, 3,  6f, 0f, 0f,  0f, 2f, 0f,  0f, 0f, 1f)println(matrixTranslate * a)println(matrixRotate * matrixTranslate * a)println(matrixScale * matrixRotate * matrixTranslate * a)\n&#123;[8.0],[9.0],[1.0]&#125;&#123;[2.428203],[11.7942295],[1.0]&#125;&#123;[14.569218],[23.588459],[1.0]&#125;\n我们来看结果，这里使用的是 desmos\n\n可以看到，矩阵左乘会让一个列向量按我们写的顺序进行变换\n右乘\n我们把这个情况在 Android 上复现（为了更明显，我们以 50px 是单位 1）\n当然，由于 Android 是右乘，我们需要倒着写，也就是先缩放，再旋转，最后位移\noverride fun onDraw(canvas: Canvas) &#123;  canvas.drawCircle(50f, 50f, 10f, paint)  canvas.save()  canvas.translate(400f, 450f)  canvas.drawCircle(50f, 50f, 10f, paint)  canvas.restore()  canvas.save()  canvas.rotate(30f)  canvas.translate(400f, 450f)  canvas.drawCircle(50f, 50f, 10f, paint)  canvas.restore()  canvas.scale(6f, 2f)  canvas.rotate(30f)  canvas.translate(400f, 450f)  canvas.drawCircle(50f, 50f, 10f, paint)&#125;\n\n我们把两个坐标系对比一下：\n\n而对于 Matrix ，右乘就是Matrix.post...， 而Matrix.pre...则是左乘，这个下面还会提到\n坐标系\n只进行 translate rotate clip skew scale 等系统预设的变换，我称之为 简单变换\n我们拿自定义 View 举例，在进行 canvas 绘制的时候，canvas 本身的坐标是和 View坐标独立的，也就是说 canvas 和 View 分别有自己的坐标\n\n举个例子，蓝色为 View 坐标系，绿色为 Canvas 坐标系\noverride fun onDraw(canvas: Canvas) &#123;  canvas.translate(200f,100f)  canvas.drawBitmap(bitmap, 0f, 0f, paint)&#125;\n如图所示，这是先将画布平移，然后绘制在画布的 (0, 0) 的位置\n也就是说，canvas.translate()函数并不是改变了绘制的位置，而是改变了画布 canvas 的位置\n3d 渲染（Matrix、Camera）\nMatrix 可以实现几乎任何变换，包括 2d 或者 3d 渲染，而 Camera 本质也是计算出 Matrix 来实现 3d 变换\nMatrix\nMatrix 是什么\n这里说的是android.graphics.Matrix而不是android.opengl.Matrix\n\n是的,每次我都想吐槽,只说这个类名而不说包名，然后遇到重名是真的抓狂\n\n我们先看这个 Matrix 到底是什么！\nlog(&quot;matrix = $matrix&quot;)\nmatrix = Matrix&#123;[1.0, 0.0, 0.0][0.0, 1.0, 0.0][0.0, 0.0, 1.0]&#125;\n这里我们调用 Matrix.toString() ，发现打印出来确实是一个矩阵，我们再看看他的 toString 是怎么写的\n@Overridepublic String toString() &#123;    StringBuilder sb = new StringBuilder(64);    sb.append(&quot;Matrix&#123;&quot;);    toShortString(sb);    sb.append(&#x27;&#125;&#x27;);    return sb.toString();&#125;private void toShortString(StringBuilder sb) &#123;    float[] values = new float[9];    getValues(values);    sb.append(&#x27;[&#x27;);    sb.append(values[0]);    sb.append(&quot;, &quot;);    sb.append(values[1]);    sb.append(&quot;, &quot;);    sb.append(values[2]);    sb.append(&quot;][&quot;);    sb.append(values[3]);    sb.append(&quot;, &quot;);    sb.append(values[4]);    sb.append(&quot;, &quot;);    sb.append(values[5]);    sb.append(&quot;][&quot;);    sb.append(values[6]);    sb.append(&quot;, &quot;);    sb.append(values[7]);    sb.append(&quot;, &quot;);    sb.append(values[8]);    sb.append(&#x27;]&#x27;);&#125;public void getValues(float[] values) &#123;    if (values.length &lt; 9) &#123;        throw new ArrayIndexOutOfBoundsException();    &#125;    nGetValues(native_instance, values);&#125;@FastNativeprivate static native void nGetValues(long nObject, float[] values);\n可以看到，这里其实就是调用了 nGetValues 这个 native 方法来填充 values，然后通过 StringBuilder 将他们连接起来\n而这个 values 其实就是关键性起作用的变量，但如果你看过 Java 层面的源码，你就知道，values 出现最多的就是 setValues 、 getValues 和 toString 里面，其他地方根本每调用过这个变量\n也就是说，这个变量的计算逻辑被完全封装到的 C++ 层了，在我们调用preRotate，postRotate，setSinCos… 这些方法的时候，他会在 C++ 层为我们计算好 Matrix ，然后在我们调用canvas.concat(matrix)或者canvas.setMatrix()的时候，将计算好的 Matrix 应用到 Canvas\n\n  \n    pre 对应矩阵左乘，而 post 对应矩阵右乘\n\n  \nAndroid 这么做的目的显而易见，是为了让我们不要过多关心矩阵运算，只通过他提供的一些方法，来完成绘制\n\n  \n    \n      值得一提的是\n\n    \n    \n      canvas.setMatrix()这个方法并不好用，经常有人抱怨这个方法会出现奇奇怪怪的问题，但我还没遇到过，所以你可以优先使用canvas.concat(matrix)\ncanvas.concat(matrix)是将 Matrix 和 Canvas 进行组合计算，而canvas.setMatrix()则是直接替换 Canvas 的矩阵\n\n    \n  \n那这个 concat 函数是如何进行矩阵操作的呢？我试验一下\noverride fun onDraw(canvas: Canvas) &#123;  canvasMatrix.setValues(floatArrayOf(2f, 4f, 3f, 8f, 5f, 9f, 2f, 5f, 7f))  cameraMatrix.setValues(floatArrayOf(-6f, 2f, 1f, 9f, 6f, -3f, 6f, 3f, 3f))  canvas.setMatrix(canvasMatrix)  canvas.concat(cameraMatrix)  log(&quot;canvas.matrix = $&#123;canvas.matrix&#125;&quot;)&#125;\nMatrix&#123;[42.0, 37.0, -1.0][51.0, 73.0, 20.0][75.0, 55.0, 8.0]&#125;\n我们猜测应该也是右乘的关系 也就是 canvasMatrix⋅cameraMatrixcanvasMatrix \\cdot cameraMatrixcanvasMatrix⋅cameraMatrix\n// 使用implementation(&quot;io.github.darkflamemasterdev:MatrixKotlin:1.1.1&quot;)val canvasMatrix = Matrix(3, 3).apply &#123;  setMatrixValue(    arrayOf(      floatArrayOf(2f, 4f, 3f),      floatArrayOf(8f, 5f, 9f),      floatArrayOf(2f, 5f, 7f)    )  )&#125;val cameraMatrix = Matrix(3, 3).apply &#123;  setMatrixValue(    arrayOf(      floatArrayOf(-6f, 2f, 1f),      floatArrayOf(9f, 6f, -3f),      floatArrayOf(6f, 3f, 3f)    )  )&#125;val x = canvasMatrix * cameraMatrixprintln(x)\n&#123;[42.0, 37.0, -1.0][51.0, 73.0, 20.0][75.0, 55.0, 8.0]&#125;\n果然和我们想的一模一样\nCamera\nCamera 模型\nCamera 类似于 3d 软件里的模型，如果你使用过类似 Blender 之类的软件一定非常好理解\n而 Camera 本质还是通过建立这样的 3d 模型计算出一个 Matrix\n\n\n  \n    这是 Camera 的坐标系，除了 X 轴，其他的都是和 View 坐标轴相反的\n\n  \n我们打开 Camera 这个类，发现很短，就只有短短 171 行\n\n方法也只有位移和旋转而已，所以相机这个模型就是为了解决投影的倾斜对应的矩阵计算的\n\n  \n    dotwithNormal 这个方法在 Google 的 Api 文档里也没有任何解释，调用它我也没有发现产生任何作用，所以我们暂时不去考虑它\n\n  \n其中有一个 getMatrix 的方法\n// android.graphics.Camerapublic void getMatrix(Matrix matrix) &#123;    nativeGetMatrix(matrix.ni());&#125;\n你可以传进去一个空的 Matrix 对象，然后 Camera 的信息会被复制进你传入的这个函数里\n所以你有理由怀疑，所有的自定义 View 变换都是通过矩阵变换计算来的，当然我也是这样想的…大概吧\n我们用 blender 模拟一下这样的摄像机模型，图片长 5 宽 5，摄像机距图片 14\n\n当摄像头默认在正上方，不旋转的时候，是这样的\n\n\n上图是摄像机旋转 45 度的样子\nLocation\n我们先查看一下这个摄像机的默认设置，主要就是这个摄像机的位置信息\noverride fun onDraw(canvas: Canvas) &#123;  log(&quot;camera.locationX = $&#123;camera.locationX&#125;&quot;)  log(&quot;camera.locationY = $&#123;camera.locationY&#125;&quot;)  log(&quot;camera.locationZ = $&#123;camera.locationZ&#125;&quot;)  camera.applyToCanvas(canvas)&#125;\ncamera.locationX = 0.0camera.locationY = 0.0camera.locationZ = -8.0\n可以看到默认 X 是 0.0 ，Y 是 0.0 , Z 是 -8.0\n值得注意的的是，只是调用 Camera 的 setLocation 并不会改变绘制主体的大小，而是会改变绘制主体的位置\n// Bitmap 长宽均为 400  private val padding = 200f  private val camera by lazy &#123;    Camera().apply &#123;      setLocation(4f, 20f, -72f)    &#125;  &#125;  private var matrix = Matrix()  override fun onDraw(canvas: Canvas) &#123;    camera.getMatrix(matrix)    log(&quot;matrix = $matrix&quot;)    camera.applyToCanvas(canvas)    canvas.drawBitmap(bitmap, padding, padding, paint)  &#125;\nmatrix = Matrix&#123;[1.0, 0.0, -288.0][0.0, 1.0, 1440.0][0.0, 0.0, 1.0]&#125;\n[10−28801144001]  \\begin{bmatrix}\n    1 &amp; 0 &amp; -288\\\\\n    0 &amp; 1 &amp; 144\\\\\n    0 &amp; 0 &amp; 1\n  \\end{bmatrix}\n⎣⎢⎡​100​010​−2881441​⎦⎥⎤​\n这里通过简单的线性代数知识就知道，这是一个位移矩阵，而主对角线全是 1 说明了这个矩阵并不存在任何缩放\n为什么会是这个数字呢？\n首先我们将相机向右上角移动，对应的投影出来的绘制主体自然会向左下角移动\n按比例计算，向左平移 4×72 = 288px ， 向下平移 20×72=1440px\n\n  \n    当我们在 Android 里调用 camera.setLocation() 的时候，里面填写的参数，单位是 inch（英寸） ，1 inch = 72 px，所以我们将这个 bitmap 设为宽高\n\n  \nRotate\nLocationZ 影响 Rotate\n从现在开始，一定要牢记，camera 的原理是矩阵变换\n// Bitmap 长宽均为 400private val paint = Paint(Paint.ANTI_ALIAS_FLAG)private val padding = 200fprivate val camera by lazy &#123;  Camera().apply &#123;    rotateX(30f)    setLocation(0f, 0f, -8)    //setLocation(0f, 0f, -16)  &#125;&#125;override fun onDraw(canvas: Canvas) &#123;  camera.applyToCanvas(canvas)  canvas.drawBitmap(bitmap, padding, padding, paint)&#125;\n我们让相机绕 X 轴旋转 30°，分别设置两个不同的 Z 轴值\n\n左图是 LocationZ 为 -16，右图 Location 为 -8\n可见，Location 虽然不会缩放，它会影响旋转的效果，这很容易理解，因为旋转的角度相同，距离越近，肯定效果越明显\n我们将矩阵打印出来\nLocationZ = -8, Matrix&#123;[1.0, 0.0, 0.0][0.0, 0.8660254, 0.0][0.0, -8.6805556E-4, 1.0]&#125;LocationZ = -16, Matrix&#123;[1.0, 0.0, 0.0][0.0, 0.8660254, 0.0][0.0, -4.3402778E-4, 1.0]&#125;LocationZ = -32, Matrix&#123;[1.0, 0.0, 0.0][0.0, 0.8660254, 0.0][0.0, -2.1701389E-4, 1.0]&#125;\n可以发现，LocationZ 会直接影响下面这个值，并且是成比例的\n对于这种效果我们是很难计算的，更多的我们是要进行更一些更有规律的变换效果，比如垂直翻转\n垂直翻转\n由于，Camera 的原理是矩阵运算，并且其他操作包括 Canvas.translate 等操作都是矩阵运算，所以我们先执行最简单的翻转\n// Bitmap 长宽均为 400private val camera by lazy &#123;  Camera().apply &#123;    rotateX(30f)    setLocation(0f, 0f, -8f)  &#125;&#125;override fun onDraw(canvas: Canvas) &#123;  camera.applyToCanvas(canvas)  canvas.drawBitmap(bitmap, -200f, -200f, paint)&#125;\n\n我们该如何将这个图放到中间呢？（也就是向右下角移动）\n垂直翻转 + 平移\n怎么才能让 Camera 计算出来的 Matrix 使得图形在任意位置垂直翻转呢？\n我们可以将位移和相机的矩阵运算结合起来\n\n先将矩阵的绘制中心和相机的 x, y 位置对准\n然后进行相机的矩阵变换\n最后将图像移回原位\n\n当然，我们得倒着写，因为 Android 里面使用的是列矩阵右乘\noverride fun onDraw(canvas: Canvas) &#123;  canvas.translate(200f, 200f) // Translate_1  camera.applyToCanvas(canvas)  canvas.translate(-200f, -200f) // Translate_2  canvas.drawBitmap(bitmap, 0f, 0f, paint)&#125;\n这个矩阵 $ Translate1\\cdot cameraMatrix\\cdot Translate2$\n网上还有人提出了以下的做法，其实也是这个道理，只不过，将第一步的canvas.translate()变成了matrix.preTranslate()而已\n这个矩阵也是这样的 $ Translate1\\cdot cameraMatrix\\cdot Translate2$\nprivate var matrix = Matrix()private val centerX = 400fprivate val centerY = 400foverride fun onDraw(canvas: Canvas) &#123;  camera.getMatrix(matrix)  matrix.preTranslate(-centerX, -centerY) // 先左乘 Translate_1  matrix.postTranslate(centerX, centerY)  // 再右乘 Translate_2  canvas.concat(matrix)  canvas.drawBitmap(bitmap, 200f, 200f, paint)&#125;\n有人说这个 centerX 和 centerY 是实际物体显示的中心位置\n这句话是不对的！！！！！！\n你依旧是按照第一个代码倒着写的原理就行\n这个代码我们将位移的变量进行了修改，最终效果就是这样的\n\n","tags":["Android","Canvas","Matrix","Camera"]},{"title":"Android自定义View03 - 属性动画","url":"/2023/12/16/Android%E8%87%AA%E5%AE%9A%E4%B9%89View03-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/","content":"概述\n这次的内容其实相比上篇要容易的多，只需要接触代码上的知识就好了\n本文介绍的是ViewPropertyAnimator和ObjectAnimator\n应用场景\nViewPropertyAnimator和ObjectAnimator原理都是使用了ValueAnimator\nViewPropertyAnimator是作为一个辅助类来调用ValueAnimator\n而ObjectAnimator则是继承了ValueAnimator，实现了更灵活的功能\n下图就对比了两个类声明的不同函数，ViewPropertyAnimator都是一些现成的变换（位移、旋转…），而ObjectAnimation则是侧重于你希望通过改变什么变量来控制动画（属于是面向对象的动画，非常符合ObjectAnimation的名字）\n\n\n  \n    \n      使用场景\n\n    \n    \n      Android 官方文档 里写到：If only one or two properties on a View object are being animated, then using an ObjectAnimator is fine; the property setters called by ObjectAnimator are well equipped to do the right thing to set the property and invalidate the view appropriately. But if several properties are animated simultaneously, or if you just want a more convenient syntax to animate a specific property, then ViewPropertyAnimator might be more well-suited to the task.\n也就是，在你使用 1~2 个属性变换的时候，ObjectAnimator是非常合适的，但属性多了会导致一些性能问题，这其实也很好理解，如果你了解过他的实现原理，就知道他其实是用反射，调用set/get方法并调用invalidate()重绘当前View，过多的重绘自然会影响性能\n而ViewPropertyAnimator将这些做了优化，但灵活性下降了不少\n但由于ObjectAnimation更加灵活，还是深受开发者喜爱\n\n    \n  \n关于ViewPropertyAnimator的优化，我这里简单说一丢丢，拿这个简单代码为例\nview.animate()  .translationX(200f)  .setInterpolator(LinearInterpolator())  .setDuration(2000)  .translationY(300f)\n1.view.animate()会构造一个ViewPropertyAnimator\n2.translationX(200f)会将这个位移 200 的动画，保存到ValueAnimator里面，post出去，而这个 post 就最终调用这个方法\n  private void animatePropertyBy(int constantName, float startValue, float byValue) &#123;    ...    mPendingAnimations.add(nameValuePair);    mView.removeCallbacks(mAnimationStarter);    mView.postOnAnimation(mAnimationStarter);&#125;\nmPendingAnimations.add(nameValuePair)就是添加动画行为，mPendingAnimations是一个 ArrayList\n而postOnAnimation这个方法就是下面这个方法\n  /** * &lt;p&gt;Causes the Runnable to execute on the next animation time step.* The runnable will be run on the user interface thread.&lt;/p&gt;** @param action The Runnable that will be executed.** @see #postOnAnimationDelayed* @see #removeCallbacks*/public void postOnAnimation(Runnable action) &#123;    final AttachInfo attachInfo = mAttachInfo;    if (attachInfo != null) &#123;        attachInfo.mViewRootImpl.mChoreographer.postCallback(                Choreographer.CALLBACK_ANIMATION, action, null);    &#125; else &#123;        // Postpone the runnable until we know        // on which thread it needs to run.        getRunQueue().post(action);    &#125;&#125;\ngetRunQueue()是一个HandlerActionQueue\n看到这里应该就非常清晰了，本质就是把这个animator交由Handler处理\n3.setInterpolator(LinearInterpolator())和setDuration(2000)这都是设置动画参数\n4. 最后还是，将动画保存下来 post 过去，但这里要注意一下removeCallbacks将上一个mAnimationStarter移除了，这达到了去重操作，这就是关键的优化操作\n\n  \n    \n      问题\n\n    \n    \n      那么有一个问题，我们先把动画 post 过去，再设置动画时长（setDuration），那这个动画是会在没给他设置动画时长的时候，启动吗？\n肯定是没有这个问题的，因为这都是在主线程里，方法整体的调用栈会先执行完，再有可能执行其他的任务，也就是说，这个post过去的任务肯定是会在我们设置这些动画参数之后的，肯定不会出问题的\n\n    \n  \n使用 ObjectAnimation\n简单用法\n\n"},{"title":"C++ IO stream（没写完）","url":"/2023/09/07/C-IO-stream/","content":"简介\n本文记录一下C++的IO stream的使用\n相对路径\n\nios_base\nios\nistream\nifstream\n\n首先要说明这个相对路径是相对于谁\n在linux环境下（我是MacOS）\n他相对的其实是，你当前的操作环境的路径\n也就是你终端（terminal）当前的路径\n举个例子\nMain.cpp输出当前的目录\n#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;unistd.h&gt;using namespace std;int main() &#123;    char buff[250];    getcwd(buff, 250);    string current_working_directory(buff);    cout &lt;&lt; &quot;Current working directory: &quot; &lt;&lt; current_working_directory &lt;&lt; endl;    while (true) &#123;&#125;    return 0;&#125;\n\n\n\n现在我们在~目录下执行file\n\n可以看到输出的路径就是~\n我们换个路径\n\n可以发现结果变了\n证实了我们的结论\n\nps : 其实./file前面的./就是当前目录的意思\n可以通过尝试cd ./来验证\n读取上一级目录是..，读取上一级目录的文件是../test.txt\n读取上上一级目录是../..，读取上上一级目录的文件是../../test.txt\n\nifstream\n#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    // 指定要读取的文件路径    std::string file_name = &quot;../test.txt&quot;;    // 创建一个fstream对象，以文本模式打开文件    std::ifstream file(file_name, std::ios::in);    // 检查文件是否成功打开    if (!file.is_open()) &#123;        std::cerr &lt;&lt; &quot;无法打开文件: &quot; &lt;&lt; file_name &lt;&lt; std::endl;        return 1;    &#125;    // 读取文件内容    std::string content;    std::string line;    while (std::getline(file, line)) &#123;        content += line;        content += &quot;\\n&quot;;    &#125;    // 关闭文件    file.close();    // 输出文件内容    std::cout &lt;&lt; &quot;文件内容:\\n&quot; &lt;&lt; content &lt;&lt; std::endl;        return 0;&#125;\n流程很容易读懂\n先打开文件\n再用getline一行一行读\n最后调用file.close()关闭文件\n\n如果你是在Clion或者vscode里面写的代码，一定要注意它运行的文件夹在哪\n通常情况是当前可执行文件的目录下面\n\nofstream\n","tags":["C++","cpp","IO","stream","流","读写"]},{"title":"C++ 傻鸟指针","url":"/2023/10/27/C-%E5%82%BB%E9%B8%9F%E6%8C%87%E9%92%88/","content":"指针是操作内存的工具\n1. 指针也存在内存中，指针也有内存地址\n指针也存在内存中，指针也有内存地址\n\n\n记住这个图，每次难以理解指针的时候，就看看这个图\n\n2. 指针的类型及其初始化\n首先，一个 int *n; ，表明了这个指针类型是 int *\n所以，通用的指针类型就是 dataType *\nint a = 10;int *p = &amp;a;\n这里p的类型是int*而不是int\n所以，指针的声明并没有什么难处，他和普通的变量其实没什么区别，只是类型改成对应的指针类型就行了\n而指针的赋值，一般就是对象的引用，\nPerson person = *new Person;Person* p = &amp;person;\n注意\n第一行代码， *new Person() 是这个分配内存后用一个临时指针所指的内存空间\n所以就类似于\nPerson* pPerson = new Person;Person person = *pPerson;\n\n这里的 * 称为指针运算符，用来取得某个地址上的数据\n\n而 person *p 是一个指针，&amp;person 是这个 person 的引用\n\n  \n    \n      tips\n\n    \n    \n      auto person = *new Person();这里还调用了拷贝构造函数，但这不是本文所述的重点\n\n    \n  \n3. 指针通过-&gt;可调用当前指向内存所属对象的内部成员\nclass Person &#123;public:    char *name;&#125;;// 调用Person *p = new Person();p-&gt;name;\n4. 指针指向一个内存地址\n可以将指针赋值给指针，也可以将一个地址赋值给指针\nint n = 10;int *ptr1 = &amp;n;int *ptr2 = ptr1;\n5. 指针输出（打印或调用）\n\n\n\n输出形式\n代码\n结果\n\n\n\n\n输出变量名\nptr\n存储的地址\n\n\n输出 *变量名\n*ptr\n地址上的数据\n\n\n输出 &amp;变量名\n&amp;ptr\n指针本身的地址\n\n\n\nint main() &#123;  int n = 10;  int *ptr = &amp;n;  std::cout &lt;&lt; &quot;ptr : &quot; &lt;&lt; ptr &lt;&lt; std::endl;  // ptr : 0x7ff7b5fe020c  std::cout &lt;&lt; &quot;*ptr : &quot; &lt;&lt; *ptr &lt;&lt; std::endl;  // *ptr : 10  std::cout &lt;&lt; &quot;&amp;ptr : &quot; &lt;&lt; &amp;ptr &lt;&lt; std::endl;  // &amp;ptr : 0x7ff7b5fe0200  std::cout &lt;&lt; &quot;n : &quot; &lt;&lt; &amp;n &lt;&lt; std::endl;  // n : 0x7ff7ba53120c&#125;\n6. 作为参数传递\n\n这里涉及一个 形参、实参 的概念\n简单来说，\n形参就是声明函数（方法）的时候，填写的参数\n实参就是调用函数（方法）的时候，填写的参数\n\n所以\n#include &lt;iostream&gt;class Person &#123;public:    const char *name = &quot;tom&quot;;&#125;;void print(Person *p) &#123;  std::cout &lt;&lt; std::endl;  std::cout &lt;&lt; &quot;print2(Person *p) &quot; &lt;&lt; p &lt;&lt; std::endl;  std::cout &lt;&lt; &quot;print2(Person &amp;p) &quot; &lt;&lt; &amp;p &lt;&lt; std::endl;  std::cout &lt;&lt; &quot;print2(Person p-&gt;name) &quot; &lt;&lt; p-&gt;name &lt;&lt; std::endl;&#125;int main() &#123;  auto person = *new Person();  auto *p_ptr = &amp;person;  std::cout &lt;&lt; &quot;p_ptr : &quot; &lt;&lt; p_ptr &lt;&lt; std::endl;  std::cout &lt;&lt; &quot;&amp;p_ptr : &quot; &lt;&lt; &amp;p_ptr &lt;&lt; std::endl;  std::cout &lt;&lt; &quot;p_ptr-&gt;name : &quot; &lt;&lt; p_ptr-&gt;name &lt;&lt; std::endl;  print(p_ptr);&#125;\n我们来看输出结果\np_ptr : 0x7ff7bbb55208 // person 地址&amp;p_ptr : 0x7ff7bbb55200p_ptr-&gt;name : tomprint2(Person *p) 0x7ff7bbb55208print2(Person &amp;p) 0x7ff7bbb551d8print2(Person p-&gt;name) tom\n我们知道第 20 行输出的肯定是指针 ptr存储的地址，也就也是这个person的地址\n并且，第 21 行输出的是指针 ptr本身的地址\n第 8 行定义的函数，括号里是形参\n在调用函数的时候，会生成一个新的指针p，指向person，也就是把传进去的p_ptr赋值给p\n所以第 10 行输出的就是p存储的地址\n所以第 11 行输出的就是p自身的地址\n所以第 11 行就是用p访问person，输出自然是person的name\n所以，指针对象作为参数传入，会生成一个新的指针，和这个传入的指针指向同一块内存，所以你用这个指针执行的操作，在函数外面也会接收到。\n所以就可以这么写\n#include &lt;iostream&gt;void copyStringToDynamicMemory(char*&amp; destination) &#123;  const char* source = &quot;This is a dynamically allocated string.&quot;;    destination = new char[strlen(source) + 1];    std::strcpy(destination, source);&#125;int main() &#123;  char* code = nullptr;  copyStringToDynamicMemory(code);  if (code != nullptr) &#123;    std::cout &lt;&lt; &quot;code : &quot; &lt;&lt; code &lt;&lt; std::endl;    delete[] code;  &#125; else &#123;    std::cerr &lt;&lt; &quot;Memory allocation failed.&quot; &lt;&lt; std::endl;  &#125;&#125;\n我们传入了code为空，等到执行完函数，code所指的内存已经写入了数据\n这里的参数这样写 char* &amp;destination\n7. 作为返回值\n这里涉及两个概念：堆和栈\n堆内存一般指的是动态分配的内存，栈内存一般指的是方法调用栈\n在C++中，你可以使用以下几种方法来申请堆内存：\n\n使用new运算符： 使用new运算符可以动态分配内存并返回一个指向该内存的指针。例如，如果要动态分配一个整数数组：\n\n  int* dynamicArray = new int[10];\n在分配内存后，不要忘记在不再需要时，使用delete运算符释放内存：\n  delete[] dynamicArray;\n\n使用malloc函数： 你还可以使用标准C库函数malloc来分配堆内存。malloc返回一个指向分配的内存块的指针。与new不同，malloc不会自动调用类的构造函数。你需要手动管理内存。\n\n  int* dynamicArray = (int*)malloc(10 * sizeof(int));\n同样，你应该使用free函数来释放内存：\n  free(dynamicArray);\n\n使用std::allocator： C++还提供了std::allocator类，它可以用于分配内存并构造对象。虽然通常不需要手动使用它，但它提供了更多的内存管理灵活性。\n\n  std::allocator&lt;int&gt; alloc;int* dynamicArray = alloc.allocate(10);\n当你不再需要内存时，你可以使用alloc.deallocate函数来释放它。\n  alloc.deallocate(dynamicArray, 10);\n\n使用智能指针： 在现代C++中，推荐使用智能指针来管理堆内存。std::shared_ptr和std::unique_ptr是强大的工具，它们会在对象不再需要时自动释放内存。\n\n  std::shared_ptr&lt;int&gt; dynamicArray = std::make_shared&lt;int[]&gt;(10);\n当指针超出范围或不再需要时，它们会自动处理内存的释放。\n使用new或malloc时，请确保在不再需要内存时手动释放它，以避免内存泄漏。同时，了解每种方法的区别和适用场景，以便根据需求选择合适的方法。\n当指针作为返回值的时候，只有两种情况\n\n指向堆内存\n指向全局变量\n\n举一个的例子🌰\nint* createAndReturnDynamicArray(int size) &#123;    int* arr = new int[size];    return arr;&#125;\n","tags":["C++","cpp","指针"]},{"title":"Android自定义View01 - 事件分发原理","url":"/2023/12/06/Android%E8%87%AA%E5%AE%9A%E4%B9%89View01-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%8E%9F%E7%90%86/","content":"\n  \n    我们从写一个自定义 View 开始，了解 View 分发机制\n\n  \n事件分发\n\n  \n    \n      返回true消费事件\n\n    \n    \n      我们都知道 OnTouchEvent 和 OnTouchListener.onTouch() 都会返回 boolean 值\n返回 true 表示消费此次事件\n并且消费的是这个事件指的是一个事件序列，这一事件序列都是以 MotionEvent.ACTION_DOWN 开始，以 MotionEvent.ACTION_UP 或者 MotionEvent.ACTION_CANCEL 结束\n所以消费这个事件的意思，是会将这个一整个事件序列消费掉，下面的 View 就不在接收到事件了\n所以，只有在接收到 DOWN 事件返回 true 才会生效\noverride fun onTouchEvent(event: MotionEvent): Boolean &#123;  // (1)  return true&#125;override fun onTouchEvent(event: MotionEvent): Boolean &#123;  // (2)  return if (event.actionMasked == MotionEvent.ACTION_DOWN) &#123;    true  &#125; else &#123;    false  &#125;&#125;override fun onTouchEvent(event: MotionEvent): Boolean &#123;  // (3)  return event.actionMasked == MotionEvent.ACTION_DOWN&#125;\n这三个的效果是完全一样的\n\n    \n  \nOnTouchEvent\n\n图中，view1 是 view2 的 子View，所以在点击的 view1 的时候，onTouchEvent 应该先传给 view1，再传给 view2，这样是符合直觉的\n那么它是怎么处理这些事件的呢？我们看看源码\n// View.onTouchEvent(MotionEvent event)public boolean onTouchEvent(MotionEvent event) &#123;    final float x = event.getX();    final float y = event.getY();    final int viewFlags = mViewFlags;    final int action = event.getAction();    final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE            || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)            || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;    if ((viewFlags &amp; ENABLED_MASK) == DISABLED            &amp;&amp; (mPrivateFlags4 &amp; PFLAG4_ALLOW_CLICK_WHEN_DISABLED) == 0) &#123;        if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;            setPressed(false);        &#125;        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;        // A disabled view that is clickable still consumes the touch        // events, it just doesn&#x27;t respond to them.        return clickable;    &#125;    if (mTouchDelegate != null) &#123;        if (mTouchDelegate.onTouchEvent(event)) &#123;            return true;        &#125;    &#125;    if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;        switch (action) &#123;            case MotionEvent.ACTION_UP:                mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;                if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;                    handleTooltipUp();                &#125;                if (!clickable) &#123;                    removeTapCallback();                    removeLongPressCallback();                    mInContextButtonPress = false;                    mHasPerformedLongPress = false;                    mIgnoreNextUpEvent = false;                    break;                &#125;                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;                if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123;                    // take focus if we don&#x27;t have it already and we should in                    // touch mode.                    boolean focusTaken = false;                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;                        focusTaken = requestFocus();                    &#125;                    if (prepressed) &#123;                        // The button is being released before we actually                        // showed it as pressed.  Make it show the pressed                        // state now (before scheduling the click) to ensure                        // the user sees it.                        setPressed(true, x, y);                    &#125;                    if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;                        // This is a tap, so remove the longpress check                        removeLongPressCallback();                        // Only perform take click actions if we were in the pressed state                        if (!focusTaken) &#123;                            // Use a Runnable and post this rather than calling                            // performClick directly. This lets other visual state                            // of the view update before click actions start.                            if (mPerformClick == null) &#123;                                mPerformClick = new PerformClick();                            &#125;                            if (!post(mPerformClick)) &#123;                                performClickInternal();                            &#125;                        &#125;                    &#125;                    if (mUnsetPressedState == null) &#123;                        mUnsetPressedState = new UnsetPressedState();                    &#125;                    if (prepressed) &#123;                        postDelayed(mUnsetPressedState,                                ViewConfiguration.getPressedStateDuration());                    &#125; else if (!post(mUnsetPressedState)) &#123;                        // If the post failed, unpress right now                        mUnsetPressedState.run();                    &#125;                    removeTapCallback();                &#125;                mIgnoreNextUpEvent = false;                break;            case MotionEvent.ACTION_DOWN:                if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123;                    mPrivateFlags3 |= PFLAG3_FINGER_DOWN;                &#125;                mHasPerformedLongPress = false;                if (!clickable) &#123;                    checkForLongClick(                            ViewConfiguration.getLongPressTimeout(),                            x,                            y,                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);                    break;                &#125;                if (performButtonActionOnTouchDown(event)) &#123;                    break;                &#125;                // Walk up the hierarchy to determine if we&#x27;re inside a scrolling container.                boolean isInScrollingContainer = isInScrollingContainer();                // For views inside a scrolling container, delay the pressed feedback for                // a short period in case this is a scroll.                if (isInScrollingContainer) &#123;                    mPrivateFlags |= PFLAG_PREPRESSED;                    if (mPendingCheckForTap == null) &#123;                        mPendingCheckForTap = new CheckForTap();                    &#125;                    mPendingCheckForTap.x = event.getX();                    mPendingCheckForTap.y = event.getY();                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());                &#125; else &#123;                    // Not inside a scrolling container, so show the feedback right away                    setPressed(true, x, y);                    checkForLongClick(                            ViewConfiguration.getLongPressTimeout(),                            x,                            y,                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);                &#125;                break;            case MotionEvent.ACTION_CANCEL:                if (clickable) &#123;                    setPressed(false);                &#125;                removeTapCallback();                removeLongPressCallback();                mInContextButtonPress = false;                mHasPerformedLongPress = false;                mIgnoreNextUpEvent = false;                mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;                break;            case MotionEvent.ACTION_MOVE:                if (clickable) &#123;                    drawableHotspotChanged(x, y);                &#125;                final int motionClassification = event.getClassification();                final boolean ambiguousGesture =                        motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE;                int touchSlop = mTouchSlop;                if (ambiguousGesture &amp;&amp; hasPendingLongPressCallback()) &#123;                    if (!pointInView(x, y, touchSlop)) &#123;                        // The default action here is to cancel long press. But instead, we                        // just extend the timeout here, in case the classification                        // stays ambiguous.                        removeLongPressCallback();                        long delay = (long) (ViewConfiguration.getLongPressTimeout()                                * mAmbiguousGestureMultiplier);                        // Subtract the time already spent                        delay -= event.getEventTime() - event.getDownTime();                        checkForLongClick(                                delay,                                x,                                y,                                TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS);                    &#125;                    touchSlop *= mAmbiguousGestureMultiplier;                &#125;                // Be lenient about moving outside of buttons                if (!pointInView(x, y, touchSlop)) &#123;                    // Outside button                    // Remove any future long press/tap checks                    removeTapCallback();                    removeLongPressCallback();                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;                        setPressed(false);                    &#125;                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;                &#125;                final boolean deepPress =                        motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS;                if (deepPress &amp;&amp; hasPendingLongPressCallback()) &#123;                    // process the long click action immediately                    removeLongPressCallback();                    checkForLongClick(                            0 /* send immediately */,                            x,                            y,                            TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS);                &#125;                break;        &#125;        return true;    &#125;    return false;&#125;\n\n\n3~6 行是获取基本信息，点击事件的坐标，viewFlags 以及 action\n\n\n7~9 行是检查是否可点击，供下面判断使用，值得一提的是这个 CONTEXT_CLICKABLE 对于是老实手机存在的一个类似右键点击的操作\n\n\n10~19 行是在处理 本可以点击，但设置为禁用状态的处理，设置为禁用，并不会防止消耗此次事件（如果禁用就不会消耗事件，那么就跟变透明了一样，点击这里，事件却被传到了这个 view 的后面，这明显是错误的，view 事件应该是直接在这个被禁用的 view 处被阻拦这样更符合直觉）\n\n\n20~24 行是触摸代理，这个是用来帮忙接收触摸事件的，比如扩大按钮的点击范围，但其实有很多其他扩大点击范围的方法，所以这个其实并不是很常用，单页挺简单的\n\n\n25 行，从这里开始就是主要部分了\n\n首先进入这个大 if 作用域，要判断 clickable 以及 TOOLTIP\nTOOLTIP 就是长按按钮浮出的一段文字，目的是解释当前 view 是干什么的\n\n &lt;Viewandroid:id=&quot;@+id/touch_view&quot;android:layout_width=&quot;300dp&quot;android:layout_height=&quot;300dp&quot;android:background=&quot;#335EC8&quot;android:tooltipText=&quot;这是一个 View&quot; /&gt;\n  \n红圈是点击位置\n\n\n接下来就是对于不同 action 进行相应\n根据事件序列的顺序，我们先看 ACTION_DOWN ，第 85 行\n\n\n从第 85 行开始，他首先判断了 event.getSource() 是否是 InputDevice.SOURCE_TOUCHSCREEN\n这是为了为手指触摸屏幕做一些优化，因为你的手指按下的是一个面，不是一个点，所以他要有优化一下比如前面提到的 tooltip 的悬浮显示，会跟点击位置有一点距离\n\n\n90 行在不可点击的时候，调用了 checkForLongClick（检查是否要长按，也就是等一会看看是否还是按下状态） 也是因为上面提示的 Tooltip\n\n\n98 行是检测鼠标右键点击的\n没错，Android 是直接外接鼠标键盘的，90 行判断的 event.getSource() 也有可能是 InputDevice.SOURCE_MOUSE\n\n\n102 行是判断是否在一个滑动控件里，这个其实挺有意思\n我们点进去看看\n\n\n  @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)public boolean isInScrollingContainer() &#123;    ViewParent p = getParent();    while (p != null &amp;&amp; p instanceof ViewGroup) &#123;        if (((ViewGroup) p).shouldDelayChildPressedState()) &#123;            return true;        &#125;        p = p.getParent();    &#125;    return false;&#125;\n这段代码是一个循环，一层层看是否需要延迟设置 pressedState ，第 5 行有一个 shouldDelayChildPressedState\n这个延迟，就是用来判断你是要滑动这个控件还是要点击这个控件\n我们继续回来看，第 105 行，如果是在滑动控件里，就会设为 PFLAG_PREPRESSED （pre press，预按下状态），并调用 postDelay ，CheckForTap 本身是一个 Runnable，他就是一个延迟的设置按下状态的事件\n如果不在滑动控件里，就直接设置按下状态\n   \n  \n    \n      注意\n\n    \n    \n      如果你的自定义 View 不是可滑动的，应该重写 shouldDelayChildPressedState() 这个方法并返回 false，这是因为 ViewGroup.shouldDelayChildPressedState() 默认返回 true，也就是所有的 ViewGroup 都默认可滑动，不重写就会某人有一个等待时间\n\n    \n  \n\n\n现在看 ACTION_MOVE ，第 134 行\n\n135~137 行 drawableHotspotChanged(x, y) 是绘制水波纹的效果的\n接下来 141~170 行 都是在不同情况下，发现 pointInView(x, y, touchSlop) 返回 false ，也就是手指点击区域不在当前 view 的范围了（TouchSlop 是一个 view 边界的宽容，不至于手指稍微出去一点点，就判断出范围），就移除相应的东西，将状态设为 false\n171~181 行，就是关于压力触控的设置\n\n\n\n现在看 ACTION_UP ，第 27 行\n\n29~31 行，是判断你按压的时间是否支持显示 Tooltip\n32~39 行，是在不可点击的时候，进行各种移除\n40 行，这里就是前面所说的 pre press ，预按下状态\n44~47 行，这里是看看能不能获取焦点，isFocusableInTouchMode 这是物理按键，或者 Android 电视所需要使用的\n48~54 行，如果是预按下状态，设置为按下状态\n55~70 行，这里就是点击事件\n74~80 行，这里是预按下状态，设置一个延迟，防止过快显示\n\n\n\n再看 123 行的 ACTION_CANCEL，就是单纯地在意外退出的时候，各种移除，干擦屁股的工作\n\n\n\n\nonInterceptTouchEvent\n// ViewGroup.onInterceptTouchEvent(MotionEvent ev)public boolean onInterceptTouchEvent(MotionEvent ev) &#123;    if (ev.isFromSource(InputDevice.SOURCE_MOUSE)            &amp;&amp; ev.getAction() == MotionEvent.ACTION_DOWN            &amp;&amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)            &amp;&amp; isOnScrollbarThumb(ev.getX(), ev.getY())) &#123;        return true;    &#125;    return false;&#125;\n这个函数的作用是父 view 拦截事件，让子 view 收不到后续事件，他可以在接收到任意事件后，拦截他，随后的一整个事件序列就不会再传给子 view 了，而是传给 自己的 OnTouchEvent\n并且，如果是中途拦截，需要给子 view 发送 CANCEL 事件，因为这是意外退出事件序列\n\n  \n    \n      使用方法\n\n    \n    \n      这个方法使用很简单，就是直接重写，然后在你需要的时候，返回不同的值就行\n比如你想在用户滑动超过 5 个像素的时候，返回 true，否则就返回 false\n当然你还需要记录这些事件，以便拦截之后，供你的 OnTouchEvent 使用\n复杂的代码逻辑往往是在 OnTouchEvent 里面\n\n    \n  \ndispatchTouchEvent\ndispatchTouchEvent 是一个事件分发的开始，他会先判断是否需要拦截此事件，看看是否要传给子 view，如果不拦截，就传给子 view 的 dispatchTouchEvent，最后再从 OnTouchEvent 传回来；如果不拦截，就直接传给自己的 OnTouchEvent，如图所示\n\nView\n这个是 View 的 dispatchTouchEvent，ViewGroup 的 dispatchTouchEventde 的实现还有所不同\n// View.dispatchTouchEvent(MotionEvent event)public boolean dispatchTouchEvent(MotionEvent event) &#123;    // If the event should be handled by accessibility focus first.    if (event.isTargetAccessibilityFocus()) &#123;        // We don&#x27;t have focus or no virtual descendant has it, do not handle the event.        if (!isAccessibilityFocusedViewOrHost()) &#123;            return false;        &#125;        // We have focus and got the event, then use normal event dispatch.        event.setTargetAccessibilityFocus(false);    &#125;    boolean result = false;    if (mInputEventConsistencyVerifier != null) &#123;        mInputEventConsistencyVerifier.onTouchEvent(event, 0);    &#125;    final int actionMasked = event.getActionMasked();    if (actionMasked == MotionEvent.ACTION_DOWN) &#123;        // Defensive cleanup for new gesture        stopNestedScroll();    &#125;    if (onFilterTouchEventForSecurity(event)) &#123;        if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;            result = true;        &#125;        //noinspection SimplifiableIfStatement        ListenerInfo li = mListenerInfo;        if (li != null &amp;&amp; li.mOnTouchListener != null                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;            result = true;        &#125;        if (!result &amp;&amp; onTouchEvent(event)) &#123;            result = true;        &#125;    &#125;    if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123;        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);    &#125;    // Clean up after nested scrolls if this is the end of a gesture;    // also cancel it if we tried an ACTION_DOWN but we didn&#x27;t want the rest    // of the gesture.    if (actionMasked == MotionEvent.ACTION_UP ||            actionMasked == MotionEvent.ACTION_CANCEL ||            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;        stopNestedScroll();    &#125;    return result;&#125;\n关键就在于 24~39 行，这里会依次响应你为他设置的 OnTouchListener 以及这个 view 自身的 OnTouchEvent\nViewGroup\n@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123;    if (mInputEventConsistencyVerifier != null) &#123;        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);    &#125;    // If the event targets the accessibility focused view and this is it, start    // normal event dispatch. Maybe a descendant is what will handle the click.    if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;        ev.setTargetAccessibilityFocus(false);    &#125;    boolean handled = false;    if (onFilterTouchEventForSecurity(ev)) &#123;        final int action = ev.getAction();        final int actionMasked = action &amp; MotionEvent.ACTION_MASK;        // Handle an initial down.        if (actionMasked == MotionEvent.ACTION_DOWN) &#123;            // Throw away all previous state when starting a new touch gesture.            // The framework may have dropped the up or cancel event for the previous gesture            // due to an app switch, ANR, or some other state change.            cancelAndClearTouchTargets(ev);            resetTouchState();        &#125;        // Check for interception.        final boolean intercepted;        if (actionMasked == MotionEvent.ACTION_DOWN                || mFirstTouchTarget != null) &#123;            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;            if (!disallowIntercept) &#123;                intercepted = onInterceptTouchEvent(ev);                ev.setAction(action); // restore action in case it was changed            &#125; else &#123;                intercepted = false;            &#125;        &#125; else &#123;            // There are no touch targets and this action is not an initial down            // so this view group continues to intercept touches.            intercepted = true;        &#125;        // If intercepted, start normal event dispatch. Also if there is already        // a view that is handling the gesture, do normal event dispatch.        if (intercepted || mFirstTouchTarget != null) &#123;            ev.setTargetAccessibilityFocus(false);        &#125;        // Check for cancelation.        final boolean canceled = resetCancelNextUpFlag(this)                || actionMasked == MotionEvent.ACTION_CANCEL;        // Update list of touch targets for pointer down, if needed.        final boolean isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE;        final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0                &amp;&amp; !isMouseEvent;        TouchTarget newTouchTarget = null;        boolean alreadyDispatchedToNewTouchTarget = false;        if (!canceled &amp;&amp; !intercepted) &#123;            // If the event is targeting accessibility focus we give it to the            // view that has accessibility focus and if it does not handle it            // we clear the flag and dispatch the event to all children as usual.            // We are looking up the accessibility focused host to avoid keeping            // state since these events are very rare.            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()                    ? findChildWithAccessibilityFocus() : null;            if (actionMasked == MotionEvent.ACTION_DOWN                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;                final int actionIndex = ev.getActionIndex(); // always 0 for down                final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)                        : TouchTarget.ALL_POINTER_IDS;                // Clean up earlier touch targets for this pointer id in case they                // have become out of sync.                removePointersFromTouchTargets(idBitsToAssign);                final int childrenCount = mChildrenCount;                if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;                    final float x =                            isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex);                    final float y =                            isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex);                    // Find a child that can receive the event.                    // Scan children from front to back.                    final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();                    final boolean customOrder = preorderedList == null                            &amp;&amp; isChildrenDrawingOrderEnabled();                    final View[] children = mChildren;                    for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;                        final int childIndex = getAndVerifyPreorderedIndex(                                childrenCount, i, customOrder);                        final View child = getAndVerifyPreorderedView(                                preorderedList, children, childIndex);                        // If there is a view that has accessibility focus we want it                        // to get the event first and if not handled we will perform a                        // normal dispatch. We may do a double iteration but this is                        // safer given the timeframe.                        if (childWithAccessibilityFocus != null) &#123;                            if (childWithAccessibilityFocus != child) &#123;                                continue;                            &#125;                            childWithAccessibilityFocus = null;                            i = childrenCount;                        &#125;                        if (!child.canReceivePointerEvents()                                || !isTransformedTouchPointInView(x, y, child, null)) &#123;                            ev.setTargetAccessibilityFocus(false);                            continue;                        &#125;                        newTouchTarget = getTouchTarget(child);                        if (newTouchTarget != null) &#123;                            // Child is already receiving touch within its bounds.                            // Give it the new pointer in addition to the ones it is handling.                            newTouchTarget.pointerIdBits |= idBitsToAssign;                            break;                        &#125;                        resetCancelNextUpFlag(child);                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;                            // Child wants to receive touch within its bounds.                            mLastTouchDownTime = ev.getDownTime();                            if (preorderedList != null) &#123;                                // childIndex points into presorted list, find original index                                for (int j = 0; j &lt; childrenCount; j++) &#123;                                    if (children[childIndex] == mChildren[j]) &#123;                                        mLastTouchDownIndex = j;                                        break;                                    &#125;                                &#125;                            &#125; else &#123;                                mLastTouchDownIndex = childIndex;                            &#125;                            mLastTouchDownX = ev.getX();                            mLastTouchDownY = ev.getY();                            newTouchTarget = addTouchTarget(child, idBitsToAssign);                            alreadyDispatchedToNewTouchTarget = true;                            break;                        &#125;                        // The accessibility focus didn&#x27;t handle the event, so clear                        // the flag and do a normal dispatch to all children.                        ev.setTargetAccessibilityFocus(false);                    &#125;                    if (preorderedList != null) preorderedList.clear();                &#125;                if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;                    // Did not find a child to receive the event.                    // Assign the pointer to the least recently added target.                    newTouchTarget = mFirstTouchTarget;                    while (newTouchTarget.next != null) &#123;                        newTouchTarget = newTouchTarget.next;                    &#125;                    newTouchTarget.pointerIdBits |= idBitsToAssign;                &#125;            &#125;        &#125;        // Dispatch to touch targets.        if (mFirstTouchTarget == null) &#123;            // No touch targets so treat this as an ordinary view.            handled = dispatchTransformedTouchEvent(ev, canceled, null,                    TouchTarget.ALL_POINTER_IDS);        &#125; else &#123;            // Dispatch to touch targets, excluding the new touch target if we already            // dispatched to it.  Cancel touch targets if necessary.            TouchTarget predecessor = null;            TouchTarget target = mFirstTouchTarget;            while (target != null) &#123;                final TouchTarget next = target.next;                if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;                    handled = true;                &#125; else &#123;                    final boolean cancelChild = resetCancelNextUpFlag(target.child)                            || intercepted;                    if (dispatchTransformedTouchEvent(ev, cancelChild,                            target.child, target.pointerIdBits)) &#123;                        handled = true;                    &#125;                    if (cancelChild) &#123;                        if (predecessor == null) &#123;                            mFirstTouchTarget = next;                        &#125; else &#123;                            predecessor.next = next;                        &#125;                        target.recycle();                        target = next;                        continue;                    &#125;                &#125;                predecessor = target;                target = next;            &#125;        &#125;        // Update list of touch targets for pointer up or cancel, if needed.        if (canceled                || actionMasked == MotionEvent.ACTION_UP                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;            resetTouchState();        &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;            final int actionIndex = ev.getActionIndex();            final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);            removePointersFromTouchTargets(idBitsToRemove);        &#125;    &#125;    if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123;        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);    &#125;    return handled;&#125;\n这就是 ViewGroup 的 dispatchTouchEvent，确实是复杂了很多，主要是因为多点触控\n多点触控涉及一个新的类就是 TouchTarget\nprivate static final class TouchTarget &#123;    private static final int MAX_RECYCLED = 32;    private static final Object sRecycleLock = new Object[0];    private static TouchTarget sRecycleBin;    private static int sRecycledCount;    public static final int ALL_POINTER_IDS = -1; // all ones    // The touched child view.    @UnsupportedAppUsage    public View child;    // The combined bit mask of pointer ids for all pointers captured by the target.    public int pointerIdBits;    // The next target in the target list.    public TouchTarget next;    @UnsupportedAppUsage    private TouchTarget() &#123;    &#125;    public static TouchTarget obtain(@NonNull View child, int pointerIdBits) &#123;        if (child == null) &#123;            throw new IllegalArgumentException(&quot;child must be non-null&quot;);        &#125;        final TouchTarget target;        synchronized (sRecycleLock) &#123;            if (sRecycleBin == null) &#123;                target = new TouchTarget();            &#125; else &#123;                target = sRecycleBin;                sRecycleBin = target.next;                 sRecycledCount--;                target.next = null;            &#125;        &#125;        target.child = child;        target.pointerIdBits = pointerIdBits;        return target;    &#125;    public void recycle() &#123;        if (child == null) &#123;            throw new IllegalStateException(&quot;already recycled once&quot;);        &#125;        synchronized (sRecycleLock) &#123;            if (sRecycledCount &lt; MAX_RECYCLED) &#123;                next = sRecycleBin;                sRecycleBin = this;                sRecycledCount += 1;            &#125; else &#123;                next = null;            &#125;            child = null;        &#125;    &#125;&#125;\n我们看这个类的结构，里面有一个 next，类型也是 Target，没错和你想的一样，这是一个单链表数据结构\nobtain 函数就是一个获取 Target 的函数，他只会在有子 View 的时候被调用，也就是 child 不为 null 的时候\nrecycle 是一个回收函数，比较简单\n我们回到 dispatchTouchEvent()，这段代码新概念偏多并且逻辑复杂，所以我们直接看简化的总结\n\n19~25 行，如果用户初次按下（ACTION_DOWN），清空 TouchTargets 和 DISALLOW_INTERCEPT 标记\n27~48 行，这里就是处理 onInterceptTouchEvent 和 requestDisallowInterceptTouchEvent，如果拦截成功，就进行正常的事件分发（看 44 行的注释：If intercepted, start normal event dispatch.），就是调用自己的 onTouchEvent\n60~163 行，如果不拦截并不是 CANCEL 事件，并且是 DOWN 或者 POINTER_DOWN，尝试把 pointer（手指）通过 TouchTarget 分配给子 View；如果分配给了子 View，调用 child.dispatchTouchEvent() 事件传给子 View\nPOINTER_DOWN 转给 第一次接收事件的子 View 时，会转成 DOWN 事件\n166 行，看有没有 TouchTarget\n\n如果没有，调用 dispatchTransformedTouchEvent，其中在 child 为空的时候，会将事件传给自己\n如果有，调用 child.dispatchTouchEvent() 把事件传给对应的子 View（如果有的话）\n\n\n202~211 行如果是 POINTER_UP，从 TouchTargets 中清除 POINTER 信息；如果是 UP 或者 CANCEL，重置状态\n\n","tags":["Android","点击","机制","事件分发","事件分发机制","多点触控"]},{"title":"多继承 or interface","url":"/2023/05/14/Java-%E5%A4%9A%E7%BB%A7%E6%89%BF-or-interface/","content":"为什么 Java 要设计成单继承，但是允许实现多个 Interface ，为什么不干脆直接设计成多继承？\n以 C++ 为例\n我们都知道 C++ 是多继承的，这就会导致一些很复杂的情况出现，比如菱形继承\n\n此时，我们假设 A 有一个变量 gender(性别)，\nB 继承 A ，所以 B 也有 gender ，\nC 继承 A ，所以 C 也有 gender ，\n那么 D 肯定也有 gender ，\n但是由于同时继承了 B 和 C ，所以 D 就有了两个 gender ，这太奇怪了，两个性别？？？\n这样我们该如何操作 gender ？？？\nclass A &#123;protected:    int gender;&#125;;class B : public A &#123;protected:    int b_gender() &#123;        return gender;    &#125;;&#125;;class C : public A &#123;protected:    int c_gender() &#123;        return gender;    &#125;;&#125;;class D : public B, public C &#123;public:    int d_gender() &#123;        return gender; //这里会编译错误    &#125;&#125;;\n\n可以看到根本没法操作，编译就报错了，所以，我们只能改成这样…\n\n但是这写法也太难理解了，更何况我们确实知道还存在一个 C::gender 存在，但是却用不到它，这意味着这部分空间浪费了！！！\n所以 C++ 推出了虚继承\n\n\n但说实话，这个虚继承很难用！！！\n\n以菱形继承为例，假设 A 定义了一个名为 gender 的成员变量，当我们在 D 中直接访问 gender 时，会有三种可能性：\n\n如果 B 和 C 中都没有 gender 的定义，那么 gender 将被解析为 A 的成员，此时不存在二义性。\n如果 B 或 C 其中的一个类定义了 gender ，也不会有二义性，派生类 D 的 gender ，比 虚基类 A 的 gender 优先级更高。\n如果 B 和 C 中都定义了 gender ，那么直接访问 gender 将产生二义性问题。\n\n如果多继承变得更复杂，织成了一张网，那就很痛苦了，这样代码会耦合严重，一旦设计不合理很容易出现离谱的问题\n不仅是成员变量，成员函数也是一样的道理\n这也就是为什么包括 Java 在内，很多语言设计为单继承的原因\n\n  \n    \n      Java 的 Interface 之间也是单继承\n\n    \n    \n      \nJava 的接口多实现，仅在一种情况下有二义性，那就是变量名冲突的情况\n\n但是这种情况下，并不复杂，因为即使是多实现，也只需要处理现在这个类就可以了，因为实现接口的是类，再往下就是单继承了\n\n\nJava 的接口多实现，不会使成员函数有二义性\n\n因为只要实现了接口，就会有对成员函数的重新实现，所以只要以当前的实现为准就好了\n\n\n\n\n    \n  \n","tags":["C++","cpp","Java"]},{"title":"Kotlin 手动环境配置","url":"/2023/11/06/Kotlin-%E6%89%8B%E5%8A%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","content":"背景介绍\nKotlin 编译器 k2 出来了，就想着平时写 Kotlin 都是直接用的 IDEA 和 Android Studio ，并不是自己配置开发环境\n这肯定是一个趋势，就是所有的开发环境配置项都i是点两下就配置好了，不用再去设置什么环境变量，非常地方便\n但我还是想看看 Kotlin 是怎么编译运行的，以 JVM 为例，大概率是把 Kotlin 编译成 jar 包对吧，然后再调用 java 运行，我是这么猜的\n阅读官网文档\n官网 教程\n下载编译器\n\n我们去 GitHub 下载\n\n安装Java\n直接下载后解压，添加 bin 到系统环境变量里面，如果我i们这时候编译，会提示找不到 Java\n我们看官网教程写着最终确实是编译成 jar 包了，那我们就需要安装 Java 了\n\n我这里选择的是 Java 21 LTS 版本\n\n记得配置环境变量，这个网上一搜一大把， Java 1.5 版本之后就不需要再配置 ClassPath 了\n编译运行\n然后我们 就可以编译运行了\n\n结尾\n如果你问我为啥不写 Kotlin 编译成 JavaScript 的教程\n答：我不会。看样子、好像、大概是只能用 Kotlin multiplatform 来进行编译了，这是一个 Gradle 插件\n","tags":["kotlin","环境配置","k2"]},{"title":"Jvm 类加载 balabala","url":"/2023/11/06/Jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD-balabala/","content":"本文大量挪用 我竟然被” 双亲委派” 给虐了！-HollisChuang’s Blog\n如果可以还请看原文，原文写的非常好！！！强烈建议观看原文并点赞\n并且全网写得比较全的，我找了好几篇，基本都是抄的这个文章！！！\n另外juejin某篇 双亲委派机制（奥利给干就完了） 也是我写的，我正在慢慢把juejin里写过的文章慢慢倒过来。。。\n起因\n起因是因为某实习期的同事，在写代码的时候，写了大量static代码，导致启动缓慢\n因为kotlin去掉了static关键字，所以很多人在使用的时候会写入很多static代码\n趁此机会我输出一篇关于类加载的文章\n看类加载器\n1. 启动类加载器（Bootstrap Class Loader）\n\n    启动类加载器（Bootstrap Class Loader）点击查看更多 \n    \n      启动类加载器（Bootstrap Class Loader）是Java类加载器体系中的最顶层加载器，也是类加载器中最特殊的一个。它负责加载Java核心库，如java.lang等核心类，以及其他基础类库。以下是关于启动类加载器的详细讲解：\n\n\n实现和特点：\n\n启动类加载器通常是由Java虚拟机的实现提供的，并不是一个普通的Java类。\n它位于JVM内部，不是Java代码实现的，因此不能通过Java代码直接访问或自定义。\n启动类加载器是Java类加载器体系的最顶层，没有父加载器。\n\n\n\n加载范围：\n\n启动类加载器负责加载Java核心类库，这些类位于JVM的核心运行时环境中，如java.lang、java.util等核心包中的类。\n启动类加载器加载的类是所有Java应用程序共享的，它们具有最高的优先级。\n\n\n\n加载过程：\n\n启动类加载器的加载过程不同于其他类加载器。它是JVM启动时自行加载的，不经过类路径（Classpath）的搜索。\n-JVM内部的实现机制确保了核心类库的加载，因此无需自定义加载逻辑或自定义类加载器。\n\n\n\n安全性：\n\n启动类加载器的主要目的是确保Java核心库的安全性和完整性，防止用户自定义的类或恶意代码覆盖核心类库。\n由于启动类加载器不经过类路径的搜索，这样可以防止用户通过自定义的类加载器来加载核心类库的替代版本。\n\n\n\n自定义类加载器和扩展类加载器：\n\n虽然不能自定义或修改启动类加载器，但可以自定义类加载器，并通过它加载应用程序自身的类和资源。\n扩展类加载器（Extension Class Loader）位于启动类加载器和应用程序类加载器之间，它可以加载位于扩展类路径中的类。\n\n\n\n总之，启动类加载器是Java类加载器体系中的顶层加载器，负责加载Java核心类库，确保核心类库的安全性和完整性。它是Java虚拟机的一部分，不需要自定义或修改，通常由JVM的实现提供。这个加载器的存在有助于保持Java的安全性和稳定性。\n\n    \n  \n2. 扩展类加载器（Extension Class Loader）\n\n    扩展类加载器（Extension Class Loader）点击查看更多 \n    \n      扩展类加载器（Extension Class Loader）是Java类加载器体系中的一个重要组成部分，位于应用程序类加载器（Application Class Loader）之上，负责加载Java的扩展库和用户自定义的扩展类。以下是关于扩展类加载器的详细讲解：\n\n\n实现和层次结构：\n\n扩展类加载器通常由Java类sun.misc.Launcher$ExtClassLoader实现。\n它是应用程序类加载器的父加载器，属于类加载器体系中的第二层。\n扩展类加载器是纯Java代码实现的，相对于启动类加载器来说更容易理解和扩展。\n\n\n\n加载范围：\n\n扩展类加载器主要负责加载Java的扩展库，这些库包括位于&lt;JAVA_HOME&gt;/lib/ext目录下的JAR文件和用户自定义的扩展类库。\n用户可以将自己编写的扩展类放置在扩展类库目录中，然后扩展类加载器就可以加载它们。\n\n\n\n扩展类库目录：\n\n扩展类加载器搜索扩展类库的目录通常位于&lt;JAVA_HOME&gt;/lib/ext，这个目录包含了Java的标准扩展库。\n用户可以通过Java系统属性java.ext.dirs来指定其他扩展类库目录，以加载自定义扩展类。\n\n\n\n加载过程：\n\n当需要加载一个类时，扩展类加载器首先会检查是否已经加载了该类。如果已经加载，它直接返回类的Class对象。\n如果尚未加载该类，扩展类加载器尝试加载它。首先，它询问自己的父加载器（应用程序类加载器）是否能够加载。只有在父加载器无法加载时，扩展类加载器才会尝试加载。\n\n\n\n用户自定义扩展类：\n\n用户可以创建自定义的扩展类，并将它们放置在扩展类库目录中。\n这些自定义扩展类可以用于扩展Java的功能，例如添加自定义的API或功能。\n\n\n\n使用场景：\n\n扩展类加载器通常用于加载与Java平台相关的扩展库，以及用户自定义的扩展类。这些库和类通常不包含在Java核心库中，但可以为特定应用或环境提供有用的功能。\n\n\n\n总之，扩展类加载器是Java类加载器体系中的一个重要组成部分，用于加载Java的扩展库和用户自定义的扩展类。它的存在有助于扩展Java平台的功能，同时保持类加载的层次结构和隔离性。用户可以通过将自定义扩展类放置在扩展类库目录中来扩展Java的功能，而不需要修改核心类库或创建自定义类加载器。\n\n    \n  \n3. 应用程序类加载器（Application Class Loader）\n\n    应用程序类加载器（Application Class Loader）点击查看更多 \n    \n      应用程序类加载器（Application Class Loader），也称为系统类加载器，是Java类加载器中的一个重要组成部分。它主要负责加载应用程序中的类，包括用户编写的类和第三方库，通常是位于类路径（Classpath）上的类。以下是关于应用程序类加载器的详细讲解：\n\n\n实现和层次结构：\n\n应用程序类加载器是由Java虚拟机提供的，通常由Java类sun.misc.Launcher$AppClassLoader实现。\n它属于类加载器体系中的一级，是双亲委派模型中的中间层，其父加载器是扩展类加载器（Extension Class Loader），并且它的父加载器没有固定的Java类来实现。\n\n\n\n加载范围：\n\n应用程序类加载器负责加载应用程序的类，包括主程序和应用程序所依赖的第三方库。\n它搜索的类路径包括环境变量CLASSPATH指定的目录，以及Java虚拟机启动时通过命令行参数指定的类路径。\n\n\n\n加载过程：\n\n当应用程序需要加载一个类时，应用程序类加载器首先检查是否已经加载了该类。如果已经加载，它直接返回类的Class对象。\n如果尚未加载该类，应用程序类加载器会尝试加载它。首先，它询问扩展类加载器是否能够加载，如果扩展类加载器也无法加载，最终由应用程序类加载器自行尝试加载。\n\n\n\n自定义类加载器：\n\n应用程序类加载器可以作为自定义类加载器的父加载器，这意味着开发人员可以通过自定义类加载器来扩展或修改类加载的行为。\n自定义类加载器通常继承自ClassLoader类，并重写findClass方法以实现自定义的加载逻辑。\n\n\n\n安全性和隔离：\n\n应用程序类加载器有助于实现类加载的隔离和安全性。不同的Java应用程序可以有不同的应用程序类加载器，它们加载的类互相隔离，不会相互影响。\n这有助于防止不同应用程序之间的类冲突，确保每个应用程序都能够独立加载并执行其自己的类。\n\n\n\n总之，应用程序类加载器是Java类加载器体系中的一个重要组成部分，它负责加载应用程序中的类，包括用户编写的类和第三方库。它的工作遵循双亲委派模型，有助于保持类的一致性和安全性，并支持类加载的隔离和独立性。\n\n    \n  \n4. 自定义类加载器（Custom Class Loader）\n\n    自定义类加载器（Custom Class Loader）点击查看更多 \n    \n      自定义类加载器（Custom Class Loader）是Java类加载机制的一个重要部分，允许开发人员根据特定需求创建自定义加载逻辑，以加载类或资源。自定义类加载器通常用于特殊的场景，如加载加密的类文件、动态生成类、热部署等。以下是关于自定义类加载器的详细讲解：\n\n\n实现自定义类加载器：\n\n要实现自定义类加载器，需要创建一个Java类，该类应该继承自ClassLoader类，并重写其中的方法，尤其是findClass方法。findClass方法负责加载指定名称的类字节码，并将其转换为Class对象。\n\npublic class MyClassLoader extends ClassLoader &#123;    @Override    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;        // 加载类的字节码并转换为Class对象的逻辑    &#125;&#125;\n\n\n加载逻辑：\n\n在findClass方法中，您需要实现加载类的逻辑，通常是从特定位置加载类文件的字节码。\n您可以从文件系统、网络、数据库或其他来源加载字节码。\n加载的字节码需要经过类加载器转换成Class对象。\n\n\n\n父加载器：\n\n自定义类加载器通常会有一个父加载器，可以是应用程序类加载器或其他自定义类加载器。您可以在构造函数中指定父加载器，也可以使用系统类加载器作为默认父加载器。\n\npublic MyClassLoader() &#123;    super(); // 使用系统类加载器作为父加载器&#125;\n\n\n使用场景：\n\n自定义类加载器可用于许多场景，包括动态代码生成、插件化架构、热部署、安全沙盒等。\n例如，Web应用程序容器（如Tomcat）使用自定义类加载器来隔离不同Web应用程序的类加载，以防止类冲突。\n\n\n\n安全性和隔离：\n\n自定义类加载器的一个重要作用是实现类加载的隔离，防止不同类加载器加载的类相互干扰。\n每个自定义类加载器加载的类都在其加载范围内，不会影响其他类加载器加载的类。\n\n\n\n类加载器层次结构：\n\n自定义类加载器可以作为类加载器层次结构的一部分，可以根据需要创建多个自定义类加载器，形成类加载器的层次结构。\n\n\n\n安全性和权限：\n\n自定义类加载器可以设置安全策略和权限控制，以确保加载的类或资源遵循安全规则。\n\n\n\n总之，自定义类加载器是Java类加载机制的灵活部分，允许开发人员根据具体需求实现自定义加载逻辑。自定义类加载器通常继承自ClassLoader类，重写findClass方法来实现加载逻辑，同时可以实现加载的隔离和安全性。这些特性使自定义类加载器在特殊场景下非常有用。\n\n    \n  \n分析 static 类加载\n\n\n静态变量（Static Variables）：\n\n静态变量是属于类而不是对象的成员变量。它们在类加载时被初始化，且只会初始化一次。\n静态变量的初始化通常发生在类加载的初始化阶段，这是类加载的一个子阶段。初始化是在类加载时执行的代码块，用来初始化静态变量。\n静态变量的值在整个应用程序中是共享的，可以通过类名访问，而不需要创建类的实例。\n\n\n\n静态方法（Static Methods）：\n\n\n静态方法也属于类而不是对象。它们在类加载时被加载到内存中，并且不需要类的实例来调用。\n\n\n静态方法可以在类加载时执行一些初始化工作，例如初始化静态变量，或执行其他与类相关的操作。\n\n\n静态方法通常用于工具类或辅助方法，不需要与特定的实例关联。\n\n\n\n\n所以他会在加载类的时候，把静态成员执行加载\n双亲委派机制是什么\n当一个ClassLoader收到了 类加载的请求 的时候，他不会直接去加载指定的类，而是把这个请求 委托给自己的 父加载器 去加载。只有父加载器 无法加载这个类的时候，才会由 当前这个加载器 来负责类的加载。\n\n  \n    \n      什么情况下父加载器会无法加载某一个类呢？\n\n    \n    \n      也就是说，一个用户自定义的类，是永远不会被Bootstrap ClassLoader Extension ClassLoader加载的\n但是一个用户自定义的类，他也会被一直委托到Bootstrap ClassLoader，但是因为Bootstrap ClassLoader不负责加载该类，那么会再由Extension ClassLoader尝\n试加载，而Extension ClassLoader也不负责这个类的加载，最终才会被Application ClassLoader加载。\n\n    \n  \n为什么需要双亲委派？\n首先，通过委派的方式，可以避免类的重复加载，当父加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。\n另外，通过双亲委派的方式，还保证了安全性。\n因为Bootstrap ClassLoader在加载的时候，只会加载JAVA_HOME中的jar包里面的类，如java.lang.Integer，那么这个类是不会被随意替换的。\n除非有人跑到你的机器上， 在你的应用启动前破坏你的JDK，\n如果他在JDK已经启动的时候破坏你的JDK，因为你已经用Bootstrap ClassLoader加载了类，所以并不影响 ，所以只有从启动前对JDK搞破坏才可以。\n“父子加载器” 之间的关系是继承吗？\n很多人看到父加载器、子加载器这样的名字，就会认为Java中的类加载器之间存在着继承关系。\n甚至网上很多文章也会有类似的错误观点。\n\n这里需要明确一下，双亲委派模型中，类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码的。\n\n如下为 ClassLoader 中父加载器的定义：\npublic abstract class ClassLoader &#123;    // The parent class loader for delegation    private final ClassLoader parent;&#125;\n双亲委派是怎么实现的？\n双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现并不复杂。\n实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass()方法之中：\nprotected Class&lt;?&gt; loadClass(String name, boolean resolve)    throws ClassNotFoundException&#123;    synchronized (getClassLoadingLock(name)) &#123;            // 第一步，先检查类是否已经被加载过         Class&lt;?&gt; c = findLoadedClass(name);                        if (c == null) &#123;                    // 第二步，若没有加载则调用父加载器的 loadClass() 方法进行加载            long t0 = System.nanoTime();            try &#123;                if (parent != null) &#123;                    c = parent.loadClass(name, false);               &#125; else &#123;                                  // 第三步，若父加载器为空则默认使用 Bootstrap ClassLoader 作为父加载器                    c = findBootstrapClassOrNull(name);               &#125;           &#125; catch (ClassNotFoundException e) &#123;               // 第四步，如果父类加载失败，抛出 ClassNotFoundException 异常               // ClassNotFoundException thrown if class not found               // from the non-null parent class loader           &#125;                      if (c == null) &#123;               // 第五步，如果前面都失败，再调用自己的 findclass()                long t1 = System.nanoTime();               c = findClass(name);               // this is the defining class loader; record the stats               PerfCounter.getParentDelegationTime().addTime(t1 - t0);               PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);               PerfCounter.getFindClasses().increment();           &#125;       &#125;       if (resolve) &#123;           resolveClass(c);       &#125;       return c;   &#125;&#125;\n代码不难理解，主要就是以下几个步骤：\n\n先检查类是否已经被加载过\n若没有加载则调用父加载器的loadClass()方法进行加载\n若父加载器为空则默认使用Bootstrap ClassLoader作为父加载器\n如果父类加载失败，抛出ClassNotFoundException异常\n上一步如果失败，再调用自己的findClass()方法进行加载。\n\n如何主动破坏双亲委派机制？\n知道了双亲委派模型的实现，那么想要破坏双亲委派机制就很简单了。\n因为他的双亲委派过程都是在 loadClass 方法中实现的，那么想要破坏这种机制，那么就自定义一个类加载器，重写其中的 loadClass 方法，使其不进行双亲委派即可。\nloadClass（）、findClass（）、defineClass（）区别\nClassLoader中和类加载有关的方法有很多，前面提到了loadClass，除此之外，还有findClass和defineClass等，那么这几个方法有什么区别呢？\nloadClass()\n就是主要进行类加载的方法，默认的双亲委派机制就实现在这个方法中，重写这个方法可以破坏双亲委派机制。\nfindClass()\n根据名称或位置加载.class字节码\ndefinclass()\n把.class字节码转化为Class\n这里面需要展开讲一下loadClass和findClass，我们前面说过，当我们想要自定义一个类加载器的时候，并且想破坏双亲委派原则时，我们会重写loadClass方法。\n\n那么，如果我们想定义一个类加载器，但是不想破坏双亲委派模型的时候呢？\n\n这时候，就可以继承ClassLoader，并且重写findClass方法。findClass()方法是JDK1.2之后的ClassLoader新添加的一个方法。\n\n这是显而易见的，ClassLoader是一个抽象类，并且findClass(String name)是一个没有具体实现的方法，并且在上面我们看到了loadClass()里面调用了findClass()\n\n\n\n如图：这个方法只抛出了一个异常，没有默认实现。\nJDK1.2之后已不再提倡用户直接覆盖loadClass()方法，而是建议把自己的类加载逻辑实现到findClass()方法中。\n因为在loadClass()方法的逻辑里，如果父类加载器加载失败，则会调用自己的findClass()方法来完成加载。\n\n所以，如果你想定义一个自己的类加载器，并且要遵守双亲委派模型，那么可以继承ClassLoader，并且在findClass()中实现你自己的加载逻辑即可。\n双亲委派被破坏的例子\n双亲委派机制的破坏不是什么稀奇的事情，很多框架、容器等都会破坏这种机制来实现某些功能。\n\n\n第一种被破坏的情况是在双亲委派出现之前。\n由于双亲委派模型是在JDK1.2之后才被引入的，而在这之前已经有用户自定义类加载器在用了。所以，这些是没有遵守双亲委派原则的。\n\n\n第二种，是 JNDI、JDBC 等需要加载 SPI 接口实现类的情况。\n\n\n第三种是为了实现热插拔热部署工具。\n为了让代码动态生效而无需重启，实现方式时把模块连同类加载器一起换掉就实现了代码的热替换。\n\n\ntomcat 等 web 容器的出现。\n\n\nOSGI、Jigsaw 等模块化技术的应用。\n\n\n为什么 JNDI，JDBC 等需要破坏双亲委派？\n我们日常开发中，大多数时候会通过API的方式调用Java提供的那些基础类，这些基础类时被Bootstrap加载的。\n但是，调用方式除了API之外，还有一种SPI的方式。\n如典型的JDBC服务，我们通常通过以下方式创建数据库连接：\nConnection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/mysql&quot;, &quot;root&quot;, &quot;1234&quot;);\n在以上代码执行之前，DriverManager会先被类加载器加载，因为java.sql.DriverManager类是位于rt.jar下面的 ，所以他会被Bootstrap ClassLoader加载。\n类加载时，会执行该类的静态方法。其中有一段关键的代码是：\nServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);\n这段代码，会尝试加载classpath下面的所有实现了Driver接口的实现类。\n那么，问题就来了。\n\nDriverManager是被Bootstrap ClassLoader加载的，那么在加载时遇到以上代码，会尝试加载所有Driver的实现类，但是这些实现类基本都是第三方提供的，根据双亲委派原则，第三方的类不能Bootstrap ClassLoader加载。\n\n那么，怎么解决这个问题呢？\n于是，就在JDBC中通过引入ThreadContextClassLoader（线程上下文加载器，默认情况下是ApplicationClassLoader）的方式破坏了双亲委派原则。\n我们深入到ServiceLoader.load方法就可以看到：\npublic static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123;    ClassLoader cl = Thread.currentThread().getContextClassLoader();    return ServiceLoader.load(service, cl);&#125;\n第一行，获取当前线程的线程上下⽂类加载器ApplicationClassLoader，⽤于加载classpath中的具体实现类。\n\n说实话，我没怎么深入了解过JDBC，这一段没看太懂\n\n为什么 Tomcat 要破坏双亲委派\n我们知道，Tomcat 是 web 容器，那么一个 web 容器可能需要部署多个应用程序。\n不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。\n如多个应用都要依赖lucas.jar，但是 A 应用需要依赖1.0.0版本，但是 B 应用需要依赖1.0.1版本。这两个版本中都有一个类是com.lucas.Test.class。\n如果采用默认的双亲委派类加载机制，那么是无法加载多个相同的类。\n所以，Tomcat破坏双亲委派原则，提供隔离的机制，为每个web 容器单独提供一个WebAppClassLoader加载器。\nTomcat的类加载机制：为了实现隔离性，优先加载Web 应用自己定义的类，所以没有遵照双亲委派的约定，每一个应用自己的类加载器——WebAppClassLoader负责加载本身的目录下的class文件，加载不到时再交给CommonClassLoader加载，这和双亲委派刚好相反。\n模块化技术与类加载机制\n近几年模块化技术已经很成熟了，在 JDK 9 中已经应用了模块化的技术。\n\n其实早在JDK 9之前，OSGI这种框架已经是模块化的了，而OSGI之所以能够实现模块热插拔和模块内部可见性的精准控制都归结于其特殊的类加载机制，加载器之间的关系不再是双亲委派模型的树状结构，而是发展成复杂的网状结构。\n\n\n\n在JDK中，双亲委派也不是绝对的了。\n\n在JDK9之前，JVM的基础类以前都是在rt.jar这个包里，这个包也是JRE运行的基石。\n这不仅是违反了单一职责原则，同样程序在编译的时候会将很多无用的类也一并打包，造成臃肿。\n在JDK9中，整个JDK都基于模块化进行构建，以前的rt.jar,tool.jar被拆分成数十个模块，编译的时候只编译实际用到的模块，同时各个类加载器各司其职，只加载自己负责的模块。\nClass&lt;?&gt; c = findLoadedClass(cn);if (c == null) &#123;    // 找到当前类属于哪个模块    LoadedModule loadedModule = findLoadedModule(cn);    if (loadedModule != null) &#123;        //获取当前模块的类加载器        BuiltinClassLoader loader = loadedModule.loader();        //进行类加载        c = findClassInModuleOrNull(loadedModule, cn);     &#125; else &#123;          // 找不到模块信息才会进行双亲委派            if (parent != null) &#123;              c = parent.loadClassOrNull(cn);            &#125;      &#125;&#125;\n总结\n… 没有总结\n","tags":["kotlin","Java","Jvm"]},{"title":"Java io nio okio","url":"/2023/11/15/Java-io-nio-okio/","content":"io\n\n  \n    \n      i(输入)，o(输出)\n\n    \n    \n      只要是把数据从程序外部拷贝到程序内部，都叫输入，包括但不限于，硬盘文件数据，网络数据，其他应用程序的数据\n只要是把数据从程序内部拷贝到程序外部，都叫输入，包括但不限于，硬盘文件数据，网络数据，其他应用程序的数据\n\n    \n  \nFileInputStream &amp; FileOutPutStream\n我们对于 Stream 这类 Closable 对象都知道需要调用 close 函数，就比如 kotlin 的 use 函数，那么我们该如何把编写正确的作用域调用呢？\nFileInputStream\n// (1) 错误val inPutStream = FileInputStream(&quot;./asd.text&quot;)inPutStream.use &#123;  try &#123;    val char = inPutStream.read().toChar()    println(char)  &#125; catch (e: Exception) &#123;    e.printStackTrace()  &#125;&#125;// (2) 正确try &#123;  val inPutStream = FileInputStream(&quot;./asd.text&quot;)  inPutStream.use &#123;    println(inPutStream.read())  &#125;&#125; catch (e: Exception) &#123;  e.printStackTrace()&#125;\n因为FileInputStream函数会抛出异常\nuse函数在最后调用的Closable.close()也会抛出异常\n所以这两个函数都应该在 try 的作用域里\n// FileInputStream.javapublic FileOutputStream(String name) throws FileNotFoundException &#123;  this(name != null ? new File(name) : null, false);&#125;// Closeable.javapublic void close() throws IOException;\nFileOutPutStream\n同样， 使用OutPutStream也是这样，应该将初始化和use都放进try的作用域\ntry &#123;  val outPutStream = FileOutputStream(&quot;./asd.text&quot;)  outPutStream.use &#123;    val byteArray = byteArrayOf(&#x27;a&#x27;.code.toByte())    outPutStream.write(byteArray)  &#125;&#125; catch (e: Exception) &#123;  e.printStackTrace()&#125;\nReader &amp; Writer\nReader\nreader: 一次只能读一个字符，需要关闭！！！\n// (1) 错误val inPutStream = FileInputStream(&quot;./asd.text&quot;)inPutStream.use &#123;  val reader = InputStreamReader(inPutStream)  reader.use &#123;    println(reader.read().toChar())    println(reader.read().toChar())  &#125;&#125;// (2) 正确val inPutStream = FileInputStream(&quot;./asd.text&quot;)val reader = InputStreamReader(inPutStream)reader.use &#123;  println(reader.read().toChar())  println(reader.read().toChar())&#125;\n\n  \n    \n      多次调用close\n\n    \n    \n      由于 InputStreamReader 在调用 close 的时候，调用 InputStream 的 close，所以只需调用一次 InputStreamReader.close 即可\n\n    \n  \n\n  \n    \n      reader.readLines()\n\n    \n    \n      如果你习惯用kotlin你会发现还有一个方法reader.readLines()，这个方法可以把所有内容都读出来，返回一个文件的字符串数组\n这是kotlin官方写的扩展函数，其实内部实现是把reader又套了一层，变成了BufferedReader，并不是 reader的成员方法\n\n    \n  \nWriter\nWriter 和 Reader 一样，同样注意 close 一次\nWriter.flush() 是冲洗，效果就是将缓冲区的数据立刻写入文件\n在你刚调用 Writer.write() 的时候，文件里并不会有你写入的字符，需要调用 Writer.flush() 或者 Writer.close 才会写进去，这是因为你的缓冲区没有写满，当你的缓冲区写满的时候，会自动 flush()\n\n  \n    \n      应用场景\n\n    \n    \n      所以 flush() 的应用场景就是在你缓冲区没写满的时候，并且不再写入或者有其他需要立刻写入文件的需求时，你可以将调用此方法，立刻写入文件\n\n    \n  \n在你调用 Writer.close 的时候也会将缓冲区立刻写入文件，只不过它并不是调用 Writer.flush()，而是另外的原理，这里就不展开讲述了\n\n  \n    \n      注意！！！\n\n    \n    \n      \nOutPutStream.flush() 不做任何操作\nflush() 类似的调用，并不能确保文件的写入，他只是将这部分操作通知给操作系统，并不会进行写入检查\n\n\n    \n  \nBufferedReader\n\n  \n    \n      频繁的io（input&amp;output）造成的性能消耗\n\n    \n    \n      在程序执行过程中，频繁进行 io 是会造成很多性能消耗\n这取决于很多原因，不过关键因素在于 io 操作会依赖于外部了————也就是硬盘（这里指的不仅是物理硬盘，也有虚拟硬盘，或者操作系统优化过的硬盘，比如 nas）或者网络，也就是并不全都是在内存里进行操作了\n而且，开始读写文件到读写第一个字符的时间 要比 读写第一个字符到读写第二个字符的时间 要长的多！！！\n\n\n物理设备速度限制： 硬盘和网络等IO设备相比于内存和CPU速度较慢。\n\n\nIO操作的机制： 读写文件涉及操作系统的多个层面。这包括用户空间和内核空间之间的数据传输，文件系统的操作（比如定位文件位置、权限检查等），以及物理设备之间的数据传输。这些操作都需要系统资源，并且可能涉及上下文切换和系统调用，从而引入额外的开销。\n\n\n数据传输的开销： 数据传输本身有开销。在磁盘上，数据可能被分散存储在不同的位置（磁盘碎片化），导致需要更多的寻道时间。此外，网络IO也会受到带宽限制和延迟的影响。\n\n\n系统等待时间： 在进行IO操作时，CPU可能会处于空闲状态，因为IO操作通常会阻塞进程直到完成。这样的等待时间可能会降低系统的整体利用率，特别是在单线程或同步IO的情况下。\n\n\n\n    \n  \nBufferedReader就可以一定程度上减少 io 操作，因为他可以一次读写一行数据\n它继承自Reader所以也需要关闭\nval inPutStream = FileInputStream(&quot;./asd.text&quot;)val reader = InputStreamReader(inPutStream)val bufferedReader = BufferedReader(reader)bufferedReader.use &#123;  println(bufferedReader.readLine())&#125;\n复制文件\n了解了前面的操作，复制操作就会很简单了\nfun copyFile(srcFilePath: String, dstFilePath: String) &#123;  try &#123;    val inputStream = FileInputStream(srcFilePath)    val outputStream = FileOutputStream(dstFilePath)    val data = ByteArray(1024)    var len: Int    while (`is`.read(data).also &#123; len = it &#125; != -1) &#123;      os.write(data, 0, len)    &#125;    inputStream.close()    outputStream.close()  &#125; catch (e: Exception) &#123;    e.printStackTrace()  &#125;&#125;\nkotlin 的 use() 会增加嵌套所以有时候，并不一定要使用 use()，用 close() 反而更简洁\n如果这里使用 use()，反而会减少可读性\ninputStream.use &#123;`is`-&gt;  outputStream.use &#123; os -&gt;    while (`is`.read(data).also &#123; len = it &#125; != -1) &#123;      os.write(data, 0, len)    &#125;  &#125;&#125;\n网络 io\nbufferedReader 和 bufferedWriter 在这里是主要的应用场景\n我这里列举一个非常简陋的服务器代码\nfun networkIO() &#123;  try &#123;    val serverSocket = ServerSocket(8080)    val socket = serverSocket.accept()    val bufferedReader = BufferedReader(InputStreamReader(socket.getInputStream()))    val bufferedWriter = BufferedWriter(OutputStreamWriter(socket.getOutputStream()))    while (true) &#123;      val requireString = bufferedReader.readLine()      if (requireString == &quot;exit&quot;) &#123;        break      &#125;      bufferedWriter.write(&quot;response: $requireString\\n&quot;)      bufferedWriter.flush()    &#125;    bufferedReader.close()    bufferedWriter.close()    socket.close()  &#125; catch (e: Exception) &#123;    e.printStackTrace()  &#125;&#125;\n我们通过 ServerSocket.accept() 来等待建立连接，并会将客户端发的信息返回去，在客户端输入 exit 的时候，结束接收新的字符并关闭服务\n$ telnet localhost 8080Trying ::1...Connected to localhost.Escape character is &#x27;^]&#x27;.helloresponse: helloexitConnection closed by foreign host.\nnio (强制使用 Buffer)\nBuffer 操作细节\n我们以一个读文件的代码来讲解 nio 的原理\ntry &#123;  val randomAccessFile = RandomAccessFile(&quot;./asd.txt&quot;, &quot;rw&quot;)  val channel = randomAccessFile.channel  val byteBuffer = ByteBuffer.allocate(1024)  channel.read(byteBuffer)  byteBuffer.flip()  println(Charset.defaultCharset().decode(byteBuffer))&#125; catch (e: Exception) &#123;  e.printStackTrace()&#125;\n\n我画了一个图，蓝色为 buffer，capacity 是 buffer 的容量，limit 是限制符，position 是当前位置\n可以看到，当 Channel 读取字符到 Buffer 里面的时候，position 一直在记录当前位置\nByteBuffer.flip() 是切换读模式，其实就是 limit 记录 position 位置，position 重置为 0，mark 重置（mark 后面会提到）\n// ByteBuffer.javaByteBuffer flip() &#123;  super.flip();  return this;&#125;// Buffer.javapublic Buffer flip() &#123;  limit = position;  position = 0;  mark = -1;  return this;&#125;\n非阻塞网络 IO\n阻塞式 IO\nfun nioNetWorkIO() &#123;  try &#123;    val serverSocketChannel = ServerSocketChannel.open()    serverSocketChannel.bind(InetSocketAddress(8080))    val socketChannel = serverSocketChannel.accept()    val byteBuffer = ByteBuffer.allocate(1024)    while (socketChannel.read(byteBuffer) != -1) &#123;      byteBuffer.flip()      val requireString = Charset.defaultCharset().decode(byteBuffer).toString()      if (requireString == &quot;exit\\r\\n&quot;) &#123;        break      &#125;      byteBuffer.flip()      socketChannel.write(byteBuffer)      byteBuffer.clear()    &#125;  &#125; catch (e: Exception) &#123;    e.printStackTrace()  &#125;&#125;\n这段代码就能充分体现出来我们学习 Buffer 操作细节的作用了\n第 9 行对 byteBuffer 进行了读取操作，此时 limit 和 position 应该相等了，如果需要再次读取，应该再次修改 position 的位置。\n我们直接修改 position 也可以byteBuffer.position(0)重新调用一遍 flip 也可以\n并且在第 15 行，我们执行 clear ，方便下次的写入\n非阻塞式 IO\n\n    这一部分其实已经有点跑题了，看个乐呵，点击查看 \n    \n      fun nioNetWorkIOunBlocking() &#123;  try &#123;    val serverSocketChannel = ServerSocketChannel.open()    serverSocketChannel.bind(InetSocketAddress(8080))    serverSocketChannel.configureBlocking(false)    val selector = Selector.open()    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT)    while (true) &#123;      selector.select()      handleRequireData(selector)    &#125;  &#125; catch (e: IOException) &#123;    e.printStackTrace()  &#125;&#125;fun handleRequireData(selector: Selector) &#123;  val selectedKeys = selector.selectedKeys()  val keyIterator = selectedKeys.iterator()  while (keyIterator.hasNext()) &#123;    val key = keyIterator.next()    if (key.isAcceptable) &#123;      val serverChannel = key.channel() as ServerSocketChannel      val client = serverChannel.accept()      client.configureBlocking(false)      client.register(selector, SelectionKey.OP_READ)      println(&quot;Client connected: &quot; + client.remoteAddress)    &#125; else if (key.isReadable) &#123;      val client = key.channel() as SocketChannel      val buffer = ByteBuffer.allocate(1024)      val bytesRead = client.read(buffer)      if (bytesRead != -1) &#123;        buffer.flip()        val receivedData = String(buffer.array(), 0, bytesRead)        println(&quot;Received data: &quot; + receivedData + &quot; from &quot; + client.remoteAddress)        buffer.clear()      &#125; else &#123;        key.cancel()        client.close()        println(&quot;Client disconnected: &quot; + client.remoteAddress)      &#125;    &#125;    keyIterator.remove()  &#125;&#125;\n\n    \n  \nokio\n简单用法\nfun okioBufferRead(file: File) &#123;  file.source().buffer().use &#123; bufferedFileSource -&gt;      println(bufferedFileSource.readUtf8())  &#125;&#125;\nfun okioBufferWrite(file: File) &#123;  file.sink().buffer().use &#123; sink -&gt;    sink.writeUtf8(&quot;Hello World!&quot;)  &#125;&#125;\n\n  \n    \n      两种使用 Buffer 的方式\n\n    \n    \n      使用以下两种方法\n\n使用 file.source() 获取 InputStreamSource ，然后调用 fileSource.read(buffer, 1024) 写入 Buffer，然后调用 buffer.readUtf8() 读取 buffer\n使用 file.source().buffer() 获取 BufferedSource ，然后调用 bufferedFileSource.readUtf8() 读取\n\n这两种其实是一样的，只不过第一种需要你指定 buffer 大小\n但第二种是官方指定推荐的形式，并且更加智能\\简洁\n\n    \n  \n\n  \n    \n      okio的关闭\n\n    \n    \n      同样，BufferedSource.close() 会调用 Source.close() ,所以只要调用 BufferedSource.close() 就可以了\n\n    \n  \nbuffer 作为输出对象\n在传统 io 里面，Buffer 并不能作为输出位置，也就是说，我们可以有 FileOutPutStream 但是并没有  BufferOutPutStream\n而 okio 给了我们机会，他直接在自己的 Buffer 上写了一个 OutPutStream 这样我们就可以就可以直接输出到 Buffer 里了\nval buffer = Buffer()try &#123;  ObjectOutputStream(buffer.outputStream()).use &#123; objectOutputStream -&gt;    objectOutputStream.writeUTF(&quot;abc&quot;)    objectOutputStream.writeBoolean(true)    objectOutputStream.writeChar(&#x27;0&#x27;.code)    objectOutputStream.flush()    val objectInputStream = ObjectInputStream(buffer.inputStream())    println(objectInputStream.readUTF())  &#125;&#125; catch (e: Exception) &#123;  e.printStackTrace()&#125;\n\n同理 buffer.inputStream() 也是有的\n\n","tags":["kotlin","stream","流","java","io","nio","okio"]},{"title":"OpenGL on Mac 环境","url":"/2023/08/08/OpenGL-on-Mac-%E7%8E%AF%E5%A2%83/","content":"环境介绍\n这次我将环境部署到了Mac + Clion上\n\n其实并没有解决上次的编译glfw的问题，但好像不太影响使用\n因为我不会自己写编译脚本(〒︿〒)\n解决了！！！chatGPT 真好用！！！\n\n\nxcode-select --install\ngit clone https://github.com/glfw/glfw.gitcd glfwgit checkout 3.3.8\nmkdir buildcd build\ncmake -D CMAKE_C_COMPILER=/usr/bin/clang -D CMAKE_CXX_COMPILER=/usr/bin/clang++ ..\ncmake ..\n\n如果你需要生成动态库，就使用下面这个命令\n cmake -DBUILD_SHARED_LIBS=ON ..\n\nmake\n\n最后一个make install不一定要执行，这个命令会将编译的文件放进系统目录，我觉得没必要，你可以直接把文件拖出来，就像这样\n  \n如果你成功编译了，那么后续的步骤中，你就不需要再下载glfw了，只要下载glad就行了\n\n\n\n先看编译器\n$ gcc -vApple clang version 14.0.0 (clang-1400.0.29.202)Target: x86_64-apple-darwin21.6.0Thread model: posixInstalledDir: /Library/Developer/CommandLineTools/usr/bin\n\n\n你可以用自己编译好的glfw库，也可以下载glfw和glad\nglfw下载地址\nglad下载地址\n\n\n\n\n3.zshrc添加环境变量\n   export GLFW_HOME=&quot;/Users/.../opengl/glfw&quot;export GLAD_HOME=&quot;/Users/.../opengl/glad&quot;\n   \n\n\n都是默认的，参考上面的 步骤 1，gcc -v 里的InstalledDir\n\n\n\nCMakeLists.txt\n\n\n  cmake_minimum_required(VERSION 3.25)project(Cpp11)set(CMAKE_CXX_STANDARD 11)# 检查环境变量if (NOT DEFINED ENV&#123;GLFW_HOME&#125;)  message(FATAL_ERROR &quot;found no env named GLFW_HOME&quot;)endif ()if (NOT DEFINED ENV&#123;GLAD_HOME&#125;)  message(FATAL_ERROR &quot;found no env named GLAD_HOME&quot;)endif ()# 暂存环境变量set(GLFW_HOME $ENV&#123;GLFW_HOME&#125;)set(GLAD_HOME $ENV&#123;GLAD_HOME&#125;)# 设置头文件目录include_directories(&quot;$&#123;GLFW_HOME&#125;/include&quot;)include_directories(&quot;$&#123;GLAD_HOME&#125;/include&quot;)# 添加 GLFW3 预编译库add_library(glfw SHARED IMPORTED)SET_TARGET_PROPERTIES(glfw PROPERTIES IMPORTED_LOCATION &quot;$&#123;GLFW_HOME&#125;/lib-x86/libglfw.3.dylib&quot;)# 编译 GLAD 库add_library(glad SHARED &quot;$&#123;GLAD_HOME&#125;/src/glad.c&quot;)# 创建可执行文件add_executable(Cpp11    main.cpp    hello_triangle.cpp    hello_triangle.h)# 链接 GLFW GLAD OpenGLtarget_link_libraries(Cpp11 glfw glad &quot;-framework OpenGL&quot;)\n\n\n运行代码\n #include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;void framebuffer_size_callback(GLFWwindow*  window, int width, int height);void processInput(GLFWwindow* window);int main() &#123;    glfwInit(); // init glfw    // use version 3.3    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,  3); // set major version    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,  3); // set minor version    glfwWindowHint(GLFW_OPENGL_PROFILE,        GLFW_OPENGL_CORE_PROFILE); // use core profile    // MacOS specific code    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);    GLFWwindow* window = glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, NULL, NULL);   // 800*600 size window called LearnOpenGL    if (window == NULL) &#123;        std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;        glfwTerminate();    // 释放/删除之前的分配的所有资源        return -1;    &#125;    glfwMakeContextCurrent(window);   // set the current window    if (!gladLoadGLLoader((GLADloadproc)    glfwGetProcAddress)) &#123;        std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;        return -1;    &#125;    glViewport(0, 0, 800, 600);    // 设置窗口位置    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);    // 设置窗口大小调整回调    // 循环检查窗口是否需要被关闭    while (!glfwWindowShouldClose(window))&#123;            processInput(window);    // 监控ESC退出窗口        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);     // 调用glClearColor来设置清空屏幕所用的颜色        glClear(GL_COLOR_BUFFER_BIT);    // 调用glClear函数来清空屏幕的颜色缓冲        glfwSwapBuffers(window);    // 函数会交换颜 色缓冲（它是一个储存着GLFW窗口每一个像素颜色值的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。        glfwPollEvents();    // 检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）    &#125;    // 释放/删除之前的分配的所有资源    glfwTerminate();    return 0;&#125;void framebuffer_size_callback(GLFWwindow*  window, int width, int height)&#123;    glViewport(0, 0, width, height);&#125;// 监控ESC退出窗口void processInput(GLFWwindow* window)&#123;    if (glfwGetKey(window, GLFW_KEY_ESCAPE) ==  GLFW_PRESS)        glfwSetWindowShouldClose(window, true);&#125;\n\n\n注意这里多了一个glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n这是MacOS的区别于别于Windows的代码\n","tags":["OpenGL"]},{"title":"Kotlin data class 被 gson 解析遇到的坑","url":"/2025/02/27/Kotlin-data-class-%E8%A2%AB-gson-%E8%A7%A3%E6%9E%90%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/","content":"\n此篇文章来自于学习 Gson 和 Kotlin Data Class 的避坑指南\n本文的所有代码和结论都经过实际验证和推敲，并且加入了我自己的理解和细节，更多算是对原文作者的补充，像是一个学习笔记，原文写的非常好，但我也希望你能看看我的这篇文章，\n因为我对于我底层逻辑的思考很有信心，这里有简单的介绍 学习的本质在于摸透底层逻辑\n\n从一个 NullPointerException 开始\nimport com.google.gson.Gsondata class UserBean(val userName: String, val userAge: Int)fun main() &#123;    val json = &quot;&quot;&quot;&#123;&quot;userName&quot;:null,&quot;userAge&quot;:26&#125;&quot;&quot;&quot;    val userBean = Gson().fromJson(json, UserBean::class.java) //第一步    println(userBean) //第二步    printMsg(userBean.userName) //第三步&#125;fun printMsg(msg: String) &#123;&#125;\n这里例子输出的结果是\nUserBean(userName=null, userAge=26)Exception in thread &quot;main&quot; java.lang.NullPointerException: Parameter specified as non-null is null: method org.czb.MainKt.printMsg, parameter msg    at org.czb.MainKt.printMsg(Main.kt)    at org.czb.MainKt.main(Main.kt:11)    at org.czb.MainKt.main(Main.kt)\n这里初级程序员也能看出来 &quot;userName&quot;:null 和 username 的 String 类型声明是不对应的，String 是非空的 String 类型\n那么这次 gson 的反序列化，居然在调用 printMsg 的时候（第三步），报出了 NPE(NullPointerException)\n我们看看这个 printMsg，把它反编译成 Java 方法\npublic static final void printMsg(@NotNull String msg) &#123;   Intrinsics.checkNotNullParameter(msg, &quot;msg&quot;);&#125;\n可以看到，这里有 checkNotNullParameter 所以才会有 NPE\n也就是说，gson 反序列化成功了\n那么我们就需要再看 gson 到底是如何绕过非空类型的判断（nullsafe）的\ngson 如何绕过 null check\n我们在 fromJson 处打个断点，使用 IDEA 的 step into 功能，跳到源码去分析\n可以发现，前面都是 fromJson 的重名函数，直到这个 typeAdapter.read(reader)\n\n\n\n  \n    \n      提示\n\n    \n    \n      这里我使用的是 com.google.code.gson:gson:2.12.1 ，和原文章的作者应该是不一致的，所以源码也有所区别\n\n    \n  \n我们可以看到 508~526 都是在遍历 JsonReader ，我们稍后再看\n505 行是创建了一个累加器，我们看看这是干什么的，使用 step into 进去\n\n可以看到，createAccumulator 这里是调用了 ObjectConstructor 的 construct() 函数\n如果你直接从这里 step into 会直接跳转到 newUnsafeAllocator\n\n而这个 lambda 就是 constuct()，所以这个 newUnsafeAllocator 会返回一个 ObjectConstructor\n我们再看看 ObjectConstructor 除了这个实现，还有哪些实现\n\nnewSpecialCollectionConstructor 使用特殊集合类的构造函数（EnumSet，EnumMap）。\nnewDefaultConstructor 使用无参构造函数。\nnewDefaultImplementationConstructor 回退到默认接口实现，支持一些 Gson 写好的集合类型\n最后就是 newUnsafeAllocator 也就是我们确定的，这个 Gson 将这次我们使用的 data class 反序列化的构建对象的方式\n\n注意上面的注释 // Consider usage of Unsafe as reflection, so don't use if BLOCK_ALL     // Additionally, since it is not calling any constructor at all, don't use if BLOCK_INACCESSIBLE\n考虑使用不安全的反射，因此请不要使用block_all，因为它根本不调用任何构造函数\n所以这是一个兜底策略，或者说最终手段\n\n\n  \n    \n      关于 UnsafeAllocator\n\n    \n    \n      类似 C 里面的 malloc 这里 Allocator 其实是一个含义————分配器。所以我们可以大概猜测，这里是和 C 类似的内存分配方式。这里其实也是对于中国程序员不友好的地方，英语的本身意思其实多多少少蕴含了一些代码的设计意图。\n\n    \n  \n然后我们在继续推进，看看这里 newUnsafeAllocator\n\n可以看到这里使用 sun.misc.Unsafe 反射初始化了一个对象，然后又使用反射获取了 allocateInstance ，调用它生成了一个 UnsafeAllocator 也就是 ObjectConstructor&lt;T&gt;\n而 ObjectConstructor&lt;T&gt; 里面只有一个返回 T 的 construct() 函数，所以 createAccumulator 最终就会返回这个被构造出来对象，并且没有使用 要被反序列化的那个类的任何构造函数，因此就跳过了 null check\n使用默认值规避 null 风险？？？\n如果我们给 userName 一个默认值，那么就可以规避掉风险了吗？我们看例子。\ndata class UserBean(val userName: String = &quot;dark&quot;, val userAge: Int)fun main() &#123;    val json = &quot;&quot;&quot;&#123;&quot;userAge&quot;:26&#125;&quot;&quot;&quot;    val userBean = Gson().fromJson(json, UserBean::class.java)    println(userBean)&#125;\n它的输出结果如下\nUserBean(userName=null, userAge=26)\n这里直接放结论，因为 Gson 使用了 UnsafeAllocator 没有使用任何构造函数，所以默认值并不会被加进去，而是会出现 null\n解决 gson 反序列化中 null 的方法\n为什么我们要在之前分析 gson 的生成 ObjectConstructor 的多种方式呢？\n最重要的点就在于可以帮我们找到解决问题的思路，也就是看看如何不使用 newUnsafeAllocator\n生成无参构造函数\n\n\n添加无参构造函数\ndata class UserBean(val userName: String, val userAge: Int)&#123;    constructor():this(userName = &quot;dark&quot;, userAge = 0)&#125;\n\n\n使用 @JvmOverloads\n这个方法类似于第一种，也是相当于提供了一个无参构造函数\ndata class UserBean @JvmOverloads constructor(val userName: String = &quot;dark&quot;, val userAge: Int = 0)\n\n  \n    \n      注意\n\n    \n    \n      @JvmOverloads 会将有默认值的参数依次忽略，生成重载方法，所以我们需要将所有参数都给上默认值，这样才能生成默认构造函数\n\n    \n  \n\n\n不使用 data class 像 java 一样，写成成员变量（字段）\nclass UserBean &#123;    var userName = &quot;dark&quot;    var userAge = 0    override fun toString(): String &#123;        return &quot;UserBean(userName=$userName, userAge=$userAge)&quot;    &#125;&#125;\n\n\n这前三种都是通过生成默认构造函数\n这里我们继续打断点 debug 看出，gson 调用的是 newDefaultConstructor\n终极方案 放弃 Gson\n比如我们可以改用 moshi\ngson 目前对 kotlin 还不够友好，moshi 对 kotlin 的支持会更好，里面有专门针对 kotlin 的适配器\nmoshi 是 square 公司提供的一个开源库，就是那个开发了 okhttp 的公司\nimport com.squareup.moshi.JsonAdapterimport com.squareup.moshi.Moshiimport com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactorydata class UserBean(val userName: String = &quot;dark&quot;, val userAge: Int)fun main() &#123;    val json = &quot;&quot;&quot;&#123;&quot;userAge&quot;:26&#125;&quot;&quot;&quot;    val moshi = Moshi.Builder()        .addLast(KotlinJsonAdapterFactory())        .build()    val jsonAdapter: JsonAdapter&lt;UserBean&gt; = moshi.adapter(UserBean::class.java)    val userBean = jsonAdapter.fromJson(json)    println(userBean)&#125;\nUserBean(userName=dark, userAge=26)\n另外，还有之前的问题，moshi 并不会在出现类型冲突的时候，成功反序列化\n// 空出 3 行对齐我 IDEA 里的行号，方便对应输出结果对应的行号import com.squareup.moshi.JsonAdapterimport com.squareup.moshi.Moshiimport com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactorydata class UserBean(val userName: String = &quot;dark&quot;, val userAge: Int)fun main() &#123;    val json = &quot;&quot;&quot;&#123;&quot;userName&quot;:null,&quot;userAge&quot;:26&#125;&quot;&quot;&quot;    val moshi = Moshi.Builder()        .addLast(KotlinJsonAdapterFactory())        .build()    val jsonAdapter: JsonAdapter&lt;UserBean&gt; = moshi.adapter(UserBean::class.java)    val userBean = jsonAdapter.fromJson(json)    println(userBean)&#125;\nException in thread &quot;main&quot; com.squareup.moshi.JsonDataException: Non-null value &#x27;userName&#x27; was null at $.userName    at com.squareup.moshi.internal.Util.unexpectedNull(Util.java:674)    at com.squareup.moshi.kotlin.reflect.KotlinJsonAdapter.fromJson(KotlinJsonAdapter.kt:89)    at com.squareup.moshi.internal.NullSafeJsonAdapter.fromJson(NullSafeJsonAdapter.java:41)    at com.squareup.moshi.JsonAdapter.fromJson(JsonAdapter.java:70)    at org.czb.MainKt.main(Main.kt:15)    at org.czb.MainKt.main(Main.kt)\n四、扩展知识（平台类型）\n再来看个扩展知识，和 Gson 无直接关联，但是在开发中也是蛮重要的一个知识点\njson 为空字符串，此时 Gson 可以成功反序列化，且得到的 userBean 为 null\n还是以 data class UserBean(val userName: String, val userAge: Int) 为例子\nfun main() &#123;    val json = &quot;&quot;    val userBean = Gson().fromJson(json, UserBean::class.java)&#125;\n如果加上类型声明：UserBean?，那也可以成功反序列化\nfun main() &#123;    val json = &quot;&quot;    val userBean: UserBean? = Gson().fromJson(json, UserBean::class.java)&#125;\n如果加上的类型声明是 UserBean 的话，那就比较好玩了，会直接抛出 NullPointerException\nfun main() &#123;    val json = &quot;&quot;    val userBean: UserBean = Gson().fromJson(json, UserBean::class.java)&#125;\nException in thread &quot;main&quot; java.lang.NullPointerException: fromJson(...) must not be null   at org.czb.MainKt.main(Main.kt:12)   at org.czb.MainKt.main(Main.kt)\n以上三个例子会有不同区别的原因是什么呢？\n这是在 kotlin 调用 java 的时候会出现的，官方文档写着“Java 中的任何引用都可能是 null，这使得 Kotlin 对来自 Java 的对象要求严格空安全是不现实的。 Java 声明的类型在 Kotlin 中会以特殊方式对待并称为平台类型。”\n就是 kotlin 在调用 java 代码的时候，会把 java 里的类型以平台类型（platform type）对待，例如 java 中的 String 会当做 String!\n\n  \n    平台类型只是编译器的中间产物，并不能显式使用在代码里， val s:String! 是不允许出现在代码里的\n\n  \n所以对于写 kotlin 的程序员来说，在使用 kotlin 调用 java 代码的时候，稳妥的方式是自己进行判空处理，或者对于 java 程序员来说，写上 @NotNull 和 @Nullable 这类参数\n回到我们的这个，当我们从 Kotlin 承接 Gson 这个 Java 类返回的变量时，既可以将其当做 UserBean 类型，也可以当做 UserBean? 类型。而如果我们直接显式声明为 UserBean 类型，就说明我们确信返回的是非空类型，当返回的是 null 时就会触发 Kotlin 的 null check，导致直接抛出 NullPointerException\n","tags":["kotlin","json","gson","data class"]},{"title":"OpenGL 三角形","url":"/2023/08/15/OpenGL-%E4%B8%89%E8%A7%92%E5%BD%A2/","content":"渲染管线\n\n这是常见的渲染管线的图，每一步都以上一步的输出为输入，图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。\n\n\n图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。\n顶点着色器主要的目的是把3D坐标转为另一种3D坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理。\n\n\n图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。\n\n\n图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。\n\n\n几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。\nOpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。\n\n\n片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。\n\n\n在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。\n\n\n看代码之前\n看代码之前我们要明确怎么写\n\n我们要初始化我们使用的工具, 比如：glfw\n创建一个窗口，并为窗口注册事件监听，后面的绘制都在这个窗口上操作\n编译着色器\n\n编译顶点着色器\n编译片段着色器\n\n\n生成 program，链接着色器\n绑定 VAO，VBO，或者以后还可能有 EBO，并设置他们的参数\n循环中绘制图形\n\n代码\nhello_triangle.h👇\n#ifndef OPENGL_ENVIRONMENT_TEST_HELLO_TRIANGLE_H#define OPENGL_ENVIRONMENT_TEST_HELLO_TRIANGLE_H#include &lt;string&gt;// GLAD is used to manage Open GL function pointers#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#define WINDOW_WIDTH 800#define WINDOW_HEIGHT 800#define WINDOW_TITLE &quot;lucas-opengl&quot;using namespace std;class hello_triangle &#123;public:    static int create_a_triangle();private:    static void draw_frame(unsigned int shaderProgram, unsigned int VAO);    static void processInput(GLFWwindow *window);    static void framebuffer_size_callback(GLFWwindow *window, int width, int height);    static void init_glfw();    static GLFWwindow *create_glfw_window();    static void check_shader(unsigned int shader, const string &amp;type);    static void check_program(unsigned int shaderProgram);&#125;;#endif //OPENGL_ENVIRONMENT_TEST_HELLO_TRIANGLE_H\nhello_triangle.cpp👇\n#include &lt;iostream&gt;#include &quot;hello_triangle.h&quot;int hello_triangle::create_a_triangle() &#123;    init_glfw();    GLFWwindow *window = create_glfw_window();    if (window == nullptr) &#123;        return -1;    &#125;    // Set the context of our window to the main context of the current thread    glfwMakeContextCurrent(window);    // glfwGetProcAddress is the function GLFW get Open GL pointer    // check if GLAD can use the glfw function in order to initialize GLAD    if (!gladLoadGLLoader((GLADloadproc) glfwGetProcAddress)) &#123;        std::cout &lt;&lt; &quot;failed to initialize GLAD&quot; &lt;&lt; std::endl;        glfwTerminate();        return -1;    &#125;    // 注册 framebuffer_size_callback    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);    // ********************* 编译着色器 ****************************    const char *vertexShaderSource = &quot;#version 330 core\\n&quot;                                     &quot;layout (location = 0) in vec3 aPos;\\n&quot;                                     &quot;void main()&#123;\\n&quot;                                     &quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n&quot;                                     &quot;&#125;\\0&quot;;    const char *fragmentShaderSource = &quot;#version 330 core\\n&quot;                                       &quot;out vec4 FragColor;\\n&quot;                                       &quot;void main()&#123;\\n&quot;                                       &quot;    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n&quot;                                       &quot;&#125;\\0&quot;;    // vertex shader    // create a shader    unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);    glShaderSource(vertexShader, 1, &amp;vertexShaderSource, nullptr);    glCompileShader(vertexShader);    // check if the vertexShader compiled successfully    check_shader(vertexShader, &quot;GL_VERTEX_SHADER&quot;);    // fragment shader    // create a shader    unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);    glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);    glCompileShader(fragmentShader);    // check if the fragmentShader compiled successfully    check_shader(fragmentShader, &quot;GL_FRAGMENT_SHADER&quot;);    // ********************* 链接着色器，编译 program ****************************    unsigned int shaderProgram = glCreateProgram();    glAttachShader(shaderProgram, vertexShader);    glAttachShader(shaderProgram, fragmentShader);    glLinkProgram(shaderProgram);    // check if the program compiled successfully    check_program(shaderProgram);    // delete shader    glDeleteShader(vertexShader);    glDeleteShader(fragmentShader); // ******************************************************************************** // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).        float vertices[] = &#123;            -0.5f, -0.5f, 0.0f,            0.5f, -0.5f, 0.0f,            0.0f, 0.5f, 0.0f    &#125;;    unsigned int VAO, VBO;    glGenVertexArrays(1, &amp;VAO);    glGenBuffers(1, &amp;VBO);    // 1.绑定 VAO    glBindVertexArray(VAO);    // 2.绑定 VBO    glBindBuffer(GL_ARRAY_BUFFER, VBO);    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);    // 3.设置 Attribute    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void *) nullptr);    glEnableVertexAttribArray(0);    // ********************************************************************************    // note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute&#x27;s bound vertex buffer object so afterward we can safely unbind    glBindBuffer(GL_ARRAY_BUFFER, 0);    // You can unbind the VAO afterward so other VAO calls won&#x27;t accidentally modify this VAO, but this rarely happens. Modifying other    // VAOs requires a call to glBindVertexArray , so we generally don&#x27;t unbind VAOs (nor VBOs) when it&#x27;s not directly necessary.    glBindVertexArray(0);    while (!glfwWindowShouldClose(window)) &#123;        processInput(window);        draw_frame(shaderProgram, VAO);        // 交换 Buffer        glfwSwapBuffers(window);        // glfwPollEvents函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）        glfwPollEvents();    &#125;    // 释放/删除之前的分配的所有资源    glfwTerminate();    return 0;&#125;/** * initialize glfw */void hello_triangle::init_glfw() &#123;    // glfw initialize    glfwInit();    // Use OpenGL 3.3 version    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);    // GLFW use core profile    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);    // MacOS specific code    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);&#125;/** * create_glfw_window and check */GLFWwindow *hello_triangle::create_glfw_window() &#123;    // Create a windows    GLFWwindow *window = glfwCreateWindow(WINDOW_WIDTH, WINDOW_HEIGHT, WINDOW_TITLE, nullptr, nullptr);    // Check if the window is created successfully    if (window == nullptr) &#123;        std::cout &lt;&lt; &quot;failed to create GLFW window&quot; &lt;&lt; std::endl;        glfwTerminate();    &#125;    return window;&#125;/** * 回调函数，在窗口大小调整的时候，调整 ViewPort 的大小 * @param window * @param width * @param height */void hello_triangle::framebuffer_size_callback(GLFWwindow *window, int width, int height) &#123;    glViewport(0, 0, width, height);&#125;/** * 检测是否有按键输入 * 如果按下了 esc 就设置当前窗口应该退出 * @param window */void hello_triangle::processInput(GLFWwindow *window) &#123;    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;        glfwSetWindowShouldClose(window, true);    &#125;&#125;void hello_triangle::check_shader(unsigned int shader, const string &amp;type) &#123;    int success;    char infoLog[512];    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;success);    if (!success) &#123;        glGetShaderInfoLog(shader, 512, NULL, infoLog);        std::cout &lt;&lt; &quot;ERROR::SHADER:: &quot; &lt;&lt; type &lt;&lt; &quot; ::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;    &#125;&#125;void hello_triangle::check_program(unsigned int shaderProgram) &#123;    int success;    char infoLog[512];    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);    if (!success) &#123;        glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);        cout &lt;&lt; &quot;ERROR::shaderProgram::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; endl;    &#125;&#125;void hello_triangle::draw_frame(unsigned int shaderProgram, unsigned int VAO) &#123;    // 设置调用 clear 所使用的颜色    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);    // 清空屏幕    glClear(GL_COLOR_BUFFER_BIT);    // draw our first triangle    glUseProgram(shaderProgram);    // seeing as we only have a single VAO there&#x27;s no need to bind it every time, but we&#x27;ll do so to keep things a bit more organized    glBindVertexArray(VAO);    glDrawArrays(GL_TRIANGLES, 0, 3);    glBindVertexArray(0);&#125;\n代码讲解\n对比上次的代码，这次多了不少，除了一些代码结构的改动，剩下的主要是在于\n1. 编译着色器\n第 29 到 59 行\n这里是编译着色器\n// ********************* 编译着色器 ****************************const char *vertexShaderSource = &quot;#version 330 core\\n&quot;                                 &quot;layout (location = 0) in vec3 aPos;\\n&quot;                                 &quot;void main()&#123;\\n&quot;                                 &quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n&quot;                                 &quot;&#125;\\0&quot;;const char *fragmentShaderSource = &quot;#version 330 core\\n&quot;                                   &quot;out vec4 FragColor;\\n&quot;                                   &quot;void main()&#123;\\n&quot;                                   &quot;    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n&quot;                                   &quot;&#125;\\0&quot;;// vertex shader// create a shaderunsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);glShaderSource(vertexShader, 1, &amp;vertexShaderSource, nullptr);glCompileShader(vertexShader);// check if the vertexShader compiled successfullycheck_shader(vertexShader, &quot;GL_VERTEX_SHADER&quot;);// fragment shader// create a shaderunsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);glCompileShader(fragmentShader);// check if the fragmentShader compiled successfullycheck_shader(fragmentShader, &quot;GL_FRAGMENT_SHADER&quot;);\n这里定义了两个着色器源代码\n1.1 顶点着色器源码 GLSL\nlayout (location = 0) in vec3 aPos;\n这里是in代表输入，类型是 vec3 ，含有 3 个值的向量，同时设置了location=0的位置值\ngl_position为输出，是一种图元类型，类型为 vec4 ，四个分量分别是 gl_position.x , gl_position.y , gl_position.z , gl_position.w ，xyz 是坐标量，w 是到相机的距离（这个以后再研究）\nvec 最多有 4 个分量，通过后缀可以看出来\n1.2 片段着色器源码 GLSL\nout vec4 FragColor\nout代表输出，FragColor类型是 vec4，四个分量分别是 red , green , blue , alpha(透明度)\n每个值的范围都是 0-1，float\n1.3 编译操作\n我们先调用glCreateShader(GL_VERTEX_SHADER)创建一个GL_VERTEX_SHADER类型的着色器，并返回句柄\n在调用glShaderSource来指定着色器源代码\nvoid glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length);\n这个函数帮我们把多个字符串拼接成一整个源代码，以便编译\n\n这个函数有四个参数，第一个是我们上一行创建的shader的句柄，第二个是字符串的数量（因为有可能我们会编译多个shader，如果这些shader的某些源代码是一样的，我们就可以将这部分写成共用的，减少字符串冗余），第三个是字符串数组的起始指针（也就是数组的起始地址，如果只有一个字符串，只需传入这个字符串的首地址即可），最后一个是结束编译源代码的结束标志（这里也是一个指针类型，要求传入一个长度为第二个参数count的整形数组，为了给每个字符串设置长度限制，如果整形数组里有负数，对应字符串以空字符为结束标志，如果这里直接传入NULL那么所有字符串都以空字符为结束标志）\n\nglCompileShader就是编译源代码的过程，我们可以通过glGetShaderiv来检查是否编译成功\n\nps : 片段着色器创建的时候，和顶点着色器填写的类型不同，为GL_FRAGMENT_SHADER\n\n2. 生成 program，链接着色器\n第 61 到 72 行\nunsigned int shaderProgram = glCreateProgram();glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);glLinkProgram(shaderProgram);// check if the program compiled successfullycheck_program(shaderProgram);// delete shaderglDeleteShader(vertexShader);glDeleteShader(fragmentShader);\n这里我们需要将编译好的着色器链接到一个可执行的程序，以便后续一键执行\n这里和上面是一样的，我们需要调用一个create函数，来创建一个program，并拿到他的句柄\nglAttachShader是用来着色器附到program上面\nglLinkProgram是用来将他们链接起来，这步操作会生成着色器对应的可执行文件\n同样我们可以使用glGetProgramiv来检验是否链接成功\n然后，我们链接成功了，编译好的Shader就没用了，可以直接删除了\n直接调用glDelete将它删除\n3. VAO 和 VBO\n\n\n顶点数组对象：Vertex Array Object，VAO\nVAO 存储顶点属性（vertex attributes）的调用，这个有点抽象，我们后面详细讲解。\n\n\n顶点缓冲对象：Vertex Buffer Object，VBO\nVBO 存储顶点本身，是为了一次性向 GPU 传输大量顶点，因为从 CPU 往 GPU 发送数据是相对慢的。\n\n\n第 74 到 102 行\n// ********************************************************************************// bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).float vertices[] = &#123;        -0.5f, -0.5f, 0.0f,        0.5f, -0.5f, 0.0f,        0.0f, 0.5f, 0.0f&#125;;unsigned int VAO, VBO;glGenVertexArrays(1, &amp;VAO);glGenBuffers(1, &amp;VBO);// 1.绑定 VAOglBindVertexArray(VAO);// 2.绑定 VBOglBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3.设置 AttributeglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void *) nullptr);glEnableVertexAttribArray(0);// ********************************************************************************// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute&#x27;s bound vertex buffer object so afterward we can safely unbindglBindBuffer(GL_ARRAY_BUFFER, 0);// You can unbind the VAO afterward so other VAO calls won&#x27;t accidentally modify this VAO, but this rarely happens. Modifying other// VAOs requires a call to glBindVertexArray , so we generally don&#x27;t unbind VAOs (nor VBOs) when it&#x27;s not directly necessary.glBindVertexArray(0);\n这里定义了 vertices 也就是顶点，为了说明三角形的位置\nfloat vertices[] = &#123;     -0.5f, -0.5f, 0.0f,     0.5f, -0.5f, 0.0f,     0.0f, 0.5f, 0.0f &#125;;\n这里是 3D 坐标，所以最后一个都是 0\n图形大概长这样\n\n3.1 VBO 和 顶点缓冲对象\n// 绑定 VBOglBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\nglBind来绑定 VAO 和 VBO\nglBufferData 会把之前定义的顶点数据复制到缓冲的内存中，所以这个函数只能在绑定了 VBO 之后调用\n/** * 它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。 * 第二个参数指定传输数据的大小(以字节为单位)；用一个简单的`sizeof`计算出顶点数据大小就行。 * 第三个参数是我们希望发送的实际数据。 * 第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式： * - GL_STATIC_DRAW ：数据不会或几乎不会改变。 * - GL_DYNAMIC_DRAW：数据会被改变很多。 * - GL_STREAM_DRAW ：数据每次绘制时都会改变。 *  * 三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。 * 如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。*/void glBufferData(GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage);\n3.2 VAO 和 顶点属性\n// 绑定 VAOglBindVertexArray(VAO);\n我们之前说的了—— VAO 存储顶点属性（vertex attributes）的调用，我们使用 learn-opengl 的图来解释一下\n\n可以看到 VAO 里面都是 pointer ，我们将一开始写的那个 float 数组存放在 VBO 里面，然后调用 glVertexAttribPointer 进行设置属性调用指针（从函数名里的 pointer 就能看出来）\n接下来我们来看这个 glVertexAttribPointer 函数：\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void *) nullptr);glEnableVertexAttribArray(0);\n/** * index : 指定要修改的通用顶点属性的索引，还记得我们一开始 vertices 里填写的 location 吗，就是这个数。 * size : 指定每个顶点属性的向量大小。，就个属性一次读取几个数，vec3类型 就填写 3 就行。 * type : 指定数组中每个组件的数据类型，直接填写 GL_FLOAT。 * normalized : 是否标准化，填写 GL_TRUE 会让显卡帮我们把点映射到 0~1 之间（因为这里我们写的是 unsigned），如果我们写的是有符号的数，则会被限制在 -1~1 之间， * 所以我们这里填写 GL_FALSE * stride : 步长（步幅），指定连续通顶点属性之间的字节偏移量。显然我们下一组顶点数据在 3 个 float 之后，所以我们直接 sizeof 3 个 float * pointer : 这里是位置数据偏移量，就是开始读取的位置，由于是从头开始，我们可以直接写 0（C++ 新标准 写的是 nullptr） */glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer)\n这样我们的顶点属性就设置好了，最后调用一句glEnableVertexAttribArray(0);让这个location为0的定点生效（激活）\n\n每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）\n获取则是通过在调用glVertexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的。\n由于在调用glVertexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性0现在会链接到它的顶点数据。\n\n3.3 解绑\nglBindBuffer(GL_ARRAY_BUFFER, 0);glBindVertexArray(0);\n然后我们就可以解绑 VAO 和 VBO 了，可以看到，我们希望 VAO 和 VBO 对应起来，就需要绑定并设置他们，然后再解绑\n在后面我们需要调用 VAO 来绘制的时候，也是这样\n绑定 -&gt; 操作 -&gt; 解绑\n只不过这是只有一个VAO，没有切换到其他VAO的需求，所以我们没必要不断绑定再解绑，但如果写了解绑其实更加标准，更加完整。\n4. 开始绘制\nwhile (!glfwWindowShouldClose(window)) &#123;    processInput(window);    draw_frame(shaderProgram, VAO);    // 交换 Buffer    glfwSwapBuffers(window);    // glfwPollEvents函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）    glfwPollEvents();&#125;// 释放/删除之前的分配的所有资源glfwTerminate();\n这里我们用一个循环不断执行绘制流程，这个上篇文章就讲过，我们这里尤其讲一下这个draw_frame\nvoid hello_triangle::draw_frame(unsigned int shaderProgram, unsigned int VAO) &#123;    // 设置调用 clear 所使用的颜色    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);    // 清空屏幕    glClear(GL_COLOR_BUFFER_BIT);    // draw our first triangle    glUseProgram(shaderProgram);    // seeing as we only have a single VAO there&#x27;s no need to bind it every time, but we&#x27;ll do so to keep things a bit more organized    glBindVertexArray(VAO);    glDrawArrays(GL_TRIANGLES, 0, 3);    glBindVertexArray(0);&#125;\n我们这里中看下最后四行代码\n// draw our first triangleglUseProgram(shaderProgram);// seeing as we only have a single VAO there&#x27;s no need to bind it every time, but we&#x27;ll do so to keep things a bit more organizedglBindVertexArray(VAO);glDrawArrays(GL_TRIANGLES, 0, 3);glBindVertexArray(0);\n可以看到在调用了glUseProgram之后，和之前说的一样，绑定 -&gt; 绘制 -&gt; 解绑\n/** * mode : 渲染的图元类型，我们这里指定的是 GL_TRIANGLES（三角形） * first : 起始索引 * count : 一共绘制几个顶点 */void glDrawArrays(GLenum mode, GLint first, GLsizei count);\n到这里，三角形应该就会出现在你的屏幕上了\n\n开始欢呼吧！！！🎉🎉🎉\n","tags":["OpenGL"]},{"title":"OpenGL 多个三角形","url":"/2023/09/02/OpenGL-%E5%A4%9A%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/","content":"使用 EBO\n元素缓冲对象(Element Buffer Object，EBO)，也叫索引缓冲对象(Index Buffer Object，IBO)\nEBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储OpenGL用来决定要绘制哪些顶点的索引。\n举个例子：如果我们需要绘制一个正方形，我们可以通过绘制两个三角形实现\nfloat vertices[] = &#123;    // 第一个三角形    0.5f, 0.5f, 0.0f,   // 右上角    0.5f, -0.5f, 0.0f,  // 右下角    -0.5f, 0.5f, 0.0f,  // 左上角    // 第二个三角形    0.5f, -0.5f, 0.0f,  // 右下角    -0.5f, -0.5f, 0.0f, // 左下角    -0.5f, 0.5f, 0.0f   // 左上角&#125;;\n可以看到，我们有两个点是重复的\n如果要绘制的三角形更多，那重复的点会更多，就会有更多的冗余代码，造成大量的空间浪费\nEBO正是解决这个问题的，它用来存储我们绘制顶点的索引（顺序）\nfloat vertices[] = &#123;    0.5f, 0.5f, 0.0f,   // 右上角    0.5f, -0.5f, 0.0f,  // 右下角    -0.5f, -0.5f, 0.0f, // 左下角    -0.5f, 0.5f, 0.0f   // 左上角&#125;;unsigned int indices[] = &#123;    // 注意索引从0开始!     // 此例的索引(0,1,2,3)就是顶点数组vertices的下标，    // 这样可以由下标代表顶点组合成矩形    0, 1, 3, // 第一个三角形    1, 2, 3  // 第二个三角形&#125;;\n那么我们现在如何将索引利用起来呢？估计你很快就猜到了，就是跟VAO和VBO类似，需要绑定它\nunsigned int EBO;glGenBuffers(1, &amp;EBO); // create a EBO glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); //绑定 EBOglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); //复制 EBO 到缓冲\n绑定结束了，现在就剩下绘制了\n直接绘制就可以了吗？\n显然不是！！！\n我们需要改成使用\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);\n完整代码\nhello_square.h\n#ifndef OPENGL_ENVIRONMENT_TEST_HELLO_SQUARE_H#define OPENGL_ENVIRONMENT_TEST_HELLO_SQUARE_H#include &lt;string&gt;// GLAD is used to manage Open GL function pointers#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#define WINDOW_WIDTH 600#define WINDOW_HEIGHT 600#define WINDOW_TITLE &quot;lucas-opengl&quot;using namespace std;class hello_square &#123;public:    static int create_a_square();private:    static void draw_frame(unsigned int shaderProgram, unsigned int VAO_handle);    static void processInput(GLFWwindow *window);    static void framebuffer_size_callback(GLFWwindow *window, int width, int height);    static void init_glfw();    static GLFWwindow *create_glfw_window();    static void check_shader(unsigned int shader, const string &amp;type);    static void check_program(unsigned int shaderProgram);&#125;;\nhello_square.cpp\n#include &quot;hello_square.h&quot;#include &lt;iostream&gt;int hello_square::create_a_square() &#123;    init_glfw();    GLFWwindow *window = create_glfw_window();    if (window == nullptr) &#123;        return -1;    &#125;    // Set the context of our window to the main context of the current thread    glfwMakeContextCurrent(window);    // glfwGetProcAddress is the function GLFW get Open GL pointer    // check if GLAD can use the glfw function in order to initialize GLAD    if (!gladLoadGLLoader((GLADloadproc) glfwGetProcAddress)) &#123;        std::cout &lt;&lt; &quot;failed to initialize GLAD&quot; &lt;&lt; std::endl;        glfwTerminate();        return -1;    &#125;    // 注册 framebuffer_size_callback    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);    // ********************* 编译着色器 ****************************    const char *vertexShaderSource = &quot;#version 330 core\\n&quot;                                     &quot;layout (location = 0) in vec3 aPos;\\n&quot;                                     &quot;void main()&#123;\\n&quot;                                     &quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n&quot;                                     &quot;&#125;\\0&quot;;    const char *fragmentShaderSource = &quot;#version 330 core\\n&quot;                                       &quot;out vec4 FragColor;\\n&quot;                                       &quot;void main()&#123;\\n&quot;                                       &quot;    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n&quot;                                       &quot;&#125;\\0&quot;;    // vertex shader    // create a shader    unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);    glShaderSource(vertexShader, 1, &amp;vertexShaderSource, nullptr);    glCompileShader(vertexShader);    // check if the vertexShader compiled successfully    check_shader(vertexShader, &quot;GL_VERTEX_SHADER&quot;);    // fragment shader    // create a shader    unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);    glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);    glCompileShader(fragmentShader);    // check if the fragmentShader compiled successfully    check_shader(fragmentShader, &quot;GL_FRAGMENT_SHADER&quot;);    // ********************* 链接着色器，编译 program ****************************    unsigned int shaderProgram = glCreateProgram();    glAttachShader(shaderProgram, vertexShader);    glAttachShader(shaderProgram, fragmentShader);    glLinkProgram(shaderProgram);    // check if the program compiled successfully    check_program(shaderProgram);    // delete shader    glDeleteShader(vertexShader);    glDeleteShader(fragmentShader);    float vertices[] = &#123;            0.5f, 0.5f, 0.0f,  // top right            0.5f, -0.5f, 0.0f,  // bottom right            -0.5f, -0.5f, 0.0f,  // bottom left            -0.5f, 0.5f, 0.0f   // top left    &#125;;    unsigned int indices[] = &#123;  // note that we start from 0!            0, 1, 3,  // first Triangle            1, 2, 3   // second Triangle    &#125;;    unsigned int VAO_handle, VBO_handle, EBO_handle;    glGenVertexArrays(1, &amp;VAO_handle);    glGenBuffers(1, &amp;VBO_handle);    glGenBuffers(1, &amp;EBO_handle);    // ********************************************************************************    // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).    // 1.绑定 VAO_handle    glBindVertexArray(VAO_handle);    // 2.绑定 VBO_handle    glBindBuffer(GL_ARRAY_BUFFER, VBO_handle);    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);    // 3.绑定 EBO_handle    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO_handle);    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);    // 4.设置 Attribute    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void *) nullptr);    glEnableVertexAttribArray(0);    // note that this is allowed, the call to glVertexAttribPointer registered VBO_handle as the vertex attribute&#x27;s bound vertex buffer object so afterward we can safely unbind    glBindBuffer(GL_ARRAY_BUFFER, 0);    // You can unbind the VAO_handle afterward so other VAO_handle calls won&#x27;t accidentally modify this VAO_handle, but this rarely happens. Modifying other    // VAOs requires a call to glBindVertexArray , so we generally don&#x27;t unbind VAOs (nor VBOs) when it&#x27;s not directly necessary.    glBindVertexArray(0);    // ********************************************************************************    while (!glfwWindowShouldClose(window)) &#123;        processInput(window);        draw_frame(shaderProgram, VAO_handle);        // 交换 Buffer        glfwSwapBuffers(window);        // glfwPollEvents函数检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）        glfwPollEvents();    &#125;    // 释放/删除之前的分配的所有资源    glfwTerminate();    return 0;&#125;/** * initialize glfw */void hello_square::init_glfw() &#123;    // glfw initialize    glfwInit();    // Use OpenGL 3.3 version    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);    // GLFW use core profile    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);    // MacOS specific code    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);&#125;/** * create_glfw_window and check */GLFWwindow *hello_square::create_glfw_window() &#123;    // Create a windows    GLFWwindow *window = glfwCreateWindow(WINDOW_WIDTH, WINDOW_HEIGHT, WINDOW_TITLE, nullptr, nullptr);    // Check if the window is created successfully    if (window == nullptr) &#123;        std::cout &lt;&lt; &quot;failed to create GLFW window&quot; &lt;&lt; std::endl;        glfwTerminate();    &#125;    return window;&#125;/** * 回调函数，在窗口大小调整的时候，调整 ViewPort 的大小 * @param window * @param width * @param height */void hello_square::framebuffer_size_callback(GLFWwindow *window, int width, int height) &#123;    glViewport(0, 0, width, height);&#125;/** * 检测是否有按键输入 * 如果按下了 esc 就设置当前窗口应该退出 * @param window */void hello_square::processInput(GLFWwindow *window) &#123;    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;        glfwSetWindowShouldClose(window, true);    &#125;&#125;void hello_square::check_shader(unsigned int shader, const string &amp;type) &#123;    int success;    char infoLog[512];    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;success);    if (!success) &#123;        glGetShaderInfoLog(shader, 512, NULL, infoLog);        std::cout &lt;&lt; &quot;ERROR::SHADER:: &quot; &lt;&lt; type &lt;&lt; &quot; ::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;    &#125;&#125;void hello_square::check_program(unsigned int shaderProgram) &#123;    int success;    char infoLog[512];    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);    if (!success) &#123;        glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);        cout &lt;&lt; &quot;ERROR::shaderProgram::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; endl;    &#125;&#125;void hello_square::draw_frame(unsigned int shaderProgram, unsigned int VAO_handle) &#123;    // 设置调用 clear 所使用的颜色    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);    // 清空屏幕    glClear(GL_COLOR_BUFFER_BIT);    // draw our first triangle    glUseProgram(shaderProgram);    // seeing as we only have a single VAO_handle there&#x27;s no need to bind it every time, but we&#x27;ll do so to keep things a bit more organized    glBindVertexArray(VAO_handle);    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);    glBindVertexArray(0);&#125;\n","tags":["OpenGL"]},{"title":"OpenGL 知识点、小问题（持续更新）","url":"/2023/09/04/OpenGL-%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%B0%8F%E9%97%AE%E9%A2%98/","content":"世界坐标\n局部空间（vec local）\n对于一个物体，建立它本身的时候，他自己会设置一个坐标系，但这个坐标只在建立它的那个空间可以使用，称为局部坐标，比如你在 Blender 里面构建一个立方体，将这个模型导入其他软件之后，就不会再使用到 Blender 里面的坐标系了，这个在 Blender 里面的坐标就是局部坐标（你可以理解这个局部坐标的是物体的元数据）\n\n也就是你在刚开始学 OpenGL 里，一开始的顶点坐标，都是局部坐标\n世界空间\n我们们需要一个世界坐标，让不同物体显示在不同的位置，这需要 模型矩阵（Model Matrix）来实现，模型矩阵存储着对于当前物体的变换（旋转、缩放）。\n大概就是这样 Mmodel⋅VlocalM_{model}\\cdot V_{local}Mmodel​⋅Vlocal​\n观察空间\n又叫摄像机空间，或者视觉空间。\n到现在，我们已经将物体放到了世界坐标系的不同位置，并且进行了变换，但是如果将这些物体呈现在屏幕上，我们需要选一个角度给我们搭的景拍一张照片，这就需要观察空间，又叫摄像机空间。\n就像这样 Mview⋅Mmodel⋅VlocalM_{view}\\cdot M_{model}\\cdot V_{local}Mview​⋅Mmodel​⋅Vlocal​\n裁剪空间\n裁剪空间会稍微抽象一点，用投影矩阵来实现，它的作用是将呈现在我们屏幕上的坐标进行裁剪。\n例如：每个维度上 (−1000,1000)(-1000,1000)(−1000,1000) 。投影矩阵会将这个指定范围坐标变换为标准化坐标的范围 (−1,1)(-1,1)(−1,1) 。(1250,700,500)(1250,700,500)(1250,700,500) 就会被裁剪掉，因为 xxx 坐标已经超过了范围。\n那么具体该如何裁剪呢？\n正射投影\n这个其实很常见，我们中学学的数学几何，基本用的都是这种方式\n\n这种方式，每条边与之对边都是平行且相等的\n透视投影\n透视投影是绘画中用的很多的技巧，比如：\n\n\n","tags":["OpenGL"]},{"title":"N1 Openwrt 相关问题（持续更新）","url":"/2023/05/29/N1-Openwrt-Alist-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","content":"前提\n\n固件 flippy-82+o 基于 OpenWrt R23.04.15\nN1 盒子（家境贫寒）\n\n问题列表\nAlist 相关\n1. 如何更新\n\n\n下载好 ipk 软件包\n例如这个openwrt-22.03-aarch64_cortex-a53.tar.gz\n\n\n解压\n\n\n\n卸载原来的 alist\n\n卸载一个就行, 其他的会跟着卸载的, 不放心可以卸载完自己检查一下\n\n\n把文件放进去, 怎么放都行, 我直接用的 sftp\n\n\n\n\n进 ssh 这个肯定都会\nssh root@192.168.31.4ip 改为你的路由器 ip\n\n\n然后一个个安装, 一定要先安装 alist, 因为其他两个是依赖 alist 的\n就像这样\nopkg install /temp/alist_3.18.0-2_aarch64_cortex-a53.ipkopkg install /temp/luci-app-alist_1.0.8_all.ipkopkg install /temp/luci-i18n-alist-zh-cn_git-23.104.20606-8a14151_all.ipk\n\n\n这样就算装好了, 此时应该就看到 Alist 更新了, 看不到就重启一下\n\n\n","tags":["Openwrt","N1","Alist"]},{"title":"OpenGL 容易犯的错误（持续更新）","url":"/2023/09/04/OpenGL-%E5%AE%B9%E6%98%93%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF/","content":"","tags":["OpenGL"]},{"title":"OpenGL 四元数","url":"/2023/08/17/OpenGL-%E5%9B%9B%E5%85%83%E6%95%B0/","content":"万向节死锁\n关键点\n理解万向节死锁的关键就在于理解为什么会前面旋转会带动后面坐标轴一起进行旋转\n欧拉角\n我们设置三个旋转方向, 分别为绕 x 轴, 绕 y 轴, 绕 z 轴 旋转, 这就是欧拉角, 以数学家欧拉的名字命名\n请注意, 我很还必须指定先绕着谁旋转, 因为旋转的先后次序不一样, 最终结果也就不一样\n写成矩阵就是这个样子： Rz⋅Ry⋅Rx⋅VR_z\\cdot R_y\\cdot R_x\\cdot VRz​⋅Ry​⋅Rx​⋅V\n进行欧拉角变换的时候, 要始终保持这个变换顺序, 不可随意删除改变任何矩阵\n举个例子\n通常举的例子是：\n我们以飞机的机头方向向量代表飞机本身\n我们定义旋转顺序为 x, y, z\n我们先让飞机绕 y 轴旋转 90° , 此时会带动 z 轴一起旋转, z 轴与 x 轴重合, 导致旋转 z 轴和 x 轴效果一样（蓝色是 zzz 轴, 红色是 xxx   轴）\n\n我们用矩阵把他表示出来\nRy=[cos90°0sin90°010−sin90°0cos90°]=[001010−100]    R_y =\n    \\begin{bmatrix}\n    cos90° &amp; 0 &amp; sin90° \\\\\n    0 &amp; 1 &amp; 0 \\\\\n    -sin90° &amp; 0 &amp; cos90°\n    \\end{bmatrix}\n    =\n    \\begin{bmatrix}\n    0 &amp; 0 &amp; 1 \\\\\n    0 &amp; 1 &amp; 0 \\\\\n    -1 &amp; 0 &amp; 0\n    \\end{bmatrix}\nRy​=⎣⎢⎡​cos90°0−sin90°​010​sin90°0cos90°​⎦⎥⎤​=⎣⎢⎡​00−1​010​100​⎦⎥⎤​\n然后我们再定义一个绕 x 轴和绕 z 轴旋转 的矩阵\nRx=[1000cosθ−sinθ0sinθcosθ]    R_x =\n    \\begin{bmatrix}\n    1 &amp; 0 &amp; 0 \\\\\n    0 &amp; cos\\theta &amp; -sin\\theta \\\\\n    0 &amp; sin\\theta &amp; cos\\theta\n    \\end{bmatrix}\nRx​=⎣⎢⎡​100​0cosθsinθ​0−sinθcosθ​⎦⎥⎤​\nRz=[cosθ−sinθ0sinθcosθ0001]    R_z =\n    \\begin{bmatrix}\n    cos\\theta &amp; -sin\\theta &amp; 0 \\\\\n    sin\\theta &amp; cos\\theta &amp; 0 \\\\\n    0 &amp; 0 &amp; 1\n    \\end{bmatrix}\nRz​=⎣⎢⎡​cosθsinθ0​−sinθcosθ0​001​⎦⎥⎤​\n我们计算\nRx⋅Ry=[001sinθcosθ0−cosθsinθ0]    R_x\\cdot R_y =\n    \\begin{bmatrix} 0 &amp; 0 &amp; 1\\\\\n    sin\\theta &amp; cos\\theta &amp; 0\\\\\n    -cos\\theta &amp; sin\\theta &amp; 0\n    \\end{bmatrix}\nRx​⋅Ry​=⎣⎢⎡​0sinθ−cosθ​0cosθsinθ​100​⎦⎥⎤​\nRz⋅Ry=[0−sinθcosθ0cosθsinθ−100]    R_z\\cdot R_y =\n    \\begin{bmatrix} 0 &amp; -sin\\theta &amp; cos\\theta \\\\\n    0 &amp; cos\\theta &amp; sin\\theta \\\\\n    -1 &amp; 0 &amp; 0\n    \\end{bmatrix}\nRz​⋅Ry​=⎣⎢⎡​00−1​−sinθcosθ0​cosθsinθ0​⎦⎥⎤​\n结果发现并没有出现我们提到的死锁问题……\n这是为什么？\n因为你改变了矩阵乘法的顺序, 所以所谓的先转什么再转什么, 指的真的就只是矩阵变化的时间先后, 并不是相乘的顺序先后\n所以我们应该直接这样写 Rz⋅Ry⋅Rx⋅V{\\color{red}R_z}\\cdot {\\color{blue}R_y}\\cdot {\\color{green}R_x}\\cdot VRz​⋅Ry​⋅Rx​⋅V , 先修改 Ry{\\color{blue}R_y}Ry​ , 再修改 Rz{\\color{red}R_z}Rz​ 和 Rx{\\color{green}R_x}Rx​ 查看效果\n\\begin{split}\n    &amp; \\begin{bmatrix}\n    1 &amp; 0 &amp; 0 \\\\\n    0 &amp; cos\\alpha &amp; -sin\\alpha \\\\\n    0 &amp; sin\\alpha &amp; cos\\alpha\n    \\end{bmatrix}\n    \\cdot\n    \\begin{bmatrix}\n    0 &amp; 0 &amp; 1 \\\\\n    0 &amp; 1 &amp; 0 \\\\\n    -1 &amp; 0 &amp; 0\n    \\end{bmatrix}\n    \\cdot\n    \\begin{bmatrix}\n    cos\\beta &amp; -sin\\beta &amp; 0 \\\\\n    sin\\beta &amp; cos\\beta &amp; 0 \\\\\n    0 &amp; 0 &amp; 1\n    \\end{bmatrix}\\\\\n    \\\\\n    &amp; =\n    \\begin{bmatrix}\n    0 &amp; 0 &amp; 1\\\\\n    sin\\alpha cos\\beta+cos\\alpha sin\\beta &amp; cos\\alpha cos\\beta - sin\\alpha sin\\beta &amp; 0\\\\\n    -cos\\alpha cos\\beta + sin\\alpha sin\\beta &amp; sin\\alpha cos\\beta+cos\\alpha sin\\beta &amp; 0\n    \\end{bmatrix}\\\\\n    \\\\\n    &amp; =\n    \\begin{bmatrix}\n    0 &amp; 0 &amp; 1\\\\\n    sin(\\alpha+\\beta) &amp; cos(\\alpha+\\beta) &amp; 0\\\\\n    -cos(\\alpha+\\beta) &amp; sin(\\alpha+\\beta) &amp; 0\n    \\end{bmatrix}\n\\end{split}\n\n现在我们计算出来直接就是一个绕 x 轴旋转的矩阵\n\n这就是万向节死锁\n\n四元数\n视频\n推荐看看这个视频, 能更好地理解四元数 YouTube bilibili\n通过球极投影来分析四元数\n球极投影可以帮我们通过低维变换来分析高维的变换\n复数乘法的几何形式\n视频里介绍了一种动态的几何形式的乘法——是将第一个复数看做函数, 第二个看做函数的自变量\n观看视频 5:26 ~ 11:04 , 这部分介绍了复数乘法的几何意义\n\n为什么要这么拉伸旋转呢？\n因为复数相乘本身就是一种拉伸旋转\n我们先做出关于 zzz 的乘法的一般式： (2+3i)(a+bi)=(2a−3b)+(2b+3a)i(2+3i)(a+bi)=(2a-3b)+(2b+3a)i(2+3i)(a+bi)=(2a−3b)+(2b+3a)i\n然后再计算缩放比例： (2a−3b)2+(2b+3a)2a2+b2=13\\displaystyle \\frac{\\sqrt{(2a-3b)^2+(2b+3a)^2}}{\\sqrt{a^2+b^2}}=\\sqrt{13}a2+b2​(2a−3b)2+(2b+3a)2​​=13​ , 可以看到这个比例变换和 aaa ,  bbb 没有任何关系, 其实就等于 zzz 里面 实部2+虚部2\\sqrt{\\text{实部}^2+\\text{虚部}^2}实部2+虚部2​\n然后再计算旋转角度： cosθ=a⋅(2a−3b)+b⋅(2b+3a)(a2+b2)((2a−3b)2+(2b+3a)2)=21313\\displaystyle cos\\theta = \\frac{a\\cdot(2a-3b)+b\\cdot(2b+3a)}{\\sqrt{(a^2+b^2)((2a-3b)^2+(2b+3a)^2)}}=\\frac{2\\sqrt{13}}{13}cosθ=(a2+b2)((2a−3b)2+(2b+3a)2)​a⋅(2a−3b)+b⋅(2b+3a)​=13213​​ 也和 aaa ,  bbb 没有任何关系\n这就意味着, 这个平面上所有的点的缩放比例都是 13\\sqrt{13}13​ , 旋转角度的余弦值都是 21313\\displaystyle \\frac{2\\sqrt{13}}{13}13213​​\n而 (0,1)(0, 1)(0,1) 点会缩放到和 z 重合的位置, 因为 z⋅1=1z\\cdot 1 = 1z⋅1=1\n\n一维生物——小莱\n小莱只能理解一维图像, 那么我该如何让他理解一个二维的圆呢？\n观看视频 5:26 ~ 11:04 , 这部分介绍了二维单位圆用球极投影投射到一维, 并讨论单位圆的旋转对应一维点如何移动\n这一段其实比较好理解\n基于上面复数乘法的几何原理, 在二维平面的单位圆上, 每个点都对应一个函数, 并且这每个函数都只旋转, 不拉伸, 你可以像刚才一样, 将 (1,0)(1, 0)(1,0) 点在单位圆上拖拽, 就可以发现这个规律\n首先我们看这个映射模型, 用到的就是球极投影, 我们将单位圆投影到 iii 轴\n\n从 −1-1−1 点出发, 连接圆上每个点并延长与 y 轴相交。\n这样 y 轴每个点都是可以看做是圆上每个点的投影, 右侧的半圆被投影到圆内部, 也就是 −i-i−i 到 iii 之间, 而左侧半圆则被投影到外面。\n我们假定, 小莱只能看到 iii 轴, 所以 iii 和 −i-i−i 就是 二维空间和一维空间重合的点, 这是小莱可以直接看到的, 然而不在 iii 轴的点就只能通过投影来进行推测\n首先 1 点被投影到原点, −1-1−1   点则被投影到无穷远处\n22+22i\\displaystyle\\frac{\\sqrt{2}}{2}+\\frac{\\sqrt{2}}{2}i22​​+22​​i 被投影到 22i\\displaystyle\\frac{\\sqrt{2}}{2}i22​​i 点了吗？很显然没有, 而是在一个比 22i\\displaystyle \\frac{\\sqrt{2}}{2}i22​​i 点更靠近原点的位置, 就好想被缩小了, 的确是这样, 而且这种缩放还是有迹可循的\n\n观察上图, 相信看到这里你甚至能猜到这为什么叫投影了, −1-1−1 就好比是一个观察点, iii 轴就是投影面\n回到我们讨论的这个点, 他被缩小的比例就是 11+22\\displaystyle \\frac{1}{1+\\frac{\\sqrt{2}}{2}}1+22​​1​\n而且我们还可以计算出, 缩放比例就是 11+a\\displaystyle \\frac{1}{1+a}1+a1​ , 也就是说, aaa 这个实部决定着缩放比例, 也就是如果实部为 0 , 那么缩放比例则为 1 , 因为他完全落在了虚轴上\n回忆我们刚才学习过的复数乘法, 他是作用于整个二维坐标系所有的点, 所有的点, 都等比例缩放, 旋转相同的角度, 就像你的手在这个坐标轴搓碟一样\n现在我们取二维坐标系任意一点 a+bia+bia+bi , 计算 i⋅(a+bi)=−b+aii\\cdot (a+bi)=-b+aii⋅(a+bi)=−b+ai , 然后计算这两个点连线原点的夹角 cosθ=a⋅(−b)+a⋅b(a2+b2)(a2+b2)=0\\displaystyle cos\\theta=\\frac{a\\cdot(-b)+a\\cdot b}{\\sqrt{(a^2+b^2)(a^2+b^2)}}=0cosθ=(a2+b2)(a2+b2)​a⋅(−b)+a⋅b​=0 , 所以 θ=90°\\theta=90°θ=90° , 左乘 iii 就是旋转 90°\n这样 ppp 点的投影也会随着旋转改变, 这些投影点, 就是我们要展示给小莱的\n\n二维生物——菲利克斯\n同样的, 菲利克斯只能理解二维的图像, 我们该如何向他解释球体的旋转呢？\n首先我们又定义了一个 jjj 轴, 它垂直于实轴和 iii 轴, 并且为了方便, 我们旋转一下, 让 iii 和 jjj 位于水平方向\n\n类比将单位圆投影到直线上, 我么们从 −1-1−1 点出发, 将单位球上的点投影到平面上\n\n下半部分的球体被投影到了单位圆的外面, 上半部分的球体被投影到了单位圆的内部\n最终投影是这样的\n\n\n同样 111 会被投影到原点, −1-1−1 点呢, 则被投影到了无穷远处\n而这次这条赤道一样的圆就是三维空间和二维空间重合的地方\n同样, 球旋转, 投影出来的面也会旋转\n\n\n但不幸的是：无法给三维复数 w+xi+yjw+xi+yjw+xi+yj 定义一个完美的乘法\n因为它不满足反对称性, 因为相乘的时候, 无法避免地会出现 i⋅ji\\cdot ji⋅j\n在四元数中 i⋅j=ki\\cdot j=ki⋅j=k , kkk 是另一个维度, 而三维里无法处理这个 kkk , 这个 kkk 是一个四维坐标系的维度, 所以我们很难去解释 i⋅ji\\cdot ji⋅j 所以就没有乘法\n\n但我们可以计算比例, 缩放比例也是 11+w\\displaystyle \\frac{1}{1+w}1+w1​ , www 为实部, 意思是如果实部为 0, 则投影比例为 1, 因为实部为 0 说明了它完全落在虚平面上\n\n三维生物——你\n四元数的代数意义\n这下我们要开始使用四元数了, 回顾一下我们用的前两个数\n\n虚数： 3.14+159i3.14+159i3.14+159i\n不是真正数系的“三维复数”： 3.14+159i+535j3.14+159i+535j3.14+159i+535j\n四元数： 1+2i+3j+4k1+2i+3j+4k1+2i+3j+4k\n\n\n四元数的乘法就像我们这样, 代数看着有些复杂, 但是很简单, 就像这样\n\n就这这样, 应该可以看懂这个图的含义\n数学家哈密顿将不含有实部的四元数, 定义为向量,\n我们可以使用向量的乘法来表达四元数的计算方法, 这样更加简洁优雅\n\n\n向量乘法\n点乘 (x1,y1,z1)⋅(x2,y2,z2)=x1x2+y1y2+z1z2(x_1, y_1, z_1)\\cdot(x_2, y_2, z_2)=x_1x_2+y_1y_2+z_1z_2(x1​,y1​,z1​)⋅(x2​,y2​,z2​)=x1​x2​+y1​y2​+z1​z2​\n叉乘 (x1,y1,z1)×(x2,y2,z2)=(x1i+y1j+z1k)(x2i+y2j+z2k)=(y1z2−z1y2k)i+(z1x2−x1z2)j+(x1y2+y1x2)k(x_1, y_1, z_1)\\times (x_2, y_2, z_2) = (x_1i+y_1j+z_1k)(x_2i+y_2j+z_2k) = (y_1z_2-z_1y_2k)i+(z_1x_2-x_1z_2)j+(x_1y_2+y_1x_2)k(x1​,y1​,z1​)×(x2​,y2​,z2​)=(x1​i+y1​j+z1​k)(x2​i+y2​j+z2​k)=(y1​z2​−z1​y2​k)i+(z1​x2​−x1​z2​)j+(x1​y2​+y1​x2​)k\n\n四元数的几何意义\n投影后的变换\n相对于虚数点到原点的距离 ∣∣a+bi∣∣=a2+b2||a+bi||=\\sqrt{a^2+b^2}∣∣a+bi∣∣=a2+b2​ , 同样四元数类似 ∣∣w+ai+bj+ck∣∣=w2+a2+b2+c2||w+ai+bj+ck||=\\sqrt{w^2+a^2+b^2+c^2}∣∣w+ai+bj+ck∣∣=w2+a2+b2+c2​\n并且, 类比 z1⋅z2z_1\\cdot z_2z1​⋅z2​ 中把 z1z_1z1​ 看做函数, q1⋅q2q_1\\cdot q_2q1​⋅q2​ 中, 也把 q1q_1q1​ 看做函数。\nz1z_1z1​ 的作用是拉伸旋转 z2z_2z2​ , 同样 q1q_1q1​ 的作用也是拉伸旋转 q2q_2q2​  , 但是旋转是 4 维的旋转\n\nps：视频里有一处错误\n\n\n理解什么是 4 维的旋转, 就需要我们从低维来观察, 也就是通过三维世界的变换, 推测四维世界的变换\n四维的坐标系是这样的, 他有四个轴, 这四个轴相互垂直, 但这样的坐标系我们画不出来, 所以只能将 iii轴 jjj轴 kkk轴 画出来, 并想象还有一条实轴垂直于这三条轴, 为什么这样画, 因为 iii轴 jjj轴 kkk轴 所构成的坐标系, 都是一个四维物体的投影, 就像前面三维投影到二维, 二维投影到一维一样。\n\n我们将一个单位四维超球投影到三维世界, 这个单位四维超球满足的条件就是 w2+a2+b2+c2=1\\sqrt{w^2+a^2+b^2+c^2}=1w2+a2+b2+c2​=1 , 也就是点距离原点都是 1\n类比于二维投影, 有一维的两点重合, 三维投影有二维的一个圆重合, 四维投影有三维的一整个球面重合\n\n所以, 我们在三维空间里看到的单位球, 代表着四维超球投影到我们空间中不变的部分\n也正如三维投影到二维, 那个赤道代表着三维实部为 0 的部分, 这个三维球面代表着四维空间中实部为 0 的部分\n为什么呢？可能你也发现了, 我们一直在做的就是将所有轴的点, 都投影到虚轴上\n并且, 只要看实部的正负就可以看出来他会投影到哪个位置, 对于二维投影, 实部为正, 就投影到 (−1,1)(-1, 1)(−1,1) , 为负, 就投影到 (−∞,−1)∪(1,+∞)(-\\infty, -1)\\cup(1, +\\infty)(−∞,−1)∪(1,+∞) ；对于三维投影, 实部为正, 就投影到 i2+j2&lt;1i^2+j^2&lt;1i2+j2&lt;1 , 实部为负, 就投影到 i2+j2&gt;1i^2+j^2&gt;1i2+j2&gt;1 ；对于四维投影呢？二维投影可以看成, i2&lt;0i^2&lt;0i2&lt;0 和 i2&gt;0i^2&gt;0i2&gt;0 , 所以四维投影自然就是——实部为正, 就投影到 i2+j2+k2&lt;1i^2+j^2+k^2&lt;1i2+j2+k2&lt;1 也就是三维单位球内部, 实部为负, 就投影到 i2+j2+k2&gt;1i^2+j^2+k^2&gt;1i2+j2+k2&gt;1 也就是三维单位球外部\n对于 1 点（意思是 iii, jjj, kkk 的系数都是 0）, 会投影到原点的位置, 而 −1-1−1 会被投影到无限远的地方\n\n注意：虽然看着每个点的投影距离原点的距离有所不同, 但其实他是在一个单位超四维球体上, 所以每个点都距原点相同的距离, 就像二维平面上的圆被投影到虚轴上, 三维球被投影到虚平面上是一样\n这种现象, 其实是投影的拉伸效果导致的\n这时, 你可能会有疑问, 三维空间中的原点, 和四维空间的是同一个点吗？\n毕竟二维投影里, 三维投影里, 看起来他们都是同一个原点。\n但答案是否定的, 不仅如此, 二维投影和三维投影里的原点其实也不是同一个, 因为我们已经把所有的高维的点全部投影到低维空间了, 并且是全部占满了所有的点, 并且之前我们曾提到过 −1-1−1 点被投影到了原点。那么这个原点呢？没错他压根不在单位（圆, 球, 四维超球）上。所以它就没被投影。我们在低维看到的原点其实是高维空间的 −1-1−1 点\n\n从一维到二维, 我们可以计算出缩放比例和旋转角度, 比例为 11+w\\displaystyle \\frac{1}{1+w}1+w1​\n从二维到三维, 我们同样可以计算缩放比例 11+w\\displaystyle \\frac{1}{1+w}1+w1​ , 但旋转角度难以计算, 因为我们需要引入 ijijij 的计算结果, 这其实是四元数的子集\n而从三维到四维, 我们可以推出, 同样 实部 www 决定了缩放比例, 比例为 11+w\\displaystyle \\frac{1}{1+w}1+w1​  , 同样如果实部为 0 , 则说明它完全在虚空间中, 投影的比例为 1\n\n就像二维单位圆投影到一维虚轴上, 我们在这里看到 每个直线 的时候, 就明白这其实代表一个圆, 一个经过 −1-1−1 点的圆\n\n正如三维球体投影到二维平面, 每个平面就是一个三维球体投影出来的, 并且这个球经过 −1-1−1 点\n四元数乘法对应的变换\n我们先用 iii 左乘一个四元数, 也就是四维空间的一个点\ni⋅(w+ai+bj+ck)=−a+wi−cj+bk    i\\cdot (w+ai+bj+ck) = -a+wi-cj+bk\ni⋅(w+ai+bj+ck)=−a+wi−cj+bk\n我们观察这个点的变换, 这是一个相互垂直的两个圆的同时旋转, 一个是 实轴, i 轴组成的平面上的单位圆, 这个圆被投影成了三维平面中的 i 轴, 而另一个是 j 轴 k 轴组成平面的单位圆\n第一个圆呈现出来的是在 i 轴上移动的点, 第二个圆则是能看见的旋转\n\n为什么呢？\n我们分开来看, 首先是前两个数, 由 w+aiw+aiw+ai 变成了 −a+wi-a+wi−a+wi , 这和我们在二维投影时候的计算规律一致\n再看后两个数, 由 bj+ckbj+ckbj+ck 变成了 −cj+bk-cj+bk−cj+bk 也是旋转 90 度, 只不过前两个数由于实轴被投影到了虚轴上, 所以我们看到的是一条线, 而 j,kj , kj,k 没有被投影, 所以看到的是实实在在的一个圆\n\nps：\n视频里说, 这两个圆相互垂直, 但是同心同半径而且完全不相交, 这也是因为一个是投影, 另一个是实实在在的圆\n\n你可以通过, 右手定则来判断这两个圆的关系\n\n直线延大拇指方向移动, 而圆顺四指的方向旋转\n\n\n如果你有一个点, 在 kkk 点, 他会出现什么现象?\n首先, 它的实部为 0, 系数的平和为 1 , 则投影在三维球体的球面上\n计算 ik=−jik=-jik=−j , 还在 这个单位圆上, 所以 kkk 点左乘 iii , 结果就是会旋转 90°\n\n\n如果这个点在 22i+22k\\displaystyle \\frac{\\sqrt{2}}{2}i+\\frac{\\sqrt{2}}{2}k22​​i+22​​k , 会出现什么现象？\n首先, 它的实部为0, 系数的平方和等于 1 , 则投影在三维球体的球面上\n计算 i⋅(22i+22k)=−22−22j\\displaystyle i\\cdot (\\frac{\\sqrt{2}}{2}i+\\frac{\\sqrt{2}}{2}k)=-\\frac{\\sqrt{2}}{2}-\\frac{\\sqrt{2}}{2}ji⋅(22​​i+22​​k)=−22​​−22​​j , 我们知道, 类比二维投影, −22−22j\\displaystyle -\\frac{\\sqrt{2}}{2}-\\frac{\\sqrt{2}}{2}j−22​​−22​​j 这个点, 就在图中绿色这个位置\n\n\n \n实部和 iii 决定了他会在投影上移动 11+33−0=3−32\\displaystyle \\frac{1}{1+\\frac{\\sqrt{3}}{3}}-0=\\frac{3-\\sqrt{3}}{2}1+33​​1​−0=23−3​​ （计算缩放比例)\n其实研究到这里就差不多了, 如果你还想验证其他的点的变化, 依照这种方式就可以了\n现在可以直接向你展示整个球的变化了，观看视频 26:02 ~ 28:42\n如果你知道了每个单位（i, j, k）对应的变换, 那么你就可以理解任意一个四元数对应的所有变换, 因为四元数满足分配律\n应用四元数\n感受四元数\n还是那个作者 3Blue1Brown-B站个人空间 3Blue1Brown_youtube\nbilibili链接 youtube链接\n这个视频里有一个网站, 里面有可以让你自己来手动操作四元数 https://eater.net/quaternions\n应用到三维旋转\n公式\n四元数中, 绕一个轴旋转 θ\\thetaθ 度数, 我们需要用一个单位向量定义这个轴 l=xi+yj+zkl=xi+yj+zkl=xi+yj+zk , 然后用角度设置它 cosθ2+sinθ2(xi+yj+zk)\\displaystyle cos\\frac{\\theta}{2}+sin\\frac{\\theta}{2}(xi+yj+zk)cos2θ​+sin2θ​(xi+yj+zk) , 然后, 我们定一个点, p=ai+bj+ckp=ai+bj+ckp=ai+bj+ck , 使用这个看起来像三明治一样的东西来计算\n\\begin{gather}\n    q\\cdot p\\cdot q^{-1}, (q^{-1}\\text{表示}q\\text{的共轭})\\\\\\\\\n    (w+xi+yj+zk)(ai+bj+ck)(w-xi-yj-zk)\n\\end{gather}\n\na1x+b1y+c1z=d1+e1a2x+b2y=d2a3x+b3y+c3z=d3\\begin{aligned}\na_1x+b_1y+c_1z &amp;=d_1+e_1 \\\\\na_2x+b_2y &amp;=d_2 \\\\\na_3x+b_3y+c_3z &amp;=d_3\\\\\n\\end{aligned}\na1​x+b1​y+c1​za2​x+b2​ya3​x+b3​y+c3​z​=d1​+e1​=d2​=d3​​\n\n为什么要用 θ2\\displaystyle \\frac{\\theta}{2}2θ​ ？为什么要乘两个四元数？\n假设只乘以一个四元数,\nqpqpqp  , q=cosβ+sinβ(xi+yj+zk)q=cos\\beta+sin\\beta(xi+yj+zk)q=cosβ+sinβ(xi+yj+zk)  相当于延 lll  进行拉伸, 并逆时针旋转 β\\betaβ  度\nq−1pq^{-1}pq−1p , q−1=cosβ−sinβ(xi+yj+zk)q^{-1}=cos\\beta-sin\\beta(xi+yj+zk)q−1=cosβ−sinβ(xi+yj+zk) 相当于延 −l-l−l 进行拉伸, 并顺时针旋转 β\\betaβ 度\npqpqpq  , q=cosβ+sinβ(xi+yj+zk)q=cos\\beta+sin\\beta(xi+yj+zk)q=cosβ+sinβ(xi+yj+zk)  相当于延 lll  进行拉伸, 并顺时针旋转 β\\betaβ  度\npq−1pq^{-1}pq−1 , q−1=cosβ−sinβ(xi+yj+zk)q^{-1}=cos\\beta-sin\\beta(xi+yj+zk)q−1=cosβ−sinβ(xi+yj+zk) 相当于延 −l-l−l 进行拉伸, 并逆时针旋转 β\\betaβ  度\n如果你能理解这些\n那么肯定就能理解 q⋅p⋅q−1q\\cdot p\\cdot q^{-1}q⋅p⋅q−1 , q=cosθ2+sinθ2(xi+yj+zk)\\displaystyle q=cos\\frac{\\theta}{2}+sin\\frac{\\theta}{2}(xi+yj+zk)q=cos2θ​+sin2θ​(xi+yj+zk) , 它相当于不拉伸, 并且逆时针旋转 2×θ2=θ\\displaystyle 2\\times \\frac{\\theta}{2}=\\theta2×2θ​=θ 度数\n\n","tags":["OpenGL"]},{"title":"OpenGL 矩阵（没写完）","url":"/2023/10/05/OpenGL-%E7%9F%A9%E9%98%B5/","content":"向量\n向量点乘（内积）\nA=[a11a12...a1na21a22...a2na31a22...a3n⋮⋮⋱⋮an1an2...ann],b=[b1b2b3⋮bn]    A = \\begin{bmatrix}\n    a_{11} &amp; a_{12} &amp; ... &amp; a_{1n}\\\\\n    a_{21} &amp; a_{22} &amp; ... &amp; a_{2n}\\\\\n    a_{31} &amp; a_{22} &amp; ... &amp; a_{3n}\\\\\n    \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\\n    a_{n1} &amp; a_{n2} &amp; ... &amp; a_{nn}\n    \\end{bmatrix} ,\n    b = \\begin{bmatrix}\n    b_{1}\\\\\n    b_{2}\\\\\n    b_{3}\\\\\n    \\vdots\\\\\n    b_{n}\n    \\end{bmatrix}\nA=⎣⎢⎢⎢⎢⎢⎢⎡​a11​a21​a31​⋮an1​​a12​a22​a22​⋮an2​​.........⋱...​a1n​a2n​a3n​⋮ann​​⎦⎥⎥⎥⎥⎥⎥⎤​,b=⎣⎢⎢⎢⎢⎢⎢⎡​b1​b2​b3​⋮bn​​⎦⎥⎥⎥⎥⎥⎥⎤​\n此方法可类比物理做功\n\n力 FFF 和位移 SSS 已给出，需要用 W=F⋅SW = F \\cdot SW=F⋅S 来表示做的功\n计算方法就是\nW=∣F∣∣S∣cosθW = |F||S|cosθ\nW=∣F∣∣S∣cosθ\n所以向量点乘（内积）就是向量模相乘再乘夹角余弦，也就是他的几何形式：\na⃗⋅b⃗=∣a⃗∣∣b⃗∣cosθ\\vec a\\cdot\\vec b = |\\vec a||\\vec b|cosθ\na⋅b=∣a∣∣b∣cosθ\n代数形式是：\na⃗⋅b⃗=∑i=1na1b1+a2b2+⋅⋅⋅+anbn\\vec a \\cdot \\vec b = \\sum_{i=1}^{n}a_1b_1+a_2b_2+\\cdot \\cdot \\cdot +a_nb_n\na⋅b=i=1∑n​a1​b1​+a2​b2​+⋅⋅⋅+an​bn​\n或者这个\na⃗b⃗=a⃗⋅b⃗T\\vec a \\vec b = \\vec a \\cdot {\\vec b}^{T}\nab=a⋅bT\n例如：\n[13−5][4−2−1]=[3]=3    \\begin{bmatrix}\n    1&amp;3&amp;-5\\end{bmatrix}\n    \\begin{bmatrix}\n    4\\\\\n    -2\\\\\n    -1\n    \\end{bmatrix}\n    =\n    \\begin{bmatrix}\n    3\n    \\end{bmatrix}\n    =3\n[1​3​−5​]⎣⎢⎡​4−2−1​⎦⎥⎤​=[3​]=3\n两个向量相乘变成了一个单数字矩阵\n向量叉乘（外积）\n此方法可以\n计算方法\na⃗×b⃗=∣a⃗∣∣b⃗∣sin⁡θ n⃗\\vec a\\times\\vec b = |\\vec a||\\vec b|\\sin{θ}\\ \\vec n\na×b=∣a∣∣b∣sinθ n\n$ \\vec n$ 指向右手坐标系大拇指位置，a⃗\\vec aa 为食指，b⃗\\vec bb  为中指\n为什么用右手，因为我们用的就是右手坐标系，又称笛卡尔坐标系\n\n\n注意：这个坐标轴可以随意旋转，只要不做镜像反转就行\n坐标形式\n\nA⃗=(Ax,Ay,Az)    \\vec A = (A_x,A_y,A_z)\nA=(Ax​,Ay​,Az​)\nB⃗=(Bx,By,Bz)    \\vec B = (B_x,B_y,B_z)\nB=(Bx​,By​,Bz​)\n[ijkAxAyAzBxByBz]=[AyAzByBz]i+[AxAzBxBz]j+[AxAyBxBy]k    \\begin{bmatrix}\n    i &amp; j &amp; k \\\\\n    A_x &amp; A_y &amp; A_z\\\\\n    B_x &amp; B_y &amp; B_z\n    \\end{bmatrix}\n    = \\begin{bmatrix}\n    A_y &amp; A_z\\\\\n    B_y &amp; B_z\n    \\end{bmatrix}i\n    +\n    \\begin{bmatrix}\n    A_x &amp; A_z\\\\\n    B_x &amp; B_z\n    \\end{bmatrix}j\n    +\n    \\begin{bmatrix}\n    A_x &amp; A_y\\\\\n    B_x &amp; B_y\n    \\end{bmatrix}k\n⎣⎢⎡​iAx​Bx​​jAy​By​​kAz​Bz​​⎦⎥⎤​=[Ay​By​​Az​Bz​​]i+[Ax​Bx​​Az​Bz​​]j+[Ax​Bx​​Ay​By​​]k\nA⃗×B⃗=(AyBz−AzBy)i+(AxBz−AzBx)j+(AxBy−AyBx)k    \\vec A \\times \\vec B = (A_y B_z-A_z B_y)i+(A_x B_z-A_z B_x)j+(A_x B_y-A_y B_x)k\nA×B=(Ay​Bz​−Az​By​)i+(Ax​Bz​−Az​Bx​)j+(Ax​By​−Ay​Bx​)k\n系数是这么算的（子行列式）\n\n\n如果你对这种计算方式感到疑惑，不用意外，我也曾感到意外，因为叉乘仿佛是一个代数和集合杂糅在一起的计算，但他们融合的有非常生硬，很反直觉……吗？其实不是，我们接着看\n为什么叉乘的等号前面是括号坐标形式的向量，而等号右边是 i、j、ki、j、ki、j、k ？你注意到这个了吗？\n我们把等号前面也改成  i、j、ki、j、ki、j、k 的形式\n\\begin{align}\n&amp; (A_xi+A_yj+A_zk)(B_xi+B_yj+B_zk) \\\\\n= &amp; A_xB_xi^2+A_yB_yj^2+A_zB_zk^2 \\\\\n&amp; +A_xB_yij+A_xB_zki \\\\\n&amp; +A_yB_xji+A_yB_zjk \\\\\n&amp; +A_zB_xki+A_zB_yjk\n\\end{align}\n\n没错，我们用的完全就是代数乘法\n为什么我将 ij、ji、jk、kj、ik、kiij、ji、jk、kj、ik、kiij、ji、jk、kj、ik、ki 分开，因为 i、j、ki、j、ki、j、k  是每个轴的单位向量，他们相乘需要用到叉乘\n通过叉乘计算你就能得到\n\\begin{cases}\n\\begin{align}\n&amp; ij=-ji=k \\\\\n&amp; ki=-ik=j \\\\\n&amp; jk=-kj=i\n\\end{align}\n\\end{cases}\n\n没错同方向或者相反方向的向量相乘，就会失去方向\n我们继续合并完这个式子，得到如下\nAxBxi2−AyByj2−AzBzk2+(AyBz−AzBy)i+(AxBz−AzBx)j+(AxBy−AyBx)kA_xB_xi^2-A_yB_yj^2-A_zB_zk^2+(A_y B_z-A_z B_y)i+(A_x B_z-A_z B_x)j+(A_x B_y-A_y B_x)k\nAx​Bx​i2−Ay​By​j2−Az​Bz​k2+(Ay​Bz​−Az​By​)i+(Ax​Bz​−Az​Bx​)j+(Ax​By​−Ay​Bx​)k\n这里，相同方向的向量 sinθ=0sin\\theta=0sinθ=0 ，所以这里的 −AxBx−AyBy−AzBz=0-A_xB_x-A_yB_y-A_zB_z=0−Ax​Bx​−Ay​By​−Az​Bz​=0\n你可以学习一下四元数的计算，这能更好地帮助你理解向量叉乘 =&gt; 四元数的代数意义\n\n矩阵\n矩阵乘法\n\n\n数乘\n3×[abcdefghi]=[3a3b3c3d3e3f3g3h3i]    3\n    \\times\n    \\left[\n    \\begin{matrix}\n    a &amp; b &amp; c \\\\\n    d &amp; e &amp; f \\\\\n    g &amp; h &amp; i\n    \\end{matrix}\n    \\right]\n    =\n    \\left[\n    \\begin{matrix}\n    3a &amp; 3b &amp; 3c \\\\\n    3d &amp; 3e &amp; 3f \\\\\n    3g &amp; 3h &amp; 3i\n    \\end{matrix}\n    \\right]\n3×⎣⎢⎡​adg​beh​cfi​⎦⎥⎤​=⎣⎢⎡​3a3d3g​3b3e3h​3c3f3i​⎦⎥⎤​\n\n\n相乘\n[123456789]⋅[abcdefghi]=[a+2d+3gb+2e+3hc+2f+3i4a+5d+6g4b+5e+6h4c+5f+6i7a+8d+9g7b+8e+9h7c+8f+9i]    \\left[\n    \\begin{matrix}\n    1 &amp; 2 &amp; 3 \\\\\n    4 &amp; 5 &amp; 6 \\\\\n    7 &amp; 8 &amp; 9\n    \\end{matrix}\n    \\right]\n    \\cdot\n    \\left[\n    \\begin{matrix}\n    a &amp; b &amp; c \\\\\n    d &amp; e &amp; f \\\\\n    g &amp; h &amp; i\n    \\end{matrix}\n    \\right]\n    =\n    \\left[\n    \\begin{matrix}\n    a+2d+3g &amp; b+2e+3h &amp; c+2f+3i \\\\\n    4a+5d+6g &amp; 4b+5e+6h &amp; 4c+5f+6i \\\\\n    7a+8d+9g &amp; 7b+8e+9h &amp; 7c+8f+9i\n    \\end{matrix}\n    \\right]\n⎣⎢⎡​147​258​369​⎦⎥⎤​⋅⎣⎢⎡​adg​beh​cfi​⎦⎥⎤​=⎣⎢⎡​a+2d+3g4a+5d+6g7a+8d+9g​b+2e+3h4b+5e+6h7b+8e+9h​c+2f+3i4c+5f+6i7c+8f+9i​⎦⎥⎤​\n[123]⋅[abdegh]=[a+2d+3gb+2e+3h]    \\left[\n    \\begin{matrix}\n    1 &amp; 2 &amp; 3 \\\\\n    \\end{matrix}\n    \\right]\n    \\cdot\n    \\left[\n    \\begin{matrix}\n    a &amp; b \\\\\n    d &amp; e \\\\\n    g &amp; h\n    \\end{matrix}\n    \\right]\n    =\n    \\left[\n    \\begin{matrix}\n    a+2d+3g &amp; b+2e+3h\n    \\end{matrix}\n    \\right]\n[1​2​3​]⋅⎣⎢⎡​adg​beh​⎦⎥⎤​=[a+2d+3g​b+2e+3h​]\nAm×n⋅Bn×h=Cm×hA_{m \\times n}\\cdot B_{n \\times h} = C_{m \\times h}\nAm×n​⋅Bn×h​=Cm×h​\n前面的行乘以后面的列\n也就是，第一个矩阵的行数决定了最终矩阵的行数，第二个矩阵的列数决定了最终矩阵的列数\n并且，第一个矩阵一行有几个元素，第二个矩阵一列就得有几个元素，这样才能进行运算\n\n\n矩阵变换\n矩阵变换一般指 要变换的向量或矩阵，左乘变换矩阵，生产成最终变换好的矩阵的过程\n左乘和右乘\n假设有个矩阵 A ，左乘 A 就是将 A 放到乘号左边，右乘就是将 A 放到乘号右边\n[S10000S20000S300001]⋅[xyzw]=[S1⋅xS2⋅yS3⋅z1⋅w]    \\begin{bmatrix}\n    \\color{red}{S_1} &amp; \\color{red}0 &amp; \\color{red}0 &amp; \\color{red}0 \\\\\n    \\color{green}0 &amp; \\color{green}{S_2} &amp; \\color{green}0 &amp; \\color{green}0 \\\\\n    \\color{blue}0 &amp; \\color{blue}0 &amp; \\color{blue}{S_3} &amp; \\color{blue}0    \\\\\n    \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}1\n    \\end{bmatrix}\n    \\cdot\n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    z \\\\\n    w\n    \\end{bmatrix}\n    =\n    \\begin{bmatrix}\n    \\color{red}{S_1} \\cdot x\\\\\n    \\color{green}{S_2} \\cdot y \\\\\n    \\color{blue}{S_3} \\cdot z \\\\\n    \\color{purple}1 \\cdot w\n    \\end{bmatrix}\n⎣⎢⎢⎢⎡​S1​000​0S2​00​00S3​0​0001​⎦⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎡​xyzw​⎦⎥⎥⎥⎤​=⎣⎢⎢⎢⎡​S1​⋅xS2​⋅yS3​⋅z1⋅w​⎦⎥⎥⎥⎤​\n这就是 $ 向量 \\begin{bmatrix} x \\ y \\ z \\ w \\end{bmatrix} 左乘矩阵 \\begin{bmatrix} \\color{red}{S_1} &amp; \\color{red}0 &amp; \\color{red}0 &amp; \\color{red}0 \\ \\color{green}0 &amp; \\color{green}{S_2} &amp; \\color{green}0 &amp; \\color{green}0 \\ \\color{blue}0 &amp; \\color{blue}0 &amp; \\color{blue}{S_3} &amp; \\color{blue}0 \\ \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}1 \\end{bmatrix} $\n或者说 $ 矩阵 \\begin{bmatrix} \\color{red}{S_1} &amp; \\color{red}0 &amp; \\color{red}0 &amp; \\color{red}0 \\ \\color{green}0 &amp; \\color{green}{S_2} &amp; \\color{green}0 &amp; \\color{green}0 \\ \\color{blue}0 &amp; \\color{blue}0 &amp; \\color{blue}{S_3} &amp; \\color{blue}0 \\ \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}1 \\end{bmatrix} 右乘向量 \\begin{bmatrix} x \\ y \\ z \\ w \\end{bmatrix}$\n缩放\nlearnopengl-cn 中使用的矩阵都是 4×44\\times 44×4 的矩阵，也就是以下\n[S10000S20000S300001]⋅[xyzw]=[S1⋅xS2⋅yS3⋅z1⋅w]    \\begin{bmatrix}\n    \\color{red}{S_1} &amp; \\color{red}0 &amp; \\color{red}0 &amp; \\color{red}0 \\\\\n    \\color{green}0 &amp; \\color{green}{S_2} &amp; \\color{green}0 &amp; \\color{green}0 \\\\\n    \\color{blue}0 &amp; \\color{blue}0 &amp; \\color{blue}{S_3} &amp; \\color{blue}0 \\\\\n    \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}1\n    \\end{bmatrix}\n    \\cdot\n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    z \\\\\n    w\n    \\end{bmatrix}\n    =\n    \\begin{bmatrix}\n    \\color{red}{S_1} \\cdot x\\\\\n    \\color{green}{S_2} \\cdot y \\\\\n    \\color{blue}{S_3} \\cdot z \\\\\n    \\color{purple}1 \\cdot w\n    \\end{bmatrix}\n⎣⎢⎢⎢⎡​S1​000​0S2​00​00S3​0​0001​⎦⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎡​xyzw​⎦⎥⎥⎥⎤​=⎣⎢⎢⎢⎡​S1​⋅xS2​⋅yS3​⋅z1⋅w​⎦⎥⎥⎥⎤​\n这样除了对角线（左上到右下的对角线）其余都是零的矩阵，就叫缩放矩阵（对角线也可以有 0）\n[S1S2S3]\\begin{bmatrix} \\color{red}S_1 \\\\ \\color{green}S_2 \\\\ \\color{blue}S_3 \\end{bmatrix}⎣⎢⎡​S1​S2​S3​​⎦⎥⎤​   就是缩放向量\n上面我们定义了一个 4 维向量在 3d 空间里的缩放，将 xxx 方向放大（缩小）为原来的S1S_1S1​ 倍，将 yyy 方向放大（缩小）为原来的 S2S_2S2​ 倍，将 zzz 方向放大（缩小）为原来的 S3S_3S3​ 倍\n这个用 4 维向量表示 3 维向量的方式，涉及到一个概念叫 齐次坐标！！！建议不了解的可以学一下，后面我们或许还会提到\n但其实如果你使用 3×33\\times 33×3  的矩阵，道理也是一样的\n[S1000S2000S3]⋅[xyz]=[S1⋅xS2⋅yS3⋅z]    \\begin{bmatrix}\n    \\color{red}{S_1} &amp; \\color{red}0 &amp; \\color{red}0 \\\\\n    \\color{green}0 &amp; \\color{green}{S_2} &amp; \\color{green}0 \\\\\n    \\color{blue}0 &amp; \\color{blue}0 &amp; \\color{blue}{S_3} \\\\\n    \\end{bmatrix}\n    \\cdot\n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    z\n    \\end{bmatrix}\n    =\n    \\begin{bmatrix}\n    \\color{red}{S_1} \\cdot x\\\\\n    \\color{green}{S_2} \\cdot y \\\\\n    \\color{blue}{S_3} \\cdot z \\\\\n    \\end{bmatrix}\n⎣⎢⎡​S1​00​0S2​0​00S3​​⎦⎥⎤​⋅⎣⎢⎡​xyz​⎦⎥⎤​=⎣⎢⎡​S1​⋅xS2​⋅yS3​⋅z​⎦⎥⎤​\n后面我依旧使用 4 维矩阵和 4 维向量\n位移\n[100Tx010Ty001Tz0001]⋅[xyz1]=[x+Txy+Tyz+Tz1]    \\begin{bmatrix}  \n    \\color{red}1 &amp; \\color{red}0 &amp; \\color{red}0 &amp; \\color{red}{T_x} \\\\\n    \\color{green}0 &amp; \\color{green}1 &amp; \\color{green}0 &amp; \\color{green}{T_y} \\\\\n    \\color{blue}0 &amp; \\color{blue}0 &amp; \\color{blue}1 &amp; \\color{blue}{T_z} \\\\\n    \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}1\n    \\end{bmatrix}\n    \\cdot\n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    z \\\\\n    1\n    \\end{bmatrix}\n    =\n    \\begin{bmatrix}\n    x + \\color{red}{T_x} \\\\\n    y + \\color{green}{T_y} \\\\\n    z + \\color{blue}{T_z} \\\\\n    \\color{purple}1\n    \\end{bmatrix}\n⎣⎢⎢⎢⎡​1000​0100​0010​Tx​Ty​Tz​1​⎦⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎡​xyz1​⎦⎥⎥⎥⎤​=⎣⎢⎢⎢⎡​x+Tx​y+Ty​z+Tz​1​⎦⎥⎥⎥⎤​\n[TxTyTz]\\begin{bmatrix}  \\color{red}{T_x} \\\\ \\color{green}{T_y} \\\\ \\color{blue}{T_z} \\end{bmatrix}⎣⎢⎡​Tx​Ty​Tz​​⎦⎥⎤​ 就是位移向量\n位移（Translation）是在原始向量的基础上加上另一个向量从而获得一个在不同位置的新向量的过程，从而在位移向量基础上移动了原始向量。\n齐次坐标(Homogeneous Coordinates)\n一个向量 vec4(x,y,z,w) ，向量的w分量也叫齐次坐标。\nw 分量通常是 1.0。\n使用齐次坐标有几点好处：它允许我们在3D向量上进行位移（如果没有w分量我们是不能位移向量的）。\n如果一个向量的齐次坐标是 0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移。\n旋转\n首先，绕哪个轴旋转，哪个轴不动\n\n绕 x 轴旋转 θ\n\n[10000cos⁡θ−sin⁡θ00sin⁡θcos⁡θ00001]⋅[xyz1]=[xcos⁡θ⋅y−sin⁡θ⋅zsin⁡θ⋅y+cos⁡θ⋅z1]    \\begin{bmatrix}\n    \\color{red}1 &amp; \\color{red}0 &amp; \\color{red}0 &amp; \\color{red}0 \\\\\n    \\color{green}0 &amp; \\color{green}{\\cos \\theta} &amp; \\color{green}{-\\sin \\theta} &amp;     \\color{green}0 \\\\\n    \\color{blue}0 &amp; \\color{blue}{\\sin \\theta} &amp; \\color{blue}{\\cos \\theta} &amp;     \\color{blue}0 \\\\\n    \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}1\n    \\end{bmatrix}\n    \\cdot\n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    z \\\\\n    1\n    \\end{bmatrix}\n    =\n    \\begin{bmatrix}\n    x \\\\\n    \\color{green}{\\cos \\theta} \\cdot y - \\color{green}{\\sin \\theta} \\cdot z \\\\\n    \\color{blue}{\\sin \\theta} \\cdot y + \\color{blue}{\\cos \\theta} \\cdot z \\\\\n    1\n    \\end{bmatrix}\n⎣⎢⎢⎢⎡​1000​0cosθsinθ0​0−sinθcosθ0​0001​⎦⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎡​xyz1​⎦⎥⎥⎥⎤​=⎣⎢⎢⎢⎡​xcosθ⋅y−sinθ⋅zsinθ⋅y+cosθ⋅z1​⎦⎥⎥⎥⎤​\n\n绕 y 轴旋转 θ\n\n[cos⁡θ0sin⁡θ00100−sin⁡θ0cos⁡θ00001]⋅[xyz1]=[cos⁡θ⋅x+sin⁡θ⋅zy−sin⁡θ⋅x+cos⁡θ⋅z1]    \\begin{bmatrix}\n    \\color{red}{\\cos \\theta} &amp; \\color{red}0 &amp; \\color{red}{\\sin \\theta} &amp; \\color{red}0 \\\\\n    \\color{green}0 &amp; \\color{green}1 &amp; \\color{green}0 &amp; \\color{green}0 \\\\\n    - \\color{blue}{\\sin \\theta} &amp; \\color{blue}0 &amp; \\color{blue}{\\cos \\theta} &amp; \\color{blue}0 \\\\\n    \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}1\n    \\end{bmatrix}\n    \\cdot\n    \\begin{bmatrix} x \\\\\n    y \\\\\n    z \\\\\n    1\n    \\end{bmatrix}\n    =\n    \\begin{bmatrix} \\color{red}{\\cos \\theta}\n    \\cdot\n    x + \\color{red}{\\sin \\theta} \\cdot z \\\\\n    y \\\\\n    - \\color{blue}{\\sin \\theta} \\cdot x + \\color{blue}{\\cos \\theta} \\cdot z \\\\\n    1\n    \\end{bmatrix}\n⎣⎢⎢⎢⎡​cosθ0−sinθ0​0100​sinθ0cosθ0​0001​⎦⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎡​xyz1​⎦⎥⎥⎥⎤​=⎣⎢⎢⎢⎡​cosθ⋅x+sinθ⋅zy−sinθ⋅x+cosθ⋅z1​⎦⎥⎥⎥⎤​\n\n绕 z 轴旋转 θ\n\n[cos⁡θ−sin⁡θ00sin⁡θcos⁡θ0000100001]⋅[xyz1]=[cos⁡θ⋅x−sin⁡θ⋅ysin⁡θ⋅x+cos⁡θ⋅yz1]    \\begin{bmatrix}\n    \\color{red}{\\cos \\theta} &amp; - \\color{red}{\\sin \\theta} &amp; \\color{red}0 &amp; \\color{red}0 \\\\\n    \\color{green}{\\sin \\theta} &amp; \\color{green}{\\cos \\theta} &amp; \\color{green}0 &amp; \\color{green}0 \\\\\n    \\color{blue}0 &amp; \\color{blue}0 &amp; \\color{blue}1 &amp; \\color{blue}0 \\\\\n    \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}1\n    \\end{bmatrix}\n    \\cdot\n    \\begin{bmatrix}\n    x \\\\\n    y \\\\\n    z \\\\\n    1\n    \\end{bmatrix}\n    =\n    \\begin{bmatrix} \\color{red}{\\cos \\theta} \\cdot x - \\color{red}{\\sin \\theta} \\cdot y \\\\\n    \\color{green}{\\sin \\theta} \\cdot x + \\color{green}{\\cos \\theta} \\cdot y \\\\\n    z \\\\\n    1\n    \\end{bmatrix}\n⎣⎢⎢⎢⎡​cosθsinθ00​−sinθcosθ00​0010​0001​⎦⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎡​xyz1​⎦⎥⎥⎥⎤​=⎣⎢⎢⎢⎡​cosθ⋅x−sinθ⋅ysinθ⋅x+cosθ⋅yz1​⎦⎥⎥⎥⎤​\n绕 x 轴旋转 90° 的例子\n\n[100000−100−1000001]⋅[abc1]=[a−c−b1]    \\begin{bmatrix} \\color{red}1 &amp; \\color{red}0 &amp; \\color{red}0 &amp; \\color{red}0 \\\\\n    \\color{green}0 &amp; \\color{green}{0} &amp; \\color{green}{-1} &amp; \\color{green}0 \\\\\n    \\color{blue}0 &amp; \\color{blue}{-1} &amp; \\color{blue}{0} &amp; \\color{blue}0 \\\\\n    \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}1 \\end{bmatrix}\n    \\cdot\n    \\begin{bmatrix}\n    a \\\\\n    b \\\\\n    c\\\\\n    1\n    \\end{bmatrix}\n    =\n    \\begin{bmatrix}\n    a \\\\\n    \\color{green}{-c} \\\\\n    \\color{blue}{-b} \\\\\n    1\n    \\end{bmatrix}\n⎣⎢⎢⎢⎡​1000​00−10​0−100​0001​⎦⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎡​abc1​⎦⎥⎥⎥⎤​=⎣⎢⎢⎢⎡​a−c−b1​⎦⎥⎥⎥⎤​\n万向节死锁\n利用旋转矩阵我们可以把任意位置向量沿一个单位旋转轴进行旋转。\n也可以将多个矩阵复合，比如先沿着x轴旋转再沿着y轴旋转。但是这会很快导致一个问题——万向节死锁（Gimbal Lock）。\n\n万向节死锁的原因是坐标轴会跟着图形一起旋转，而并非一直呈现为标准的坐标轴样子\n推荐在 B站 或者 YouTube 搜索一些关于万向节死锁的视频，会帮助你理解这个问题产生的原因\n\n在这里我们不会讨论它的细节，但是对于3D空间中的旋转，一个更好的模型是沿着任意的一个轴，比如单位向量 (0.662,0.2,0.7222)(0.662, 0.2, 0.7222)(0.662,0.2,0.7222) 旋转，而不是对一系列旋转矩阵进行复合。\n这样的一个（超级麻烦的）矩阵是存在的，见下面这个公式，其中 (Rx,Ry,Rz)(\\color{red}{Rx},\\color{green}{Ry},\\color{blue}{Rz} \\color{white})(Rx,Ry,Rz) 代表任意旋转轴：\n[cos⁡θ+Rx2(1−cos⁡θ)RxRy(1−cos⁡θ)−Rzsin⁡θRxRz(1−cos⁡θ)+Rysin⁡θ0RyRx(1−cos⁡θ)+Rzsin⁡θcos⁡θ+Ry2(1−cos⁡θ)RyRz(1−cos⁡θ)−Rxsin⁡θ0RzRx(1−cos⁡θ)−Rysin⁡θRzRy(1−cos⁡θ)+Rxsin⁡θcos⁡θ+Rz2(1−cos⁡θ)00001]\\begin{bmatrix}\n\\cos \\theta + \\color{red}{R_x}^2(1 - \\cos \\theta) &amp;\n\\color{red}{R_x}\\color{green}{R_y}(1 - \\cos \\theta) - \\color{blue}{R_z} \\sin \\theta &amp;\n\\color{red}{R_x}\\color{blue}{R_z}(1 - \\cos \\theta) + \\color{green}{R_y} \\sin\\theta &amp;\n0 \\\\\n\\color{green}{R_y}\\color{red}{R_x} (1 - \\cos \\theta) + \\color{blue}{R_z} \\sin \\theta &amp;\n\\cos \\theta + \\color{green}{R_y}^2(1 - \\cos \\theta) &amp;\n\\color{green}{R_y}\\color{blue}{R_z}(1 - \\cos \\theta) - \\color{red}{R_x} \\sin \\theta &amp;\n0 \\\\\n\\color{blue}{R_z}\\color{red}{R_x}(1 - \\cos \\theta) - \\color{green}{R_y} \\sin \\theta &amp;\n\\color{blue}{R_z}\\color{green}{R_y}(1 - \\cos \\theta) + \\color{red}{R_x} \\sin \\theta &amp;\n\\cos \\theta + \\color{blue}{R_z}^2(1 - \\cos \\theta) &amp;\n0 \\\\\n0 &amp; 0 &amp; 0 &amp; 1\n\\end{bmatrix}\n⎣⎢⎢⎢⎡​cosθ+Rx​2(1−cosθ)Ry​Rx​(1−cosθ)+Rz​sinθRz​Rx​(1−cosθ)−Ry​sinθ0​Rx​Ry​(1−cosθ)−Rz​sinθcosθ+Ry​2(1−cosθ)Rz​Ry​(1−cosθ)+Rx​sinθ0​Rx​Rz​(1−cosθ)+Ry​sinθRy​Rz​(1−cosθ)−Rx​sinθcosθ+Rz​2(1−cosθ)0​0001​⎦⎥⎥⎥⎤​\n\n以下是 learnopengl-cn 对于万向节死锁的解释\n在数学上讨论如何生成这样的矩阵仍然超出了本节内容。\n但是记住，即使这样一个矩阵也不能完全解决万向节死锁问题（尽管会极大地避免）。\n避免万向节死锁的真正解决方案是使用四元数(Quaternion)，它不仅更安全，而且计算会更有效率。四元数可能会在后面的教程中讨论。\n对四元数的理解会用到非常多的数学知识。如果你想了解四元数与3D旋转之间的关系，可以来阅读我的教程。如果你对万向节死锁的概念仍不是那么清楚，可以来阅读我教程的Bonus章节。\n现在3Blue1Brown也已经开始了一个四元数的视频系列，他采用球极平面投影(Stereographic Projection)的方式将四元数投影到3D空间，同样有助于理解四元数的概念（仍在更新中）：https://www.youtube.com/watch?v=d4EgbgTm0Bg\n\n矩阵组合变换\n假设一个向量，我们希望将其缩放2倍，然后位移 (1,2,3)(1, 2, 3)(1,2,3) 个单位\nTrans⋅Scale=[1001010200130001]⋅[2000020000200001]=[2001020200230001]    Trans \\cdot Scale =\n    \\begin{bmatrix}\n    \\color{red}1 &amp; \\color{red}0 &amp; \\color{red}0 &amp; \\color{red}1 \\\\\n    \\color{green}0 &amp; \\color{green}1 &amp; \\color{green}0 &amp; \\color{green}2 \\\\\n    \\color{blue}0 &amp; \\color{blue}0 &amp; \\color{blue}1 &amp; \\color{blue}3 \\\\\n    \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}1\n    \\end{bmatrix}\n    \\cdot\n    \\begin{bmatrix} \\color{red}2 &amp; \\color{red}0 &amp; \\color{red}0 &amp; \\color{red}0 \\\\\n     \\color{green}0 &amp; \\color{green}2 &amp; \\color{green}0 &amp; \\color{green}0 \\\\\n    \\color{blue}0 &amp; \\color{blue}0 &amp; \\color{blue}2 &amp; \\color{blue}0 \\\\\n    \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}1\n    \\end{bmatrix}\n     =\n    \\begin{bmatrix}\n    \\color{red}2 &amp; \\color{red}0 &amp; \\color{red}0 &amp; \\color{red}1 \\\\\n    \\color{green}0 &amp; \\color{green}2 &amp; \\color{green}0 &amp; \\color{green}2 \\\\\n    \\color{blue}0 &amp; \\color{blue}0 &amp; \\color{blue}2 &amp; \\color{blue}3 \\\\\n    \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}1\n    \\end{bmatrix}\nTrans⋅Scale=⎣⎢⎢⎢⎡​1000​0100​0010​1231​⎦⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎡​2000​0200​0020​0001​⎦⎥⎥⎥⎤​=⎣⎢⎢⎢⎡​2000​0200​0020​1231​⎦⎥⎥⎥⎤​\n\n  \n    \n      注意\n\n    \n    \n      当矩阵相乘时我们先写位移再写缩放变换的。\n矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。\n当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的，所以你应该从右向左读这个乘法。\n建议您在组合矩阵时，先进行缩放操作，然后是旋转，最后才是位移，否则它们会互相影响。\n比如，如果你先位移再缩放，位移的向量也会同样被缩放（译注：比如向某方向移动2米，2米也许会被缩放成1米）！\n\n    \n  \n现在我们验证一下，这个矩阵的效果\n[2001020200230001]⋅[xyz1]=[2x+12y+22z+31]    \\begin{bmatrix} \\color{red}2 &amp; \\color{red}0 &amp; \\color{red}0 &amp; \\color{red}1 \\\\\n    \\color{green}0 &amp; \\color{green}2 &amp; \\color{green}0 &amp; \\color{green}2 \\\\\n    \\color{blue}0 &amp; \\color{blue}0 &amp; \\color{blue}2 &amp; \\color{blue}3 \\\\\n    \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}1\n    \\end{bmatrix}\n    \\cdot\n    \\begin{bmatrix} x \\\\\n    y \\\\\n    z \\\\\n    1 \\end{bmatrix}\n    =\n    \\begin{bmatrix}\n    \\color{red}2x + \\color{red}1 \\\\\n    \\color{green}2y + \\color{green}2  \\\\\n    \\color{blue}2z + \\color{blue}3 \\\\\n    1\n    \\end{bmatrix}\n⎣⎢⎢⎢⎡​2000​0200​0020​1231​⎦⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎡​xyz1​⎦⎥⎥⎥⎤​=⎣⎢⎢⎢⎡​2x+12y+22z+31​⎦⎥⎥⎥⎤​\n可以看到，他确实放大了两倍，并且平移了 (1,2,3)(1,2,3)(1,2,3)\n实践\nglm 库\n我们需要一个库 glm\n相信你非常容易地就猜出来了，这是 gl-math 的缩写\n我们就是通过这个库来实现各种矩阵运算\n\nglm 下载地址\n\nglm-0.9.9+\n\nGLM库从0.9.9版本起，默认会将矩阵类型初始化为一个零矩阵（所有元素均为0），而不是单位矩阵（对角元素为1，其它元素为0）。\n如果你使用的是0.9.9或0.9.9以上的版本，你需要将所有的矩阵初始化改为 glm::mat4 mat = glm::mat4(1.0f)。\n如果你使用 kotlin 编写 OpenGL 代码，也可以用 glm for kotlin\n我们需要的GLM的大多数功能都可以从下面这3个头文件中找到：\n#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt;\n位移实践\n我们以 向量(1,0,0) 位移（1,1,0）为例，并且简单说明一下，glm 的使用\nglm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f);std::cout &lt;&lt; &quot;位移前向量 (&quot; &lt;&lt; vec.x &lt;&lt; &quot;,&quot; &lt;&lt; vec.y &lt;&lt; &quot;,&quot; &lt;&lt; vec.z &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;// 先初始化，0.9.9及以上版本需要初始化为单位矩阵glm::mat4 transMat4 = glm::mat4(1.0f);// 设置延 x 轴，y 轴进行位移glm::vec3 transVec3 = glm::vec3(1.0f, 1.0f, 0.0f);// 生成位移矩阵transMat4 = glm::translate(transMat4, transVec3);std::cout &lt;&lt; &quot;位移矩阵：\\n&quot;;printMatrix(transMat4);// 矩阵和向量相乘vec = transMat4 * vec;std::cout &lt;&lt; &quot;位移后向量 (&quot; &lt;&lt; vec.x &lt;&lt; &quot;,&quot; &lt;&lt; vec.y &lt;&lt; &quot;,&quot; &lt;&lt; vec.z &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;\nvoid printMatrix(const glm::mat4 &amp;matrix) &#123;  const float* pMatrix = glm::value_ptr(matrix);  for (int i = 0; i &lt; 4; ++i) &#123;    for (int j = 0; j &lt; 4; ++j) &#123;      std::cout &lt;&lt; pMatrix[i + j * 4] &lt;&lt; &#x27; &#x27;;    &#125;    std::cout &lt;&lt; std::endl;  &#125;&#125;\n位移前向量 (1,0,0)位移矩阵：1 0 0 1 0 1 0 1 0 0 1 0 0 0 0 1 位移后向量 (2,1,0)\n\ntransMat4 是单位矩阵\nglm::translate(transMat4, transVec3) 用来生成位移矩阵\n然后向量左乘位移矩阵，实现向量的位移\n缩放实践\nglm::vec4 vec(1.0f, 1.0f, 0.0f, 1.0f);std::cout &lt;&lt; &quot;缩放前向量 (&quot; &lt;&lt; vec.x &lt;&lt; &quot;,&quot; &lt;&lt; vec.y &lt;&lt; &quot;,&quot; &lt;&lt; vec.z &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;// 初始化单位矩阵glm::mat4 transMat4 = glm::mat4(1.0f);// x 轴缩放到 0.5，y 轴缩放到 0.8glm::vec3 scaleVec3 = glm::vec3(0.5f, 0.8f, 0.0);// 生成缩放矩阵transMat4 = glm::scale(transMat4, scaleVec3);std::cout &lt;&lt; &quot;缩放矩阵：\\n&quot;;printMatrix(transMat4);// 计算vec = transMat4 * vec;std::cout &lt;&lt; &quot;缩放后向量 (&quot; &lt;&lt; vec.x &lt;&lt; &quot;,&quot; &lt;&lt; vec.y &lt;&lt; &quot;,&quot; &lt;&lt; vec.z &lt;&lt; &quot;)\\n&quot;;\n缩放前向量 (1,1,1)缩放矩阵：0.5 0 0 0 0 0.8 0 0 0 0 2 0 0 0 0 1 缩放后向量 (0.5,0.8,2)\n\ntransMat4 是单位矩阵\nglm::translate(transMat4, transVec3) 用来生成缩放矩阵\n然后向量左乘缩放矩阵，实现向量的缩放\n旋转实践\nglm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f);std::cout &lt;&lt; &quot;旋转前向量 (&quot; &lt;&lt; vec.x &lt;&lt; &quot;,&quot; &lt;&lt; vec.y &lt;&lt; &quot;,&quot; &lt;&lt; vec.z &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;// 初始化单位矩阵glm::mat4 transMat4 = glm::mat4(1.0f);// 旋转向量（选择 z 轴）glm::vec3 transVec3 = glm::vec3(0.0f, 0.0f, 1.0f);// 生成旋转矩阵transMat4 = glm::rotate(transMat4, 0.523598333333333f, transVec3);std::cout &lt;&lt; &quot;旋转矩阵：\\n&quot;;printMatrix(transMat4);// 计算vec = transMat4 * vec;std::cout &lt;&lt; &quot;旋转后向量 (&quot; &lt;&lt; vec.x &lt;&lt; &quot;,&quot; &lt;&lt; vec.y &lt;&lt; &quot;,&quot; &lt;&lt; vec.z &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;\n旋转前向量 (1,0,0)旋转矩阵：0.866026 -0.5 0 0 0.5 0.866026 0 0 0 0 1 0 0 0 0 1 旋转后向量 (0.866026,0.5,0)\n\ntransMat4 是单位矩阵\nglm::rotate(transMat4, transVec3) 用来生成缩放矩阵\n然后向量左乘位移矩阵，实现向量的旋转\nopengl\n","tags":["OpenGL"]},{"title":"OpenGL 窗口","url":"/2023/08/13/OpenGL-%E7%AA%97%E5%8F%A3/","content":"学习地址\n我是从这里学习的 OpenGL LearnOpenGL-CN\n了解背景\n首先，了解背景很重要的，这能让我们更好地初步对OpenGL有一个概念\n概念\nOpenGL 并不是一个 API ，它仅仅是一个由Khronos组织制定并维护的规范（ Specification ）。\n文档链接\n实际的OpenGL库的开发者通常是显卡的生产商。你购买的显卡所支持的OpenGL版本都为这个系列的显卡专门开发的。\n当你使用Apple系统的时候，OpenGL库是由Apple自身维护的。\n在 Linux 下，有显卡生产商提供的OpenGL库，也有一些爱好者改编的版本。这也意味着任何时候OpenGL库表现的行为与规范规定的不一致时，基本都是库的开发者留下的bug。\n渲染模式的变更\n早期的OpenGL 使用立即渲染模式（Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便，容易学习和使用，但不够灵活。一旦要进行细节实现，效率低下的弊端就会暴露出来。\n因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的核心模式 (Core-profile)下进行开发，这个分支的规范完全移除了旧的特性。\n正是因为完全废除了旧特性，所以我们就没法使用已经废弃的函数了，而不像某些语言，废弃只是不建议使用，而废弃函数本身还可以勉强使用\n\nps：相对于立即渲染模式，核心渲染模式更加灵活高效，但你需要深入理解OpenGL的渲染流程，因此学习起来更加复杂。\n\n对扩展(Extension)的支持\n当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。\n开发者可以使用支持此扩展的显卡来编写更新的代码，只需判断是否支持即可\n就像这样\nif(GL_ARB_extension_name)&#123;    // 使用硬件支持的全新的现代特性&#125;else&#123;    // 不支持此扩展: 用旧的方式去做&#125;\nOpenGL 是个状态机\nOpenGL的状态通常被称为OpenGL_Context。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL_Context来渲染。\n假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些Context变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。\n一旦我们改变了 OpenGL 的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。\n\n所以很多人在学习OpenGL的时候总是感觉不明白gl函数的意义，其实本质就是在操作OpenGL这个状态机\n\nOpenGL 里的对象\nOpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。\n所以OpenGL里的对象就是C语言里的结构体。\n他表示的就是OpenGL里的状态小集合\nstruct object_name &#123;    float  option1;    int    option2;    char[] name;&#125;;\n而OpenGL本身就是一个状态的集合\n// OpenGL的状态struct OpenGL_Context &#123;    ...    object* object_Window_Target;    ...     &#125;;\n我们操作OpenGL的时候，就会类似下面这样的操作\nunsigned int objectId = 0;glGenObject(1, &amp;objectId);  // 创建对象glBindObject(GL_WINDOW_TARGET, objectId);   // 绑定对象至上下文glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800);   // 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);glBindObject(GL_WINDOW_TARGET, 0);  // 将上下文对象设回默认\n这一小段代码展现了你以后使用OpenGL时常见的工作流。\n我们首先创建一个对象，然后用一个id保存它的引用（实际数据被储存在后台）。\n然后我们将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET）。\n接下来我们设置窗口的选项。\n最后我们将目标位置的对象id设回0，解绑这个对象。\n设置的选项将被保存在objectId所引用的对象中，一旦我们重新绑定这个对象到GL_WINDOW_TARGET位置，这些选项就会重新生效。\n代码讲解\n这里我以在 Mac 端为例，贴上全部代码，其实就是 OpenGL on Mac 环境 的那些代码\n源码\n#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;void framebuffer_size_callback(GLFWwindow*  window, int width, int height);void processInput(GLFWwindow* window);int main() &#123;    glfwInit(); // init glfw    // use version 3.3    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,  3); // set major version    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,  3); // set minor version    glfwWindowHint(GLFW_OPENGL_PROFILE,        GLFW_OPENGL_CORE_PROFILE); // use core profile    // MacOS specific code    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);    GLFWwindow* window = glfwCreateWindow(800,  600, &quot;LearnOpenGL&quot;, NULL, NULL);   //    800*600 size window called LearnOpenGL    if (window == NULL) &#123;        std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;        glfwTerminate();    // 释放/删除之前的分配的所有资源        return -1;    &#125;    glfwMakeContextCurrent(window);   // set the current window    if (!gladLoadGLLoader((GLADloadproc) glfwGetProcAddress)) &#123;        std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot;    &lt;&lt; std::endl;        return -1;    &#125;    glViewport(0, 0, 800, 600);    // 设置窗口位置    glfwSetFramebufferSizeCallback(window,  framebuffer_size_callback);    // 设置窗口大小调整回调    // 循环检查窗口是否需要被关闭    while (!glfwWindowShouldClose(window))&#123;            processInput(window);    // 监控ESC退出窗口        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);     // 调用glClearColor来设置清空屏幕所用的颜色        glClear(GL_COLOR_BUFFER_BIT);    // 调用glClear函数来清空屏幕的颜色缓冲        glfwSwapBuffers(window);    // 函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素 颜色值的大缓冲），它在这一迭代中被用来绘 制，并且将会作为输出显示在屏幕上。        glfwPollEvents();    // 检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）    &#125;    // 释放/删除之前的分配的所有资源    glfwTerminate();    return 0;&#125;void framebuffer_size_callback(GLFWwindow*  window, int width, int height)&#123;    glViewport(0, 0, width, height);&#125;// 监控ESC退出窗口void processInput(GLFWwindow* window)&#123;    if (glfwGetKey(window, GLFW_KEY_ESCAPE) ==  GLFW_PRESS)        glfwSetWindowShouldClose(window, true);&#125;\n\nps: 再次强调，引用的时候glad在前glfw在后，不能反过来\n\n初始化工作\nglfwInit(); // init glfw// use version 3.3glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,  3); // set major versionglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,  3); // set minor versionglfwWindowHint(GLFW_OPENGL_PROFILE,    GLFW_OPENGL_CORE_PROFILE); // use core  profile// MacOS specific codeglfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n这一部分基本算是死代码，所以暂时不需要过多关心\n设置 window\nGLFWwindow* window = glfwCreateWindow(800,  600,&quot;LearnOpenGL&quot;, NULL, NULL);   //    800*600 size window called LearnOpenGLif (window == NULL) &#123;    std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt;std::endl;    glfwTerminate();    // 释放/删除之前的分配的所有资源    return -1;&#125;glfwMakeContextCurrent(window);   // set the current windowif (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123;    std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot;    &lt;&lt; std::endl;    return -1;&#125;glViewport(0, 0, 800, 600);    // 设置窗口位置glfwSetFramebufferSizeCallback(window,  framebuffer_size_callback);    // 设置窗口大小调整回调\n这里是window设置，也就是窗口大小（没错就是我们平时看到的 Mac 窗口）\n\nviewport指的是渲染的区域大小\ndoc here\n/** * Parameters * x, y * Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0). *  * width, height * Specify the width and height of the viewport. When a GL context is first attached to a window, width and height are set to the dimensions of that window.*/void glViewport(GLint x, GLint y, GLsizei width, GLsizei height);\n如果指定的viewport比windows小，就会出现这样的现象\n\n左下角有一个远远小于窗口大小的图形\nglfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n这是设置framebuffer回调，framebuffer_size_callback的定义在下面\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123;    glViewport(0, 0, width, height);&#125;\n渲染循环\nwhile (!glfwWindowShouldClose(window))&#123;    processInput(window);    // 监控ESC退出窗口    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);     // 调glClearColor来设置清空屏幕所用的颜色    glClear(GL_COLOR_BUFFER_BIT);    // 调用glClear函数来清空屏的颜色缓冲    glfwSwapBuffers(window);    // 函数会交换颜色缓冲（它是一个储着GLFW窗口每一个像素 颜色值的大缓冲），它在这一迭代中被用绘 制，并且将会作为输出显示在屏幕上。    glfwPollEvents();    // 检查有没有触发什么事件（比如键盘输入、鼠移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调法手动设置）&#125;\n我们可不希望只绘制一个图像之后我们的应用程序就立即退出并关闭窗口。\n我们希望程序在我们主动关闭它之前不断绘制图像并能够接受用户输入。\n因此，我们需要在程序中添加一个while循环，我们可以把它称之为渲染循环(Render Loop)，它能在我们让GLFW退出前一直保持运行。\nprocessInput是检测按键是否是ESC，定义在这里，glfwSetWindowShouldClose(window, true);通过把WindowShouldClose属性设置为true的方法关闭GLFW\nvoid processInput(GLFWwindow* window)&#123;    if (glfwGetKey(window, GLFW_KEY_ESCAPE) ==  GLFW_PRESS)        glfwSetWindowShouldClose(window, true);&#125;\nglClearColor(0.2f, 0.3f, 0.3f, 1.0f);这是设置glClearColor的值，也就是清除颜色缓冲的颜色值，在下一行glClear调用的时候用的就是我们设置的这个颜色\nglClearColor(0.2f, 0.3f, 0.3f, 1.0f);     // 调glClearColor来设置清空屏幕所用的颜色glClear(GL_COLOR_BUFFER_BIT);    // 调用glClear函数来清空屏幕的颜色缓冲\nglfwSwapBuffers(window);是渲染下一帧的指令\n为了渲染的连贯性，opengl有两个缓冲，当上一帧在前台显示的时候，会在后台继续渲染，然后将后台渲染好的缓冲直接加载到前台变成了前台缓冲，而前台的buffer变成了后台缓冲，继续渲染后续的帧，就这么不断地交换缓冲，这就叫双缓冲\n\n双缓冲(Double Buffer)\n应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。\n\n\nglfwPollEvent:poll是轮训的意思，意思就是在检查事件，并返回给 OpenGL\nglfwPollEvents();    // 检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）\n放个文档在这\n/*This function processes only those events that are already in the event queue and then returns immediately. Processing events will cause the window and input callbacks associated with those events to be called. *此函数仅处理事件队列中已有的那些事件，然后立即返回。处理事件将导致调用与这些事件关联的窗口和输入回调。 * *On some platforms, a window move, resize or menu operation will cause event processing to block. This is due to how event processing is designed on those platforms. You can use the window refresh callback to redraw the contents of your window when necessary during such operations. *在某些平台上，窗口移动、调整大小或菜单操作将导致事件处理阻塞。这是由于事件处理在这些平台上的设计方式。在此类操作期间，如有必要，可以使用窗口刷新回调重绘窗口的内容。 * *Do not assume that callbacks you set will only be called in response to event processing functions like this one. While it is necessary to poll for events, window systems that require GLFW to register callbacks of its own can pass events to GLFW in response to many window system function calls. GLFW will pass those events on to the application callbacks before returning. *不要假设您设置的回调只会在响应像这样的事件处理函数时才被调用。虽然有必要轮询事件，但需要 GLFW 注册自己的回调的窗口系统可以将事件传递给 GLFW 以响应许多窗口系统函数调用。GLFW 会在返回之前将这些事件传递给应用程序回调。 * *Event processing is not required for joystick input to work. *游戏杆输入不需要事件处理即可工作。 */void glfwPollEvents(void)\nglfw文档在这里看\n另外有一个翻译插件非常好用，之前也有safari 版本现在好像只有Chrome 版本了\n\nglfwTerminate();\n这个是设置所有资源，我们放在return 0;的前一行\n","tags":["OpenGL"]},{"title":"C++ 可恶的 duplicate symbol (符号重复)","url":"/2024/04/01/C-%E5%8F%AF%E6%81%B6%E7%9A%84-duplicate-symbol-%E7%AC%A6%E5%8F%B7%E9%87%8D%E5%A4%8D/","content":"背景\n我之前是主写 Java 、 Kotlin 的， C++ 写的少之甚少\n之前写 OpenGL 的时候，就一直被 duplicate symbol 这个问题困扰\n现在我终于找到了解决方法\n先说结论\n我之所以没有明白这个问题的原因和解决方法，是因为我对于 C++ 多文件编程存在理解错误\n我没有意识到 #include 的作用主要是帮助声明，而不是和 Java 、 Kotlin 之类的语言一样使用 import 将包引入。\n\n  \n    \n      结论\n\n    \n    \n      C++ 在编译期间有一个连接的过程，这个过程能让 C++ 任意访问声明过的任意函数或者变量，所以 #include 的常见作用是将一大堆的声明导入到你的 cpp 文件中。\n毕竟如果你在很多文件里都需要使用某些函数，每次都写好几行声明确实有点麻烦，而一行 #include 就可以解决这个问题\n所以， #pragma once 、 #if def 的作用主要是防止 #include 导入的声明重复\n所以你更多的是检查声明以及定义的对应，往往能解决大部分问题\n\n    \n  \n\n  \n    当然 #include 的功能不止是导入声明，也可以在 #include 里写函数的定义，这时候往往会将函数设为 static 来限制他的作用域\n\n  \n原理\n首先，C++ 的编译器本身也是一段程序，而且不同编译器，编译成功与否可能会有细微的差别，但几乎都是相同的\n\n\n如果你在两个以上文件定义同样的函数（方法），就会产生重复。\n\n\n预处理阶段（Preprocessing），预处理指令会对源码文件（cpp 文件）进行临时扩充，预处理命令以 # 开头，例如： #include  ， #define ， #ifdef 等\n对于 #define 指令，编译器将源码中的宏替换成宏定义中的内容；\n对于 #if 、 #ifdef 和 #ifndef 指令，编译器将有选择地跳过或选中部分源代码；\n而对于 #include 指令，编译器将把对应的库的源码插入到当前源代码中——这通常是一些通用的声明。\n被 #include 指令引入的头文件（ .h ）往往会包含大量的代码，你引入的越多，最后生成的预编译文件就越大。\n总的来说，预编译过的文件会比原来的 C++ 源码更大一些。\n\n\n编译编译和汇编阶段（Compilation &amp; assembly），预处理结束后，将预处理好的文件编译成 object 目标文，也就是 .o 文件。\n\n\n链接阶段（linking），将未定义标识符的引用全部替换成它们对应的正确地址，地址对应上，这就算是链接上了，这一步就是我们代码编译过程中产生 duplicate symbol（重复）的地方。\n\n\n也就是说，在编译器进行链接（linking）的时候，由于某个方法我们定义了多次，所以它并不知道要链接到那个地址，所以就报报错了\n解决办法\n消除 symbol\n\n将 method 声明为 inline 。 inline 方法会被直接 copy 到方法调用处，这个 Kotlin 也有类似的语法\n宏定义\n\n  #define LOG(s) (std::cout &lt;&lt; s &lt;&lt; std::endl)\n声明为静态\n静态函数会只在当前 object目标文件（.o文件）可见\n最好的方式就是养成良好的代码习惯\n考虑清楚你定义的函数应该设为全局的还是局部的，是否会被多次定义\n\n  \n    如果你定义的函数存在 .h 文件里，那么就容易出现重复定义的情况\n\n  \n","tags":["C++","cpp"]},{"title":"OpenGL 纹理","url":"/2023/09/24/OpenGL-%E7%BA%B9%E7%90%86/","content":"纹理坐标（2D）\n纹理坐标在 x 和 y 轴上，范围为 0 到 1 之间\n\nblue 使用纹理坐标获取纹理颜色叫做采样(Sampling)\n这个采样是什么意思呢？我们看一个图\n\n这是一个纹理的坐标图\nfloat texCoords[] = &#123;    0.0f, 0.0f, // 左下角    1.0f, 0.0f, // 右下角    0.0f, 1.0f, // 左上角    1.0f, 1.0f  // 右上角&#125;;\n这是一个纹理的坐标\n这些点的坐标和上面那个图是什么关系？看下面这个图\n\n也就是说：这个坐标其实就是红色虚线框的坐标，红色虚线框是用来裁切图片的\n将图片以某种算法填充到这个红色虚线框里，这就叫纹理映射。\n\n坐标的常见操作\n\n\n缩小（裁切）\n将纹理坐标写为\n\n\n float texCoords[] = &#123;    -0.25f, -0.25f, // 左下角    1.75f, -0.25f, // 右下角    -0.25f, 1.75f, // 左上角    1.75f, 1.75f  // 右上角&#125;;\n纹理将这样显示\n  \n也就是这样\n  \n\n\n放大\n将纹理坐标写为\n\n\n float texCoords[] = &#123;    0.0f, 0.0f, // 左下角    0.5f, 0.0f, // 右下角    0.0f, 0.5f, // 左上角    0.5f, 0.5f  // 右上角&#125;;\n纹理将这样显示\n  \n也就是这样\n  \n那么我想显示中间一块小区域该怎么写坐标呢？\n float texCoords[] = &#123;    0.25f, 0.25f, // 左下角    0.75f, 0.25f, // 右下角    0.25f, 0.75f, // 左上角    0.75f, 0.75f  // 右上角&#125;;\n  \n  \n\n\n错位\n纹理坐标并不一定是裁切或者放大，还可以将纹理平移\n这很容易理解，比如我想不放大缩小，只是向右平移纹理，那么坐标应该这样写\n\n\n float texCoords[] = &#123;    -0.5f, 0.0f, // 左下角    0.5f, 0.0f, // 右下角    -0.5f, 1.0f, // 左上角    0.5f, 1.0f  // 右上角&#125;;\n  \n你甚至可以将纹理映射成梯形，平行四边形，只要你写对了这四个点的坐标\n  \n但是如果我们将它映射成梯形，就不同了\n  \n但是这里涉及一个纹理过滤（也就是一开始提到的插值的问题）的问题，我接下来会讲\n环绕方式\n环绕方式只有你在漏出不存在区域（图片外的区域）的时候，才会起效果\nOpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择（也就是环绕方式，玩过 WinXP 的桌面的肯定很熟悉）：\n\n图片就很直观，唯一要说的是GL_CLAMP_TO_BORDER，这个需要你制定一个颜色，图片外的区域都会渲染成这个颜色，上面我就选了黄色\n纹理过滤\n当你\n你可能已经猜到了，OpenGL也有对于纹理过滤(Texture Filtering)的选项。\n纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：GL_NEAREST和GL_LINEAR。\n\n\nGL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：\n\n\nGL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色：\n\n\n\n\n那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：\n\nGL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。\n当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n多级渐远纹理（mipmap）\nmipmap 主要解决 2 个事情\n\n线性插值的计算问题，这个后面会说到\n内存或者性能的占用问题\n\n让我们看一下多级渐远纹理是什么样子的：\n\n手动为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好 OpenGL 有一个 glGenerateMipmaps 函数，在创建完一个纹理后调用它 OpenGL 就会承担接下来的所有工作了。\n在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。\n就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用 NEAREST 和 LINEAR 过滤。\n为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式：\nGL_NEAREST_MIPMAP_NEAREST 以这个为例，前半部分 GL_NEAREST 是纹理过滤的插值算法，后半部分 MIPMAP_NEAREST 多级纹理切换的方式\n描述\n\n\n\n过滤方式\n描述\n\n\n\n\nGL_NEAREST_MIPMAP_NEAREST\n使用邻近插值进行插值，使用最邻近的多级渐远纹理\n\n\nGL_LINEAR_MIPMAP_NEAREST\n使用线性插值进行采样，使用最邻近的多级渐远纹理\n\n\nGL_NEAREST_MIPMAP_LINEAR\n使用邻近插值进行采样，在两个邻近的多级渐远纹理之间使用线性插值\n\n\nGL_LINEAR_MIPMAP_LINEAR\n使用线性插值进行采样，在两个邻近的多级渐远纹理之间使用线性插值\n\n\n\n就像纹理过滤一样，我们可以使用 glTexParameteri 将过滤方式设置为前面四种提到的方法之一：\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\nps: 一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。\n这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个 GL_INVALID_ENUM 错误代码。\n\n多级渐远纹理背后的理念很简单：在小的范围上，映射一个分辨率非常高的纹理，会导致线性插值的时候，计算颜色变得复杂\n反应到十几种就是距观察者的距离过远，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。\n由于距离远，解析度不高也不会被用户注意到。\n同时，多级渐远纹理另一加分之处是它的性能非常好。\n","tags":["OpenGL"]},{"title":"OpenGL 齐次坐标的妙用","url":"/2023/08/21/OpenGL-%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%9A%84%E5%A6%99%E7%94%A8/","content":"非透视投影变换\n非透视投影包括 R(旋转)、S(缩放)、T(位移)、虚拟摄像机变换、正视投影变换，所有的非透视投影变换 都是 R S T 组合而来的\n位移变换\n假设我们有一个向量代表一个物体 V=(x,y)V=(x,y)V=(x,y) ，然后我们想平移它\n比如这样：V′=(x+tx,y+tx)V^{&#x27;}=(x+t_x,y+t_x)V′=(x+tx​,y+tx​)\n而矩阵运算\n[abcd]⋅[xy]=[ax+bycx+dy]\\begin{bmatrix}\na &amp; b \\\\\nc &amp; d\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nax+by \\\\\ncx+dy\n\\end{bmatrix}\n[ac​bd​]⋅[xy​]=[ax+bycx+dy​]\n没有办法出现常数，所以我们就可以增加一个维度：\n$\\begin{bmatrix}\nx\\\ny\\\n1\n\\end{bmatrix} $\n然后再使用一个 3×3 的矩阵来做变换\n[x′y′1]=[10tx01ty001][xy1]=[x+txy+tx1]\\begin{bmatrix}\nx^{&#x27;}\\\\\ny^{&#x27;}\\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 &amp; 0 &amp; t_x \\\\\n0 &amp; 1 &amp; t_y \\\\\n0 &amp; 0 &amp; 1\n\\end{bmatrix}\n\\begin{bmatrix}\nx\\\\\ny\\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nx+t_x\\\\\ny+t_x\\\\\n1\n\\end{bmatrix}\n⎣⎢⎡​x′y′1​⎦⎥⎤​=⎣⎢⎡​100​010​tx​ty​1​⎦⎥⎤​⎣⎢⎡​xy1​⎦⎥⎤​=⎣⎢⎡​x+tx​y+tx​1​⎦⎥⎤​\n得到 x′=x+xtx^{&#x27;}=x+x_tx′=x+xt​ ， y′=y+yty^{&#x27;}=y+y_ty′=y+yt​\n这样我们就可以完成位移了，这个吧多出来的维度就叫齐次坐标。\n\n同样我们统一使用齐次坐标来进行缩放和旋转，因为这样就可以一直保持向量是多一个维度的（也就是多出来的那个齐次坐标），直接相乘不用来回增减齐次坐标了。\n\nT=[10tx01ty001]T=\n\\begin{bmatrix}\n1 &amp; 0 &amp; t_x \\\\\n0 &amp; 1 &amp; t_y \\\\\n0 &amp; 0 &amp; 1\n\\end{bmatrix}\nT=⎣⎢⎡​100​010​tx​ty​1​⎦⎥⎤​\n缩放变换\nS=[sx000sy0001]S=\\begin{bmatrix}\ns_x &amp; 0 &amp; 0 \\\\\n0 &amp; s_y &amp; 0 \\\\\n0 &amp; 0 &amp; 1\n\\end{bmatrix}\nS=⎣⎢⎡​sx​00​0sy​0​001​⎦⎥⎤​\n旋转变换\nR=[cosθ−sinθ0sinθcosθ0001]R=\n\\begin{bmatrix}\ncos\\theta &amp; -sin\\theta &amp; 0 \\\\\nsin\\theta &amp; cos\\theta &amp; 0 \\\\\n0 &amp; 0 &amp; 1\n\\end{bmatrix}\nR=⎣⎢⎡​cosθsinθ0​−sinθcosθ0​001​⎦⎥⎤​\n三维物体变换\n位移\nT=[100tx010ty001tz0001]T=\n\\begin{bmatrix}\n1 &amp; 0 &amp; 0 &amp; t_x\\\\\n0 &amp; 1 &amp; 0 &amp; t_y\\\\\n0 &amp; 0 &amp; 1 &amp; t_z\\\\\n0 &amp; 0 &amp; 0 &amp; 1\n\\end{bmatrix}\nT=⎣⎢⎢⎢⎡​1000​0100​0010​tx​ty​tz​1​⎦⎥⎥⎥⎤​\n缩放\nS=[sx0000sy0000sz00001]S=\n\\begin{bmatrix}\ns_x &amp; 0 &amp; 0 &amp; 0\\\\\n0 &amp; s_y &amp; 0 &amp; 0\\\\\n0 &amp; 0 &amp; s_z &amp; 0\\\\\n0 &amp; 0 &amp; 0 &amp; 1\n\\end{bmatrix}\nS=⎣⎢⎢⎢⎡​sx​000​0sy​00​00sz​0​0001​⎦⎥⎥⎥⎤​\n旋转\nRx=[cosθ−sinθ00sinθcosθ0000100001]R_x=\n\\begin{bmatrix}\ncos\\theta &amp; -sin\\theta &amp; 0 &amp; 0\\\\\nsin\\theta &amp; cos\\theta &amp; 0 &amp; 0\\\\\n0 &amp; 0 &amp; 1 &amp; 0\\\\\n0 &amp; 0 &amp; 0 &amp; 1\n\\end{bmatrix}\nRx​=⎣⎢⎢⎢⎡​cosθsinθ00​−sinθcosθ00​0010​0001​⎦⎥⎥⎥⎤​\nRy=[cosθ0−sinθ00100sinθ0cosθ00001]R_y=\n\\begin{bmatrix}\ncos\\theta &amp; 0 &amp; -sin\\theta &amp; 0 \\\\\n0 &amp; 1 &amp; 0 &amp; 0 \\\\\nsin\\theta &amp; 0 &amp; cos\\theta &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 1\n\\end{bmatrix}\nRy​=⎣⎢⎢⎢⎡​cosθ0sinθ0​0100​−sinθ0cosθ0​0001​⎦⎥⎥⎥⎤​\nRz=[10000cosθ−sinθ00sinθcosθ00001]R_z=\n\\begin{bmatrix}\n1 &amp; 0 &amp; 0 &amp; 0 \\\\\n0 &amp; cos\\theta &amp; -sin\\theta &amp; 0 \\\\\n0 &amp; sin\\theta &amp; cos\\theta &amp; 0 \\\\\n0 &amp; 0 &amp; 0 &amp; 1\n\\end{bmatrix}\nRz​=⎣⎢⎢⎢⎡​1000​0cosθsinθ0​0−sinθcosθ0​0001​⎦⎥⎥⎥⎤​\n透视投影变换\n小孔成像\n透视投影变换能够呈现出近大远小透视效果，更符合我们的视觉感受\n透视投影模拟的是针孔摄像机，或者说小孔成像\n\n小孔成像会在黑盒里的真空后面后面呈现一个倒立的图像，但是我们在计算机里可以将图像放在小孔前面，这样不仅可以避免图像颠倒，写代码的时候还会更直观\n而且这个小孔的位置就可以成为我们的观察点\n矩阵计算\n然后我们就可以计算一下这个最终呈现的像的大小\n\n如图所示，我们用相似可以简单推出 y′=−n⋅yz\\displaystyle y^{&#x27;}=-\\frac{n\\cdot y}{z}y′=−zn⋅y​ （ py=−zpy=-zpy=−z 是因为坐标 zzz 是 AAA 点的 zzz  轴坐标）\n成像的 y′y^{&#x27;}y′ 与 zzz 成反比，正好符合近大远小的规律\n然而，矩阵运算是乘法和加法，没法很方便地计算除法\n所以我们这里使用齐次坐标\n[ABCEFGIJK]⋅[xyz]=[Ax+By+CzEx+Fy+GzIx+Jy+Kz]\\begin{bmatrix}\nA &amp; B &amp; C \\\\\nE &amp; F &amp; G \\\\\nI &amp; J &amp; K \n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\nx\\\\\ny\\\\\nz\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nAx+By+Cz\\\\\nEx+Fy+Gz\\\\\nIx+Jy+Kz\n\\end{bmatrix}\n⎣⎢⎡​AEI​BFJ​CGK​⎦⎥⎤​⋅⎣⎢⎡​xyz​⎦⎥⎤​=⎣⎢⎡​Ax+By+CzEx+Fy+GzIx+Jy+Kz​⎦⎥⎤​\n最终将得到的向量除以 zzz 分量得到：\n[Ax+By+CzIx+Jy+KzEx+Fy+GzIx+Jy+Kz1]\\begin{bmatrix}\n\\displaystyle\\frac{Ax+By+Cz}{Ix+Jy+Kz}\\\\\\\\\n\\displaystyle\\frac{Ex+Fy+Gz}{Ix+Jy+Kz}\\\\\\\\\n1\n\\end{bmatrix}\n⎣⎢⎢⎢⎢⎢⎢⎢⎢⎡​Ix+Jy+KzAx+By+Cz​Ix+Jy+KzEx+Fy+Gz​1​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎤​\n就得到了最终的答案，在成像位置不变的时候，zzz 越小显示的图像越大，反之越小，三维物体也是同样的道理：\n[ABCDEFGHIJKLMNOP]⋅[xyzw]=[Ax+By+Cz+DwEx+Fy+Gz+HwIx+Jy+Kz+LwMx+Ny+Oz+Pw]    \\begin{bmatrix}\n    A &amp; B &amp; C &amp; D\\\\\n    E &amp; F &amp; G &amp; H\\\\\n    I &amp; J &amp; K &amp; L\\\\\n    M &amp; N &amp; O &amp; P\n    \\end{bmatrix}\n    \\cdot\n    \\begin{bmatrix}\n    x\\\\\n    y\\\\\n    z\\\\\n    w\n    \\end{bmatrix}\n    =\n    \\begin{bmatrix}\n    Ax+By+Cz+Dw\\\\\n    Ex+Fy+Gz+Hw\\\\\n    Ix+Jy+Kz+Lw\\\\\n    Mx+Ny+Oz+Pw\n    \\end{bmatrix}\n⎣⎢⎢⎢⎡​AEIM​BFJN​CGKO​DHLP​⎦⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎡​xyzw​⎦⎥⎥⎥⎤​=⎣⎢⎢⎢⎡​Ax+By+Cz+DwEx+Fy+Gz+HwIx+Jy+Kz+LwMx+Ny+Oz+Pw​⎦⎥⎥⎥⎤​\n归一化：\n[Ax+By+Cz+DwMx+Ny+Oz+PwEx+Fy+Gz+HwMx+Ny+Oz+PwIx+Jy+Kz+LwMx+Ny+Oz+Pw1]\\begin{bmatrix}\n\\displaystyle\\frac{Ax+By+Cz+Dw}{Mx+Ny+Oz+Pw}\\\\\\\\\n\\displaystyle\\frac{Ex+Fy+Gz+Hw}{Mx+Ny+Oz+Pw}\\\\\\\\\n\\displaystyle\\frac{Ix+Jy+Kz+Lw}{Mx+Ny+Oz+Pw}\\\\\\\\\n1\n\\end{bmatrix}\n⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​Mx+Ny+Oz+PwAx+By+Cz+Dw​Mx+Ny+Oz+PwEx+Fy+Gz+Hw​Mx+Ny+Oz+PwIx+Jy+Kz+Lw​1​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​\n\n可以看到， DDD HHH LLL 会与 www 相乘，从而实现位移\nMMM NNN OOO 会与  xxx yyy zzz 相乘，并加和在 www 分量上\n[ABCEFGIJK]\\begin{bmatrix}\nA &amp; B &amp; C \\\\\nE &amp; F &amp; G \\\\\nI &amp; J &amp; K\n\\end{bmatrix}⎣⎢⎡​AEI​BFJ​CGK​⎦⎥⎤​ 左上角这个矩阵完成旋转\n主对角线完成缩放\n\n齐次坐标的原理\n\nwww 分量所表达的就是比例变换，可以看到图中的 w=1w=1w=1 的时候平移和 w=2w=2w=2 的位移距离完全不一样\n\n将矩阵运算出来的向量分量除以 www ，并将 www 置为1（也可以减去 www 这个维度），这个过程叫做归一化\n\n\n坐标 (x,y,z)的齐次坐标为(wx,wy,wz,w)(x,y,z)\\text{的齐次坐标为}(wx,wy,wz,w)(x,y,z)的齐次坐标为(wx,wy,wz,w)\n我们以三维物体投影到二维平面为例：\n一个 (2,4,3)(2,4,3)(2,4,3) 坐标，映射到 z=5z=5z=5 的平面上\n他的计算过程应该是这样的\n先做归一化 (23,43,1)\\displaystyle (\\frac{2}{3},\\frac{4}{3},1)(32​,34​,1) ，然后再翻到 z=5z=5z=5 的平面 (23×5,43×5,5)=(103,203,5)\\displaystyle (\\frac{2}{3}\\times 5,\\frac{4}{3}\\times 5,5)=(\\frac{10}{3},\\frac{20}{3},5)(32​×5,34​×5,5)=(310​,320​,5) ，最终得到了坐标\n\n","tags":["OpenGL"]},{"title":"ffmpeg-01编译","url":"/2023/10/23/ffmpeg-01%E7%BC%96%E8%AF%91/","content":"gpt 真好用\n\n如果提示没有nasm和yasm\n\n连哪种方案性能更好都说出来了，可以说非常周全了\n当然make install依旧不是必须的，你可以直接将编译出来的文件提取出来，放在你希望的地方\n","tags":["ffmpeg"]},{"title":"OpenGL on Windows 环境","url":"/2023/08/02/OpenGL-on-Windows-%E7%8E%AF%E5%A2%83/","content":"配置glad\nGLAD是一个开源的库，它能解决我们上面提到的那个繁琐的问题。GLAD的配置与大多数的开源库有些许的不同，GLAD使用了一个在线服务。在这里我们能够告诉GLAD需要定义的OpenGL版本，并且根据这个版本加载所有相关的OpenGL函数。\n打开GLAD的在线服务，\n将语言 (Language) 设置为C/C++，\n在 API 选项中，选择 3.3 以上的OpenGL (gl) 版本（我们的教程中将使用 3.3 版本，但更新的版本也能用）。\n之后将模式(Profile)设置为Core，\n并且保证选中了生成加载器(Generate a loader)选项。\n现在可以先（暂时）忽略扩展(Extensions)中的内容。\n都选择完之后，点击生成(Generate)按钮来生成库文件。\n\nGLAD现在应该提供给你了一个 zip压缩文件，\n包含两个头文件目录，和一个glad.c文件。\n\n在你想要的位置新建一个文件夹，比如叫custom_include\n\n将两个头文件目录（glad和KHR）复制到custom_include文件夹中（或者增加一个额外的项目指向这些目录），并添加glad.c文件到你的工程中。\n经过前面的这些步骤之后，你就应该可以将以下的指令加到你的文件顶部了：\n#include &lt;glad/glad.h&gt; \n配置glfw\n\n这个就是不通用的地方了，因为我只会用CMake生成 VS project 的库\n\nglfw是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL_Context、定义窗口参数以及处理用户输入，对我们来说这就够了。\nCMake 编译 glfw 源码\n这一步可以让库保证完整性，还可以完全适配我们的操作系统，毕竟是用我们自己编译器编译的\nglfw 下载链接\n下载源代码之后\n下载 CMake\n我下载的是这个cmake-3.27.0-windows-x86_64.msi\n\n\n选择 Where is the source code 为你下载的 glfw 的地址\n\n\n新建一个 build 文件夹，再选择 Where to build the Binaries\n\n\n\n再点击Configure，选择你自己 VS 版本，其他默认\n \n\n\n再次点击Configure，保存\n \n\n\n点击Generate\n\n\n打开 build 文件夹，build/src/Debug文件夹内就会出现GLFW.sln文件\n\n\n用Visual Studio 2019打开。因为CMake已经配置好了项目，并按照默认配置将其编译为64位的库，所以我们直接点击Build Solution(生成解决方案)按钮，然后在build/src/Debug文件夹内就会出现我们编译出的库文件glfw3.lib。\n\n\n配置 VS\n\n\n创建两个文件夹，用来存放自己定义的 lib 和 include\n我直接在这里创建的 我也推荐在这里创建\n\n\nC:\\Users\\用户名\\source\\custom_includes\nC:\\Users\\用户名\\source\\custom_lib\n把 include 和 lib 放进这俩文件夹里面\n\n\n新建一个 VS 空项目\n\n\n\n将这里改成×64\n\n\n\n设置Library_Directories和Include_Directories\n这里也可以设置环境变量，然后再设置环境变量的名\n\n\n\n设置链接\n添加opengl32.lib（这个库 32 位和 64 位名字居然一样！！！）和glfw3.lib\n\n\n\n这就算配好了\n运行代码\n#include &lt;glad/glad.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow* window);int main() &#123;    glfwInit(); // init glfw    // use version 3.3    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); // set major version    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); // set minor version    glfwWindowHint(GLFW_OPENGL_PROFILE,        GLFW_OPENGL_CORE_PROFILE); // use core profile    GLFWwindow* window = glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, NULL, NULL);   // 800*600 size window called LearnOpenGL    if (window == NULL) &#123;        std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;        glfwTerminate();    // 释放/删除之前的分配的所有资源        return -1;    &#125;    glfwMakeContextCurrent(window);   // set the current window    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123;        std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;        return -1;    &#125;    glViewport(0, 0, 800, 600);    // 设置窗口位置    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);    // 设置窗口大小调整回调    // 循环检查窗口是否需要被关闭    while (!glfwWindowShouldClose(window))&#123;              processInput(window);    // 监控ESC退出窗口        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);     // 调用glClearColor来设置清空屏幕所用的颜色        glClear(GL_COLOR_BUFFER_BIT);    // 调用glClear函数来清空屏幕的颜色缓冲        glfwSwapBuffers(window);    // 函数会交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色值的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。        glfwPollEvents();    // 检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）    &#125;    // 释放/删除之前的分配的所有资源    glfwTerminate();    return 0;&#125;void framebuffer_size_callback(GLFWwindow* window, int width, int height)&#123;    glViewport(0, 0, width, height);&#125;// 监控ESC退出窗口void processInput(GLFWwindow* window)&#123;    if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)        glfwSetWindowShouldClose(window, true);&#125;\n前面两行就是引用的配置好的库\n\n注意两个库的引用顺序，不能反过来！！！\n\n","tags":["OpenGL"]},{"title":"git 的奇怪问题（持续更新）","url":"/2023/07/27/git-%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/","content":"1. kex_exchange_identification: Connection closed by remote host\n这个是你挂了梯子🪜的问题，我尝试了改端口啥的没什么用，就干脆把梯子关了，目前没啥好办法\n同样的，我在这里也提到过类似的问题 部署hexo到github.io的一些小问题 上传 github 报权限问题\n","tags":["git","github"]},{"title":"kotlin 中的 java static","url":"/2025/04/08/java-static-%E5%92%8C-kotlin-%E7%9A%84-object/","content":"java static 的用法\n\n\n静态变量（类变量）\n特点：可以不初始化实例就直接调用；所有实例共享同一内存空间，类加载时初始化，生命周期持续到程序结束。\n示例：统计类实例数量时，可通过静态变量实现全局共享。\nclass Counter &#123;    static int count = 0; // 所有实例共享的计数器    Counter() &#123; count++; &#125;&#125;\n\n\n静态方法\n特点：可以不初始化实例就直接调用；但不能访问非静态成员 （需通过对象引用）。\n典型场景：工具类方法（如数学计算、字符串处理）。\nclass MathUtils &#123;    static int add(int a, int b) &#123; return a + b; &#125; // 工具方法&#125;\n\n\n静态代码块\n作用：类加载时执行一次，相当于在类加载的时候执行的方法体，常用于初始化静态变量或加载资源。\n执行顺序：按代码顺序执行，优先于构造方法。\nclass Database &#123;    static Connection conn;    static &#123;        conn = DriverManager.getConnection(...); // 初始化数据库连接    &#125;&#125;\n\n\n静态内部类\n特点：独立于外部类实例，可直接创建，但仅能访问外部类的静态成员。\n示例：实现嵌套工具类或特定设计模式（如 Builder 模式）。\nclass Outer &#123;    static class Inner &#123; // 静态内部类        void display() &#123; System.out.println(&quot;独立于外部类实例&quot;); &#125;    &#125;&#125;\n\n\n静态导包\n语法：import static java.lang.Math.*;，允许直接调用静态成员而无需类名前缀。\n注意：过度使用可能降低代码可读性。\n\n\nkotlin 中与 static 有关的语法\n包级函数(顶层函数)\nkotlin 允许将函数直接定义到文件中，而不是在 class 内部\n// GlobalFile.ktval hello = &quot;Hello&quot;fun printHello() &#123;    println(hello)&#125;\n反编译成 java\n@Metadata(   // 省略)public final class GlobalFileKt &#123;   @NotNull   private static final String hello = &quot;Hello&quot;;   @NotNull   public static final String getHello() &#123;      return hello;   &#125;   public static final void printHello() &#123;      System.out.println(hello);   &#125;&#125;\n用 java 调用，代码如下：\nGlobalFileKt.getHello();GlobalFileKt.printHello();\n修改生成的类名\nGlobalFileKt 这个名字是由编译器给我生成的，如果想改，可以使用 @file:JvmName(&quot;AAA&quot;)\n@file:JvmName(&quot;AAA&quot;)package org.czbval hello = &quot;Hello&quot;fun printHello() &#123;    println(hello)&#125;\n反编译成 java\npublic final class AAA &#123;   @NotNull   private static final String hello = &quot;Hello&quot;;   @NotNull   public static final String getHello() &#123;      return hello;   &#125;   public static final void printHello() &#123;      System.out.println(hello);   &#125;&#125;\nobject class\nobject class 本身就是声明成单例类，我看看写法\nobject SingleClass &#123;    val hello = &quot;Hello&quot;    fun printHello() &#123;        println(hello)    &#125;&#125;\n反编译成 java\n@Metadata(   // 省略)public final class SingleClass &#123;   @NotNull   public static final SingleClass INSTANCE = new SingleClass();   @NotNull   private static final String hello = &quot;Hello&quot;;   private SingleClass() &#123;   &#125;   @NotNull   public final String getHello() &#123;      return hello;   &#125;   public final void printHello() &#123;      System.out.println(hello);   &#125;&#125;\n用 java 调用，代码如下：\nSingleClass.INSTANCE.getHello();SingleClass.INSTANCE.printHello();\ncompanion object\nclass TestCompanion &#123;    companion object &#123;        var hello = &quot;Hello&quot;        fun printHello() &#123;            println(hello)        &#125;    &#125;&#125;\n反编译成 java\n@Metadata(   // 省略)public final class TestCompanion &#123;   @NotNull   public static final Companion Companion = new Companion((DefaultConstructorMarker)null);   @NotNull   private static String hello = &quot;Hello&quot;;   @Metadata(      // 省略   )   public static final class Companion &#123;      private Companion() &#123;      &#125;      @NotNull      public final String getHello() &#123;         return TestCompanion.hello;      &#125;      public final void setHello(@NotNull String var1) &#123;         Intrinsics.checkNotNullParameter(var1, &quot;&lt;set-?&gt;&quot;);         TestCompanion.hello = var1;      &#125;      public final void printHello() &#123;         System.out.println(this.getHello());      &#125;      // $FF: synthetic method      public Companion(DefaultConstructorMarker $constructor_marker) &#123;         this();      &#125;   &#125;&#125;\n用 java 调用，代码如下：\nTestCompanion.Companion.getHello();TestCompanion.Companion.printHello();\n这个 Companion 其实是一个用内部类实现的单例类\n@JvmStatic\n在半生对象（companion object）或者 object class 里的方法，在声明函数的时候，也只会生成 final 函数，如果我们想生成 static 函数就可以使用 @JvmStatic 了\nclass TestCompanion &#123;    companion object &#123;        var hello = &quot;Hello&quot;        @JvmStatic        fun printHello() &#123;            println(hello)        &#125;    &#125;&#125;\npublic final class TestCompanion &#123;   @NotNull   public static final Companion Companion = new Companion((DefaultConstructorMarker)null);   @NotNull   private static String hello = &quot;Hello&quot;;   @JvmStatic   public static final void printHello() &#123;      Companion.printHello();   &#125;   @Metadata(      // 省略   )   public static final class Companion &#123;      private Companion() &#123;      &#125;      @NotNull      public final String getHello() &#123;         return TestCompanion.hello;      &#125;      public final void setHello(@NotNull String var1) &#123;         Intrinsics.checkNotNullParameter(var1, &quot;&lt;set-?&gt;&quot;);         TestCompanion.hello = var1;      &#125;      @JvmStatic      public final void printHello() &#123;         System.out.println(this.getHello());      &#125;      // $FF: synthetic method      public Companion(DefaultConstructorMarker $constructor_marker) &#123;         this();      &#125;   &#125;&#125;\n","tags":["kotlin","java","static","object"]},{"title":"java ClassLoader 哲学","url":"/2025/04/12/java-ClassLoader-%E5%93%B2%E5%AD%A6/","content":""},{"title":"java并发-线程基础（未完成）","url":"/2023/04/20/java%E5%B9%B6%E5%8F%91-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/","content":"线程的状态\n\n\nNew（新建）\n创建后尚未启动。\n\n\nRunnable（运行）\n可能正在运行，也可能正在等待 CPU 时间片。\n包含了操作系统线程状态中的 Running 和 Ready。\n\n\nBlocking（阻塞）\n等待获取一个排它锁，如果其线程释放了锁就会结束此状态。\n\n\nWaiting（无限期等待）\n没有设置 Timeout 参数的 Object.wait() 方法\n没有设置 Timeout 参数的 Thread.join() 方法\nLockSupport.park() 方法\n\n\nTime-Waiting（限期等待）\n进入一个有期限的等待，时间到了自动被唤醒，或者被中断\n\n调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。\n调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。\n睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。\n阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。\n而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。\n\n\nThread.sleep()\n设置了 Timeout 参数的 Object.wait()\n设置了 Timeout 参数的 Thread.join() 方法\nLockSupport.parkNanos() 方法，参数等待时间\nLockSupport.parkUntil() 方法，参数 deadline\n\n\n\nTerminated\n\n线程自己运行结束\n线程因为触发异常而被结束\n\n\n\n","tags":["线程","Java","Jvm","并发","多线程"]},{"title":"Hello World","url":"/2025/11/18/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\n\n你好\n我好\n\n\nnihao\nwohao\n\n1234567890\nCreate a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n$ hexo server\nMore info: Server\nGenerate static files\n$ hexo generate\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\nMore info: Deployment\n"},{"title":"kotlin data class 解析","url":"/2025/04/25/kotlin-data-class-%E8%A7%A3%E6%9E%90/","content":"官方文档\n\nData classes in Kotlin are primarily used to hold data. For each data class, the compiler automatically generates additional member functions that allow you to print an instance to readable output, compare instances, copy instances, and more. Data classes are marked with data:\nKotlin 中的数据类主要用于保存数据。对于每个数据类，编译器都会自动生成额外的成员函数，允许你将实例打印到可读的输出、比较实例、复制实例等等。数据类以 data 标记：\ndata class User(val name: String, val age: Int)\nThe compiler automatically derives the following members from all properties declared in the primary constructor:\n编译器自动从主构造函数中声明的所有属性派生以下成员：\n\nequals()/hashCode() pair.\nequals() / hashCode() 对。\ntoString() of the form “User(name=John, age=42)”.\n形式为 “User(name=John, age=42)” 的 toString() 。\ncomponentN() functions corresponding to the properties in their order of declaration.\ncomponentN() 函数按声明顺序对应于属性。\ncopy() function (see below).\ncopy() 函数（见下文）。\n\n\n对于这几个函数，值得说的有两个，一个是 componentN() 另一个是 copy()\n我们直接用个例子来看：\ndata class Person(    val name: String,    val age: Int)\n我们反编译成 java 来看看\n@Metadata(   // 省略)public final class Person &#123;   @NotNull   private final String name;   private final int age;   public Person(@NotNull String name, int age) &#123;      Intrinsics.checkNotNullParameter(name, &quot;name&quot;);      super();      this.name = name;      this.age = age;   &#125;   @NotNull   public final String getName() &#123;      return this.name;   &#125;   public final int getAge() &#123;      return this.age;   &#125;   @NotNull   public final String component1() &#123;      return this.name;   &#125;   public final int component2() &#123;      return this.age;   &#125;   @NotNull   public final Person copy(@NotNull String name, int age) &#123;      Intrinsics.checkNotNullParameter(name, &quot;name&quot;);      return new Person(name, age);   &#125;   // $FF: synthetic method   public static Person copy$default(Person var0, String var1, int var2, int var3, Object var4) &#123;      if ((var3 &amp; 1) != 0) &#123;         var1 = var0.name;      &#125;      if ((var3 &amp; 2) != 0) &#123;         var2 = var0.age;      &#125;      return var0.copy(var1, var2);   &#125;   @NotNull   public String toString() &#123;      return &quot;Person(name=&quot; + this.name + &quot;, age=&quot; + this.age + &#x27;)&#x27;;   &#125;   public int hashCode() &#123;      int result = this.name.hashCode();      result = result * 31 + Integer.hashCode(this.age);      return result;   &#125;   public boolean equals(@Nullable Object other) &#123;      if (this == other) &#123;         return true;      &#125; else if (!(other instanceof Person)) &#123;         return false;      &#125; else &#123;         Person var2 = (Person)other;         if (!Intrinsics.areEqual(this.name, var2.name)) &#123;            return false;         &#125; else &#123;            return this.age == var2.age;         &#125;      &#125;   &#125;&#125;\n没想到，反编译出来居然这么长，但是并不复杂\n可以看到，这里面没有默认构造函数（无参构造函数）\ncomponentN\n这个 componentN 居然只是返回了其中的一个对象\n我们来看看如何使用这个函数：\nfun main() &#123;    val (name, age) = Person(&quot;Tom&quot;, 23)    println(&quot;name is $name, age is $age&quot;)&#125;\n此时我们反编译成 java\npublic final class MainKt &#123;   public static final void main() &#123;      Person var0 = new Person(&quot;Tom&quot;, 23);      String name = var0.component1();      int age = var0.component2();      System.out.println(&quot;name is &quot; + name + &quot;, age is &quot; + age);   &#125;   // $FF: synthetic method   public static void main(String[] args) &#123;      main();   &#125;&#125;\n可以看到他就是直接使用 componentN 来返回其中的类成员变量的\ncopy\ncopy() 方法，用于复制当前对象，并允许在复制的同时修改某些属性的值。这是实现不可变对象修改的神器！\n代码如下：\nval p1 = Person(&quot;Tom&quot;, 23)val p2 = Person.copy(age = 24)\n为什么直接使用构造函数呢？\n\n原因一：如果你有很多类成员变量，一一去初始化会很麻烦\n原因二：增强可读性，这样写代码能看出来对象之间的关系，就比如上面代码就是 p2 的年龄比 p1 长 1 岁\n\n","tags":["kotlin","java","static","class","inner"]},{"title":"kotlin 协程-01 delay 函数（没写完）","url":"/2023/10/25/kotlin-%E5%8D%8F%E7%A8%8B-01-delay-%E5%87%BD%E6%95%B0/","content":"读代码困难\n协程代码里有大量的Lambda，我每次看kotlin的Lambda，都有点头疼，但是不能退缩！！！\n看源码\n我们先看这delay函数的定义\n// Delay.ktpublic suspend fun delay(timeMillis: Long) &#123;    if (timeMillis &lt;= 0) return // don&#x27;t delay    return suspendCancellableCoroutine sc@ &#123; cont: CancellableContinuation&lt;Unit&gt; -&gt;        // if timeMillis == Long.MAX_VALUE then just wait forever like awaitCancellation, don&#x27;t schedule.        if (timeMillis &lt; Long.MAX_VALUE) &#123;            cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)        &#125;    &#125;&#125;\n这里返回了一个Lambda，这个Lambda接受一个CancellableContinuation&lt;Unit&gt;，并调用了scheduleResumeAfterDelay方法\n接下我们看看这个Lambda怎么定义的：\n// CancellableCoroutine.ktpublic suspend inline fun &lt;T&gt; suspendCancellableCoroutine(    crossinline block: (CancellableContinuation&lt;T&gt;) -&gt; Unit): T =    suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;        val cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)        /*         * For non-atomic cancellation we setup parent-child relationship immediately         * in case when`block`blocks the current thread (e.g. Rx2 with trampoline scheduler), but         * properly supports cancellation.         */        cancellable.initCancellability()        block(cancellable)        cancellable.getResult()    &#125;\n这个suspendCancellableCoroutine接受了另一个Lambda block，这个block就是上面Delay.kt里面大括号里面的所有代码。\nsuspendCancellableCoroutine通过suspendCoroutineUninterceptedOrReturn方法来执行逻辑\n而且这是一个inline方法，这到不太影响我们来梳理代码逻辑，注意返回值即可\n我们继续看suspendCoroutineUninterceptedOrReturn：\n// Intrinsic.ktpublic suspend inline fun &lt;T&gt; suspendCoroutineUninterceptedOrReturn(    crossinline block: (Continuation&lt;T&gt;) -&gt; Any?): T &#123;    contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125;    throw NotImplementedError(&quot;Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic&quot;)&#125;\n这里我们直接进入了Intrinsic.kt里，说明这里已经到了底层了，就没必要看了，我们继续回到CancellableCoroutine.kt\n我们看到他新建了一个cancellable，然后调用initCancellability，然后执行了block，也就是执行了cancellable.context.delay.scheduleResumeAfterDelay(timeMillis, cancellable)\n前面都是初始化工作，关键就是这个，到此我们观察代码，最终定位到了这里，也就是一开始我们看到的那一点点代码\n\n并且这些定位工作是值得的，他让我们可以放心地去专注于我们的主要逻辑了\n\n我们点进scheduleResumeAfterDelay\n@InternalCoroutinesApipublic interface Delay &#123;\t...\t    public fun scheduleResumeAfterDelay(        timeMillis: Long,        continuation: CancellableContinuation&lt;Unit&gt;    )        ...&#125;\n发现这是一个Interface里的方法\n那么我们就看看这个这个Interface是在哪实现的\n我们进入这个delay\ninternal val CoroutineContext.delay: Delay get() = \tget(ContinuationInterceptor) as? Delay ?: DefaultDelay\n这里是在尝试将get(ContinuationInterceptor)的返回值转成Delay，失败就返回DefaultDelay\n看看这个DefaultDelay\n// DefaultExecutor.kt@PublishedApiinternal actual val DefaultDelay: Delay = initializeDefaultDelay()private fun initializeDefaultDelay(): Delay &#123;    // Opt-out flag    if (!defaultMainDelayOptIn) return DefaultExecutor    val main = Dispatchers.Main    /*     * When we already are working with UI and Main threads, it makes     * no sense to create a separate thread with timer that cannot be controller     * by the UI runtime.     */    return if (main.isMissing() || main !is Delay) DefaultExecutor else main&#125;@Suppress(&quot;PLATFORM_CLASS_MAPPED_TO_KOTLIN&quot;)internal actual object DefaultExecutor : EventLoopImplBase(), Runnable &#123;    ...&#125;\n可以看到，这里返回一个一个Dispacher.Main或者一个DefaultExecutor\n而这个DefaultExecutor继承实现自EventLoopImplBase，Runnable\n而EventLoopImpBase实现了Delay\n// EventLoopCommon.ktinternal abstract class EventLoopImplBase: EventLoopImplPlatform(), Delay &#123;\t...\t  override fun scheduleResumeAfterDelay(timeMillis: Long, continuation: CancellableContinuation&lt;Unit&gt;) &#123;        val timeNanos = delayToNanos(timeMillis)        if (timeNanos &lt; MAX_DELAY_NS) &#123;            val now = nanoTime()            DelayedResumeTask(now + timeNanos, continuation).also &#123; task -&gt;                /*                 * Order is important here: first we schedule the heap and only then                 * publish it to continuation. Otherwise,`DelayedResumeTask`would                 * have to know how to be disposed of even when it wasn&#x27;t scheduled yet.                 */                schedule(now, task)                continuation.disposeOnCancellation(task)            &#125;        &#125;    &#125;    ...&#125;\n.\n"},{"title":"java垃圾回收（GC）（未完成）","url":"/2023/04/19/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89/","content":"\n本文大量引用 GC - Java 垃圾回收基础知识 | Java 全栈知识体系，尤其是到后面直接照抄了，因为根本看不懂。如果有机会一定要去看原文，写的非常好！！！而且很多博客都是抄的这篇文章，并且并未注明出处，当然我也抄的这里。\n\n概述\n\n垃圾回收主要是针对 堆 和 方法区 进行回收\n程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收\n\n引用计数法\n给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。\n引用计数为 0 的对象可被回收。\n两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。\n\n正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。\n\n可达性算法\n\n通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。\n\n\nJava 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容:\n\n虚拟机栈中引用的对象\n本地方法栈中引用的对象\n方法区中类静态属性引用的对象\n方法区中的常量引用的对象\n\n四大引用\n无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。\nJava 具有四种强度不同的引用类型。\n强引用\n被强引用关联的对象不会被回收。\n使用 new 一个新对象的方式来创建强引用。\nObject obj = new Object();\n软引用\n被软引用关联的对象只有在内存不够的情况下才会被回收。\n使用 SoftReference 类来创建软引用。\nObject obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null;  // 使对象只被软引用关联\n弱引用\n被弱引用关联的对象一定会被回收，也就是只要触发 GC ，他就会被回收。\n使用 WeakReference 类来实现弱引用。\nObject obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null;\n虚引用\n又称为幽灵引用或者幻影引用。\n虚引用有两个特点：\n\n无法通过虚引用取得一个对象。\n虚引用必须与 ReferenceQueue 一起使用\n\n\n为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。\n虚引用必须与 ReferenceQueue 一起使用，当 GC 准备回收一个对象，如果发现它还有虚引用，就会在回收之前，把这个虚引用加入到与之关联的 ReferenceQueue 中。\n所以我们就可以监视这个队列来观察这个对象是否被回收\n\n我们写点代码\npublic class PhantomReferenceTest &#123;    static Student[] s = &#123;new Student()&#125;;    public static void main(String[] args) &#123;        ReferenceQueue queue = new ReferenceQueue();        List&lt;byte[]&gt; bytes = new ArrayList&lt;&gt;();        PhantomReference&lt;Student&gt; reference = new PhantomReference&lt;Student&gt;(new Student(), queue);              // 用虚引用来获取对象       System.out.println(reference.get());        // 用来触发 GC        new Thread(() -&gt; &#123;            try &#123;                Thread.sleep(2000);                String s = &quot;asda&quot;+&quot;asda&quot;;                System.gc();            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;).start();        new Thread(() -&gt; &#123;            while (true) &#123;                Reference poll = queue.poll();                if (poll != null) &#123;                    System.out.println(&quot;虚引用被回收了：&quot; + poll);                   break;                &#125;            &#125;        &#125;).start();        Scanner scanner = new Scanner(System.in);        scanner.hasNext();    &#125;&#125;class Student &#123;&#125;\n运行结果：\nnull虚引用被回收了：java.lang.ref.PhantomReference@72ef3cbf\n可以看到，我们确实无法通过虚引用获取对象，返回的是 null\n并且确实 queue 也有了数据\n方法区的回收\n因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。\n主要是对常量池的回收和对类的卸载。\n在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。\n类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载:\n\n该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。\n加载该类的 ClassLoader 已经被回收。\n该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。\n\n可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。\n垃圾回收算法\n标记 - 清除\n\n将存活的对象进行标记，然后清理掉未被标记的对象。\n不足:\n\n标记和清除过程效率都不高；\n会产生大量不连续的内存碎片，导致无法给大对象分配内存。\n\n标记 - 整理\n\n让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n复制\n\n将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。\n主要不足是只使用了内存的一半。\n现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。\nHotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。\n分代收集\n现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。\n一般将堆分为新生代和老年代。\n\n新生代使用: 复制算法\n老年代使用: 标记 - 清除 或者 标记 - 整理 算法\n\n垃圾收集器\n\n以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。\n\n单线程与多线程: 单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；\n串行与并行: 串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并形指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。\n\nSerial 收集器\n\nSerial 翻译为串行，也就是说它以串行的方式执行。\n它是单线程的收集器，只会使用一个线程进行垃圾收集工作。\n它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。\n它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。\nParNew 收集器\n\n它是 Serial 收集器的多线程版本。\n是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。\n默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。\nParallel Scavenge 收集器\n与 ParNew 一样是多线程收集器。\n其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为 “吞吐量优先” 收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。\n停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。\n缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。\n可以通过一个开关参数打开 GC 自适应的调节策略 (GC Ergonomics)，就不需要手动指定新生代的大小 (-Xmn)、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。\nSerial Old 收集器\n\n是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途:\n\n在 JDK 1.5 以及之前版本 (Parallel Old 诞生以前) 中与 Parallel Scavenge 收集器搭配使用。\n作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。\n\nParallel Old 收集器\n\n是 Parallel Scavenge 收集器的老年代版本。\n在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。\nCMS 收集器\n\nCMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。\n分为以下四个流程:\n\n初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。\n并发标记: 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。\n重新标记: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。\n并发清除: 不需要停顿。\n在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。\n\n具有以下缺点:\n\n吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。\n无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。\n标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。\n\nG1 收集器\nG1(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。\n堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。\n\nG1 把堆划分成多个大小相等的独立区域 (Region)，新生代和老年代不再物理隔离。\n\n通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间 (这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。\n每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。\n\n如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤:\n\n\n初始标记\n\n\n并发标记\n\n\n最终标记: 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。\n\n\n筛选回收: 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。\n具备如下特点:\n\n\n空间整合: 整体来看是基于 “标记 - 整理” 算法实现的收集器，从局部 (两个 Region 之间) 上来看是基于 “复制” 算法实现的，这意味着运行期间不会产生内存空间碎片。\n\n\n可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。\n更详细内容请参考: Getting Started with the G1 Garbage Collector\n\n\n内存分配与回收策略\nMinor GC、Major GC、Full GC\nJVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。\n针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）\n部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：\n新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集\n老年代收集（Major GC/Old GC）：只是老年代的垃圾收集\n目前，只有 CMS GC 会有单独收集老年代的行为\n很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收\n混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集\n目前只有 G1 GC 会有这种行为\n整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾\n内存分配策略\n对象优先在 Eden 分配\n大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。\n大对象直接进入老年代\n大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。\n经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。\n-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。\n长期存活的对象进入老年代\n为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。\n-XX:MaxTenuringThreshold 用来定义年龄的阈值。\n动态对象年龄判定\n虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。\n空间分配担保\n在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。\n如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。\nFull GC 的触发条件\n对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件:\n调用 System.gc()\n只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。\n老年代空间不足\n老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。\n为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。\n空间分配担保失败\n使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第五小节。\nJDK 1.7 及以前的永久代空间不足\n在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。\n当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。\n为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。\nConcurrent Mode Failure\n执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足 (可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。\n","tags":["Java","Jvm","引用"]},{"title":"hexo 安装自定义字体的思路","url":"/2023/11/17/hexo-%E5%AE%89%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E7%9A%84%E6%80%9D%E8%B7%AF/","content":"\n  \n    \n      问题\n\n    \n    \n      很多博客自定义字体的时候，都是用的 google fonts 的链接\n但是很多字体 google fonts 里面没有，那我们该怎么办呢？\n\n    \n  \ngoogle fonts 的原理\n我们点开一个链接 Ubuntu mono https://fonts.googleapis.com/css2?family=Ubuntu+Mono&amp;display=swap\n\n可以看到里面就是 css @font-face\n自己模仿写一个\n所以我们只要自己写一个链接，让他打开也是这样的，就可以了\n放置字体\n首先我们将需要的字体放进自己的 source 文件目录下\n\n此时我们只需要一个链接指向该字体就行了\n编写 css 文件\n然后把我们自己的字体放进我这里是自己新建了一个 css 文件夹，可以看到下图的路径栏 source/css/font-meslo.css\n\n编写 css 的时候，最重要的就是这个 url\n我们只要正确编写链接即可，如果你使用的是 github.io 大概率可以从你的仓库查找到这个文件的相对地址，只要前面加上你博客的域名即可\n确认链接正确，我们可以将链接复制到浏览器，看是否会下载\n修改博客配置\nfamily: &#x27;Meslo&#x27;url: https://darkflamemasterdev.github.io/css/font-meslo.css\n同样，我们需要将链接指向对应的文件，这里我们可以通过将连接复制到浏览器进行验证，链接依旧是博客的域名+这个文件的相对地址\n提交修改\nhexo cleanhexo d\n执行提交后，等待博客构建完，应该就可以看到字体更改成功了\n","tags":["hexo","字体","博客","font"]},{"title":"kotlin泛型","url":"/2025/03/24/kotlin%E6%B3%9B%E5%9E%8B/","content":"前言\n学习 kotlin 泛型肯定离不开 java 泛型，这是显而易见的\n很多大佬写过 kotlin 泛型的文章或者出过讲 kotlin 泛型的教程，我深受启发\n所以，我们先学 java 泛型\nJava 泛型\n泛型是什么\n\n一些前提术语\n\n泛型：泛型是 Java 引入的一种参数化类型机制，允许在定义类、接口或方法时使用类型占位符（如 T、E 等），并在调用&gt; 时指定具体类型，从而增强代码的类型安全性和复用性。\n泛型类型：指包含类型参数的类或接口。例如 List&lt;T&gt; 是一个泛型类型，而 List&lt;String&gt; 是其参数化后的具体&gt; 类型。\n泛型类型参数：泛型定义中使用的类型占位符（如 T、K、V 等），用于表示未知的具体类型，在实例化时由开发者指定。\n\n\n泛型类型是一种参数化的类型，比如 List&lt;T&gt; 这个 List 本身是一种类型，但它的泛型类型参数（T）不同，它本身的类型也不同，也就是说 List&lt;String&gt; 和 List&lt;Integer&gt; 就是不同的类型\n当然，我们也不一定非要使用这种套一层的泛型类型，直接使用泛型类型参数 T 就可以，此时泛型类型 等同于 泛型类型参数\n但我们往往都会给泛型类型参数（T）加一个“范围”，或者一个限制，这样方便我们更明确地表示使用泛型类型的意义，比如让 T 作为 List 里的元素，或者让 T 作为 Number 的子类，例子如下：\n&lt;T extends Number&gt; double add(T a, T b) &#123;    return a.doubleValue() + b.doubleValue();&#125;\n泛型类型声明的写法\n\n\n定义泛型类/接口\n将 &lt;T&gt; 写在类名或接口名之后，表示该类/接口接受一个泛型类型参数 T\n// 泛型接口public interface List&lt;T&gt; &#123;    void add(T element);    T get(int index);&#125;// 泛型类public class Box&lt;T&gt; &#123;&#125;\n\n\n定义泛型方法\n将 &lt;T&gt; 写在方法的返回类型之前，表示该方法独立于类的泛型参数，拥有自己的泛型类型 T。\npublic static &lt;T&gt; void printArray(T[] array) &#123;    for (T element : array) &#123;        System.out.println(element);    &#125;&#125;\n\n\n第一个问题：类型擦除\n我们肯定都听过类型擦除，他是实现泛型的原理中的一部分，简单来说就是在编译期间将类型直接打回到声明时的边界类型，在运行时无法识别具体类型是什么\n边界类型\n如果你的泛型类型这么写 &lt;T extends String&gt; 那类型擦除后的就是 String，如果你泛型类型这么写 &lt;String&gt; 那边界类型是 Object\n也就是，有继承关系，边界类型就是继承关系的上界，没有继承关系就是 Object\n\njava 泛型可以多继承？\n\njava 泛型允许多继承，但这其实是一种语法简化，是将 implement 接口也用 extends 了\n比如 &lt;T extends Number &amp; Comparable&lt;? extends T&gt;&gt;，这样的多重边界，选择第一个为边界类型，并且编译器还会给你提示，让你将类作为第一个边界，并且不允许集成多个类\n\n\n\n? extends 和 T extends\n\n\n? extends 是在使用泛型类型的时候，写的\n\n\n一般含有 T 或 E 的都是在定义（声明）泛型类或者泛型函数的时候，写的\n\n\n除非在定义的时候，也存在调用，例如：\nprivate  &lt;E extends Comparable&lt;? super E&gt;&gt; E max(List&lt;? extends E&gt; e1) \n\n\n这里的 Comparable&lt;? super E&gt; 就是调用 E，并非定义\n\n\n\n\n容易混淆的写法\n\n所以编译器的类型擦除，只是在定义泛型类型参数（T）的时候，也就是调用 T extends String 的时候，会将边界&gt; 类型识别为 String ，而 ? extends String 与类型擦除的边界类型无关。这涉及我们后面讲的协变和逆变。\n不用管有些教程里面说的什么上界下界，那是协变逆变里的知识，而且在我看来属于冗余知识，对写代码没什么帮助，而且还&gt; 会迷惑初学者\n你肯定也发现了，T extends String 和 ? extends String 是容易混淆的两个写法，这确实是学习泛型的一个&gt; 难点，而 kotlin 的泛型很好地规避了这点，这在后面讲。\n\n\n类型擦除干了什么\n类型擦除会在编译期间，将泛型类型参数（T）替换成他的边界类型，然后在字节码中插入强制类型转换，并在继承的子类中，为重写（覆盖）方法生成桥方法\n强制类型转换\n\n\n将边界类型再转回声明时的类型\nList&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;hello&quot;);String value0 = list.get(0); // 这里就有字节码插入的强制类型转换\n\n\n返回泛型类型对象时\n开发者需要使用 Class.cast() 进行类型安全转换，try-catch 一下及时处理，而不是直接强制类型转换 (T)obj\n\nClass.cast() 和 (T)obj 的区别\n\n为什么说 Class.cast() 更安全，因为 cast() 会在此方法执行的时候，就抛出 ClassCastException\n而 (T)obj 会在转换完之后，调用的时候抛出异常，这个时间点比 Class.cast() 更晚\n转换的时候不进行异常捕捉，在调用的时候，再抛出异常，这就容易出错\n\n\n\n\n在生成的桥方法中也会有强制类型转换\n\n\n什么是桥方法？\n桥方法是为了避免 java 多态失效的\njava 多态中，有一个方法重写，也就是子类重写父类方法，比如：\nclass Box&lt;T&gt; &#123;    void putIn(T t) &#123;        System.out.println(&quot;我是一个什么都能装的 Box，放入&quot; + t.toString());    &#125;&#125;class StringBox extends Box&lt;String&gt; &#123;    @Override    void putIn(String s) &#123;        System.out.println(&quot;我是一个只能装 String 的 Box，放入&quot; + s);    &#125;&#125;class Box_class &#123;    public static void main(String[] args) &#123;        Box box = new StringBox();        box.putIn(&quot;ABC&quot;);    &#125;&#125;\n\n重写的规则\n\n重写的规则就是，子类的 Override 方法必须要和父类的声明（访问权限修饰符，参数列表，返回类型）完全一致，但内部实现可以重新定义\n因为我们这里使用了泛型，所以 T 和 String 这样是被允许的\n如果参数一个是 Integer 一个是 String 则不被允许\n\n\n上述代码中，StringBox 是 Box 的子类，在声明一个 Box box 但是 new 一个 StringBox 的时候，调用 box.putIn(); 会去实际调用 StringBox 的 putIn() 方法\n但是如果，你在使用泛型，T 会被擦除为 Object ，也就是说，父类变成了 void putIn(Object obj)，此时如果没有桥方法，重写就失效了，因为此时父类方法和子类方法的参数不一样了\n这时候，编译器就是在子类生成一个桥方法，也就是生成一个参数为 Object 的方法，让重写继续生效\nclass StringBox extends Box&lt;String&gt; &#123;    @Override    void putIn(String s) &#123;        System.out.println(&quot;我是一个只能装 String 的 Box，放入&quot; + s);    &#125;    // 编译器生成的桥方法    void putIn(Object obj) &#123;        putIn((String)obj);    &#125;&#125;\n第二个问题：协变和逆变\n接下来我们就使用这三个类的继承关系\n\n搞明白了类型擦除，我们就可以解释为什么 List&lt;Animal&gt; 和 List&lt;Peopple&gt; 是完全不同的类型\n因为 List&lt;Animal&gt; 和 List&lt;People&gt; 在运行时表现为相同的原始类型（List&lt;Object&gt;），但编译器在编译时通过类型擦除和强制转换确保它们无法互换使用，从而维护泛型类型的安全性。运行时的类型擦除不影响编译时对类型一致性的严格检查。\n\n为什么这么设计呢？\n\n这是 java 的有意为之，原因就在于泛型会在编译的时候进行类型擦除之后，导致运行时无法进行类型判断。\n即使使用父类子类进行约束泛型类型参数，也会出现混乱的情况，导致使用泛型类型参数的时候，开发者无法判断出来到是是什么类型。\n在运行时，也无法动态判断类型，导致代码出现不可空的问题\n其实数组其实也有这个问题，但是它就可以在运行时捕捉到异常，导致类型不匹配可以被检测出来，这就变得可控了\n至于为啥数组和泛型要使用不同的设计，这是语言设计开发的考量，并且其中多多少少都有一些历史问题，为了兼容性啊什么之类的。\n\n\n所以 List&lt;Animal&gt; 和 List&lt;People&gt; 在编译器认为，这就不是同种类型，没有任何继承关系\n// 协变 People[] 是 Animal[] 的子类Animal[] animals = new People[10];// 这里会抛出 ArrayStoreException 尝试将错误类型的对象类型存储到对象数组中animals[0] = new Animal(); \n也正是因为泛型使用了类型擦除，很难在运行时捕捉到类型异常，所以干脆直接禁止了协变（参数是子类的泛型类，可以赋值给，参数是父类的泛型类）\n\n为什么使用类型擦除？\n\n既然类型擦除这么不好，为什么要是用类型擦除呢？\n其实也没有很不好，毕竟这样设计避免一些类型安全问题，在编译期间就直接报出类型匹配问题，避免了运行时的类型问题\n\n\n然后为了突破这种限制，java 给了协变和逆变的修饰符 ? super 和 ? extends\n协变（? extends）：参数是子类的泛型类 是 参数是父类的泛型类的 子类\n逆变（? super）：参数是父类的泛型类 是 参数是子类的泛型类的 父类\n注意，这个 super 和 extends 又和 平时在使用类的继承和父类的不一样\n无论是 ? super 还是 ? extends，都是修饰符，语法像 public static\n\n注意区别\n协变逆变并不是改变使用泛型类型参数的功能，而是改变泛型类型本身继承关系的功能，以下代码在不使用协变逆变的时候也会正常编译运行\n\nList&lt;Animal&gt; animalArrayList = new ArrayList&lt;&gt;();animalArrayList.add(new People());animalArrayList.add(new Man());System.out.println(animalArrayList.get(0));System.out.println(animalArrayList.get(1));\n协变\n? extends 的修饰，表示使用协变————类型参数是子类的泛型类型，是此泛型类型的，子类。\n但是这会还有一个限制，你只能用这个泛型类型参数，但不能修改它，也就是只读不写，因为你没法找到一个类型为 ? extends 的变量。\n是的，编译器会直接把类型识别成 ? extends\n\n具体表现在，你不能调用，方法参数里 包含泛型类型参数 的方法。也不能给它 包含类型参数的字段 赋值，除了 null。\n\n以上原因————都是，因为没法填写类型为 ? extends 的参数。\n\n举个例子：\n// 初始化一个 泛型类型参数为 People 的 ArrayListList&lt;People&gt; peopleArrayList = new ArrayList&lt;&gt;();peopleArrayList.add(new People());// 使用 ? extends Animal 就表示所有 泛型类型参数使用 Animal 子类的// 都是参数类型是 ? extends Animal 的泛型类型的子类，所以可以赋值List&lt;? extends Animal&gt; animalList = peopleArrayList;People p = (People) animalList.get(0);System.out.println(p);// 这行会报错 animalList01.add(new People());//                   ^//   方法 List.add(CAP#1)不适用//     (参数不匹配; People无法转换为CAP#1)//   方法 List.add(int,CAP#1)不适用//     (实际参数列表和形式参数列表长度不同)// 其中, CAP#1是新类型变量://   CAP#1从? extends Animal的捕获扩展AnimalanimalList.add(new Man());\n逆变\n逆变有点反直觉\n// 协变List&lt;People&gt; peopleList01 = new ArrayList&lt;&gt;();peopleList01.add(new People());List&lt;? extends Animal&gt; animalList01 = peopleList01;System.out.println(animalList01.get(0));// 逆变List&lt;Animal&gt; animalList02 = new ArrayList&lt;&gt;();List&lt;? super People&gt; peopleList02 = animalList02;peopleList02.add(new People());// 这行会报错 peopleList02.add(new Animal());//                           ^//     方法 List.add(CAP#1)不适用//       (参数不匹配; Animal无法转换为CAP#1)//     方法 List.add(int,CAP#1)不适用//       (实际参数列表和形式参数列表长度不同)//   其中, CAP#1是新类型变量://     CAP#1从? super People的捕获扩展Object 超 PeoplepeopleList02.add(new Animal());// 逆变在知道类型的时候，可以进行读取Animal animal02 = (Animal) peopleList02.get(0);\n逆变用 ? super 修饰，表示类型参数是父类的泛型类型，是此泛型类型的，父类。\n\n逆变不是允许泛型类型参数是父类吗？？？\n\n因为这里确实有个歧义，逆变说的泛型类型参数允许是父类，指的是对于整个泛型类型而言的。\n也就是 List&lt;? super People&gt; 的子类变成了 类型参数为 People 子类的泛型类型。\n而 List&lt;? super People&gt; 还是只允许添加 People 的子类。\n\n\n\n只读不写 vs 只写不读\n\n很多大佬，包括扔物线都说，协变是只允许读不允许写，逆变是只允许写不允许读\n但这种说法不仅仅是不对的，还没有透彻地解释清楚这些限制的由来，而且逆变是可以读的，但是前提是你可以准确判断他的类型是什么。\n在 java 语法中，最起码在我使用的 java17 里面是没有任何问题的（OpenJDK Runtime Environment Temurin-17.0.14+7 (build 17.0.14+7)）\n\n\n总结一下\n\n\n协变逆变只是改变泛型类型本身的子类父类关系，并不影响泛型类型参数的继承关系，使用泛型类型参数的时候，还是只能使用类型参数的子类。\n\n\n协变会增加一些写的限制，这些限制的来源是因为编译器自己在生成了一个类型，一般叫做 CAP#0 或 CAP#1\n之类的，你声明这个类型。\n\n协变里，CAP#1 这个新类型，不允许你初始化它，所以你没办法将这个类型填写到任何地方，并且他的子类也没发用，或者说，它没有继承关系，连 Object 跟他都没关系。\n逆变里，你可以像不使用协变逆变一样读写，但是只能使用当前声明的类型参数的本身或子类。\n\n\n\n\n\n\n&lt;?&gt; 相当于 &lt;? extends Object&gt;\n\n\n泛型数组\n确切的泛型数组是不允许创建的，因为所有的泛型类型，都会被类型擦除，所以就会出现 List&lt;String&gt;[] 和 List&lt;Integer&gt;[] 都会擦除成 List&lt;Object&gt;[]\n但如下代码是被允许的\nList&lt;?&gt;[] lists_0 = new ArrayList[10];List[] lists_1 = new ArrayList[10];\n多个泛型类型参数\njava 允许多个泛型类型参数，比如 HashMap&lt;K,V&gt;，那么我们思考一下，多个泛型参数如何进行协变和逆变呢？\n答案是交集！\n比如你有一个 HashMap&lt;? extends Animal, ? super People&gt; 的对象，那他的子类，必须是第一个参数是 Animal 及其子类，第二个参数是 People 及其父类，这样的才是他的子类，就像这样：\nHashMap&lt;People, Animal&gt; hm = new HashMap&lt;&gt;();HashMap&lt;? extends Animal, ? super People&gt; map = hm;\n到调用的时候，还是，参与协变的类型参数不在继承关系里，没法手动生成，所以没法填进方法参数里；参与逆变的类型参数需要知道具体类型进行强制类型转换。\nOK ！说了这么多，终于要开始对接 Kotlin 泛型了\nKotlin 泛型\n泛型类型的声明写法\n// 泛型接口public interface List&lt;T&gt; &#123;    void add(T element);    T get(int index);&#125;// 泛型类public class Box&lt;T&gt; &#123;&#125;// 泛型函数fun &lt;T&gt; printArray(array: Array&lt;T&gt;) &#123;    for (element in array) &#123;        println(element)    &#125;&#125;\nextends 在 kotlin 里是 :\nfun &lt;T : Number&gt; add(a: T, b: T): Double &#123;    return a.toDouble() + b.toDouble()&#125;\nkotlin 的协变和逆变\n我们还是使用之前的 Animal People\n\njava 的 ? extends 在 kotlin 里变成了 out，? super 在 kotlin 里变成了 in\n这样就会避免了 ? extends 和 T extends 的歧义\n// 协变val peopleArrayList: MutableList&lt;People&gt; = ArrayList()peopleArrayList.add(People())val animalList: MutableList&lt;out Animal&gt; = peopleArrayListval p = animalList[0] as Peopleprintln(p)// 这行会报错，Argument type mismatch: actual // type is &#x27;org.czb.bean.Man&#x27;, but // &#x27;CapturedType(out org.czb.bean.Animal)&#x27; was expected.// 参数类型不匹配：实际类型是 &#x27;org.czb.bean.Man&#x27;，但// &#x27;CapturedType（out org.czb.bean.Animal）&#x27; 是预期的。animalList.add(Man())// 逆变peopleArrayList.clear()val manList: MutableList&lt;in Man&gt; = peopleArrayListmanList.add(Man())val m = manList[0] as Manprintln(m)\n协变这里，说预期的类型是 CapturedType（out org.czb.bean.Animal） ，这和 java 的 CAP#1 是一个意思，这里的参数没法写入，因为这个类型是编译器自己生成的，开发者自己没法生成\n逆变这里，也是和 java 一样，可以读取，但是前提是你必须知道类型，因为返回的是 Any? 类型\n在看一个例子：\nfun &lt;T&gt; consume(list: MutableList&lt;out T&gt;) &#123;    list.add()&#125;\n\n\nout 和 ? extends / in 和 ? super\n\njava 的 ? extends 和 ? super 会给一种，类型参数的继承关系改变的错觉（实际上 ? extends 和 ? super 是将泛型类型的继承关系改变，而不是类型参数）\nkotlin 的 out in 可以避免这种歧义，但泛型类型的继承关系就变的不太明显了\n\n\n\n官方文档的胡言乱语\n\n为了修正这一点，我们必须声明对象的类型为 Source&lt;? extends Object&gt;。这么做毫无意义， 因为我们可以像以前一样在该对象上调用所有相同的方法，所以更复杂的类型并没有带来价值。 但编译器并不知道。\n在 Kotlin 中，有一种方法向编译器解释这种情况。这称为声明处型变： 可以标注 Source 的类型参数 T 来确保它仅从 Source&lt;T&gt; 成员中返回（生产），并从不被消费。 为此请使用 out 修饰符：\n\n\n另外，out 和 in 可以写在声明泛型类或者接口的地方（泛型函数不允许声明），这是 ? extends 和 ? super 做不到的，例如：\n// 协变class Box1&lt;out T&gt; &#123;    // 这行会报错，Type parameter T is declared as &#x27;out&#x27;     // but occurs in &#x27;in&#x27; position in type T    // 类型参数t被声明为“ out”，但在出现在类型 T 的 &#x27;in&#x27; 位置    fun addValue(value: T) &#123;&#125;&#125;// 逆变class Box2&lt;in T&gt; &#123;    // 这行会报错，Type parameter T is declared as &#x27;in&#x27;     // but occurs in &#x27;out&#x27; position in type T    // 类型参数 T 声明为 &#x27;in&#x27;，但出现在类型 T 的 &#x27;out&#x27; 位置    fun getValue(): T &#123;&#125;&#125;\n当你直接将 out 和 in 写在类和接口的声明时，表明你在定义类或者接口的时候，你的意图就是将泛型类型设计成只写不读，或者只读不写。\n这时候的 out 和 in 是 kotlin 的独家语法，并且这个语法要求会更严格\n借助郭霖大佬的一个图\n\n方法参数位置是 in position ，返回值位置是 out position\nkotlin 多类型参数\nkotlin 这里也和 java 保持一致，取交集\nval hm = HashMap&lt;People, Animal&gt;()val map: HashMap&lt;out Animal, in People&gt; = hm\nkotlin 星号投影 &lt;*&gt;\n这是一个比较复杂的东西，首先 &lt;*&gt; 是在调用的写的\n\n\n\n泛型定义\n&lt;*&gt; 代表的含义\n\n\n\n\nMutableList&lt;T&gt;\nMutableList&lt;out Any?&gt;\n\n\nMutableList&lt;T : TUpper&gt;\nMutableList&lt;out TUppper&gt;\n\n\nMutableList&lt;out T&gt;\nMutableList&lt;out Any?&gt;\n\n\nMutableList&lt;out T : TUpper&gt;\nMutableList&lt;out TUppper&gt;\n\n\nMutableList&lt;in T&gt;\nMutableList&lt;in Nothing&gt;\n\n\n\n如果泛型类型具有多个类型参数，则每个类型参数都可以单独投影。 例如，如果类型被声明为 interface Function &lt;in T, out U&gt;，可以使用以下星投影：\n\nFunction&lt;*, String&gt; 表示 Function&lt;in Nothing, String&gt;\nFunction&lt;Int, *&gt; 表示 Function&lt;Int, out Any?&gt;\nFunction&lt;*, *&gt; 表示 Function&lt;in Nothing, out Any?&gt;\n\n不可空的泛型类型\n·要将泛型类型 T 声明为绝对不可空，请使用 &amp; Any 声明该类型。例如： T &amp; Any\n_ 下划线类型推导\n下划线运算符 _ 可用于类型参数。当明确指定其他类型时，使用它来自动推断参数的类型：\nabstract class SomeClass&lt;T&gt; &#123;    abstract fun execute() : T&#125;class SomeImplementation : SomeClass&lt;String&gt;() &#123;    override fun execute(): String = &quot;Test&quot;&#125;class OtherImplementation : SomeClass&lt;Int&gt;() &#123;    override fun execute(): Int = 42&#125;object Runner &#123;    inline fun &lt;reified S: SomeClass&lt;T&gt;, T&gt; run() : T &#123;        return S::class.java.getDeclaredConstructor().newInstance().execute()    &#125;&#125;fun main() &#123;    // T is inferred as String because SomeImplementation derives from SomeClass&lt;String&gt;    val s = Runner.run&lt;SomeImplementation, _&gt;()    assert(s == &quot;Test&quot;)    // T is inferred as Int because OtherImplementation derives from SomeClass&lt;Int&gt;    val n = Runner.run&lt;OtherImplementation, _&gt;()    assert(n == 42)&#125;\n可实例化的泛型类型\n在 java 中泛型类型是无法实例化的，获取泛型类型的 Class 对象 T.class 或者类型转换 a as T 的写法是不被支持的，因为 T 在运行的时候类型就被擦除了，但在 kotlin （或者说其他所有的 JVM 语言）中想实现泛型的实例化就不再是梦了\nkotlin 有内联函数（inline），内联函数会直接把函数体了的代码直接替换到调用位置，并且将参数直接改成实际调用的对象。这也就是 kotlin 将泛型类型实例化的秘密了，当然了，实例化泛型类型参数，还需要一个关键字 reified\ninline fun &lt;reified T&gt; getGenericType() = T::class.java\n附上郭霖大佬在第三行代码里推荐的写启动 Activity 的写法\ninline fun &lt;reified T&gt; startActivity(context: Context, block: Intent.() -&gt; Unit) &#123;    val intent = Intent(context, T::class.java)    intent.block()    context.startActivity(intent)&#125;// 实际调用的时候// 在 Activity 里面startActivity&lt;MainActivity&gt;(this) &#123;    putExtra(&quot;param1&quot;, &quot;data1&quot;)    putExtra(&quot;param2&quot;, &quot;data2&quot;)&#125;\n\n特别强调，得是 inline 函数\n\n","tags":["kotlin","java","泛型","Generic"]},{"title":"test_code","url":"/2025/11/20/test-code/","content":"#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;bool is_leap_year(int year) &#123;    if (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0) &#123;        return true;    &#125;    return false;&#125;"},{"title":"kotlin 内部类","url":"/2025/04/24/kotlin-%E5%86%85%E9%83%A8%E7%B1%BB/","content":"class 嵌套类\n使用 class 会被反编译成 static final class\ninner class 内部类\n使用 inner class 会被反编译成 final class\n结果\nclass InnerClassDemo &#123;    inner class InnerClass &#123;        var hello = &quot;Hello&quot;        fun printHello() &#123;            println(hello)        &#125;    &#125;    class Clazz &#123;        var hello = &quot;Hello&quot;        fun printHello() &#123;            println(hello)        &#125;    &#125;&#125;\n反编译成 java\n@Metadata(   // 省略)public final class InnerClassDemo &#123;   @Metadata(      // 省略   )   public final class InnerClass &#123;      @NotNull      private String hello = &quot;Hello&quot;;      @NotNull      public final String getHello() &#123;         return this.hello;      &#125;      public final void setHello(@NotNull String var1) &#123;         Intrinsics.checkNotNullParameter(var1, &quot;&lt;set-?&gt;&quot;);         this.hello = var1;      &#125;      public final void printHello() &#123;         System.out.println(this.hello);      &#125;   &#125;   @Metadata(      // 省略   )   public static final class Clazz &#123;      @NotNull      private String hello = &quot;Hello&quot;;      @NotNull      public final String getHello() &#123;         return this.hello;      &#125;      public final void setHello(@NotNull String var1) &#123;         Intrinsics.checkNotNullParameter(var1, &quot;&lt;set-?&gt;&quot;);         this.hello = var1;      &#125;      public final void printHello() &#123;         System.out.println(this.hello);      &#125;   &#125;&#125;","tags":["kotlin","java","static","class","inner"]},{"title":"kotlin 的 ::class.java 和 .javaClass","url":"/2025/03/18/kotlin-%E7%9A%84-class-java-%E5%92%8C-javaClass/","content":"\n\n\n\n特性\nKotlin\nJava\n用途\n\n\n\n\n静态类引用\nSomeClass::class.java\nSomeClass.class\n获取类的 Class 对象（编译时类型）\n\n\n实例类引用\ninstance.javaClass\ninstance.getClass()\n获取实例的运行时类对象（可能被子类覆盖）\n\n\nKotlin 类引用\nSomeClass::class（返回 KClass）\n无等价概念\n获取 Kotlin 的类元数据（KClass）\n\n\nKotlin 类引用\nSomeClass::class（返回 KClass）\n无等价概念\n获取 Kotlin 的类元数据（KClass）\n\n\nKotlin 类引用\nSomeClass::class（返回 KClass）\n无等价概念\n获取 Kotlin 的类元数据（KClass）\n\n\n\n","tags":["kotlin","Class","KClass"]},{"title":"test_img","url":"/2025/11/20/test-img/","content":""},{"title":"test-math","url":"/2025/11/20/test-math/","content":"这里是行内公式：a2+b2=c2a^2 + b^2 = c^2a2+b2=c2\n这里是块级公式：\n−b±b2−4ac2a\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}\n2a−b±b2−4ac​​\nTrans⋅Scale=[1001010200130001]⋅[2000020000200001]=[2001020200230001]Trans \\cdot Scale =\n\\begin{bmatrix}\n\\color{red}1 &amp; \\color{red}0 &amp; \\color{red}0 &amp; \\color{red}1 \\\\\n\\color{green}0 &amp; \\color{green}1 &amp; \\color{green}0 &amp; \\color{green}2 \\\\\n\\color{blue}0 &amp; \\color{blue}0 &amp; \\color{blue}1 &amp; \\color{blue}3 \\\\\n\\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}1\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix} \\color{red}2 &amp; \\color{red}0 &amp; \\color{red}0 &amp; \\color{red}0 \\\\\n\\color{green}0 &amp; \\color{green}2 &amp; \\color{green}0 &amp; \\color{green}0 \\\\\n\\color{blue}0 &amp; \\color{blue}0 &amp; \\color{blue}2 &amp; \\color{blue}0 \\\\\n\\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\color{red}2 &amp; \\color{red}0 &amp; \\color{red}0 &amp; \\color{red}1 \\\\\n\\color{green}0 &amp; \\color{green}2 &amp; \\color{green}0 &amp; \\color{green}2 \\\\\n\\color{blue}0 &amp; \\color{blue}0 &amp; \\color{blue}2 &amp; \\color{blue}3 \\\\\n\\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}0 &amp; \\color{purple}1\n\\end{bmatrix}\nTrans⋅Scale=⎣⎢⎢⎢⎡​1000​0100​0010​1231​⎦⎥⎥⎥⎤​⋅⎣⎢⎢⎢⎡​2000​0200​0020​0001​⎦⎥⎥⎥⎤​=⎣⎢⎢⎢⎡​2000​0200​0020​1231​⎦⎥⎥⎥⎤​\n"},{"title":"test_table","url":"/2025/11/20/test-table/","content":"\n\n\na\na\na\ns\ns\ns\ns\ns\n\n\n\n\naasdadadadadasd\nasasdasdsadadsadd\nasasdadsadadas\nasdasasdadsaddasd\nasdasdadsadadasd\nasdasdadadadadsad\nasasdadadsadada\nasasdadsadadadd\n\n\n\n\n\n\na\na\na\ns\n\n\n\n\naasdadadadadasd\nasasdasdsadadsadd\nasasdadsadadas\nasdasasdadsaddasd\n\n\n\n"},{"title":"关于学习新技术的个人看法（持续更新）","url":"/2025/02/27/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0%E6%96%B0%E6%8A%80%E6%9C%AF%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%9C%8B%E6%B3%95/","content":"综述\n我其实不是一个特别厉害的代码高手，本篇只是写一下我自己学习技术的一些习惯和思考\n我所说的技术，更多的是指一些抽象的技术，比如：多线程，编译原理，跨平台…\n详细内容\n1. 了解背景\n什么是了解背景？\n了解一项技术的背景，就是它的由来，他一开始是用来干嘛的，现在是用来干嘛的，这期间有哪些改变…这是你应该优先去做的事情\n为什么要了解背景？\n\n因为了解背景有很多有优点：了解背景能让 你更全局地审视一门技术，能让你能更有方向地去探索这门技术，也能让你在快速地找到学习的方向、纠正错误的思路，更能提高你掌握一门技术的效率\n除了优点，在基于当下的互联网编程氛围，了解背景更有必要，因为很多人轻视了解背景这个步骤，他们甚至觉得了解背景没什么用，所以对于一个新手，你会被他们带入这辆“没准备好就仓促登上的列车”。\n\n这篇文章其实我想写其实就是因为想强调了解背景在学习技术的重要性————这是根植在我内心的想法\n那为什么之前不写呢？\n因为今天我挺喜欢的一个 B站up主 TheCW 发了一个视频，一下子就戳中了我的点，讲的是 Flutter\n跨平台开发该不该用Flutter？2023年版Flutter全面解析\n2.学习的本质在于摸透底层逻辑\n这个事情最准确最直接的例子是健身中的肌肉增长\n如果你希望肌肉增长，底层逻辑在于————肌纤维断裂，然后再重新长好\n围绕这个底层逻辑，我们可以去探究————肌纤维断裂到什么程度？肌纤维生长周期是多少？饮食上注意哪些可以促进肌纤维恢复？参与哪些运动会让让哪些肌纤维断裂？\n然后再围绕之后得到的答案，再去探究————不同姿势会怎样促进肌纤维断裂？大重量少次和小重量多次对肌肉的影响？如何让自己的运动状态更好，效率更高？肌纤维断裂会引起哪些问题，该如何规避或者解决？\n然后再去探究蛋白粉如何更有性价比…这样一系列的问题都像一棵树木一样，长得枝繁叶茂，并且联系紧密，印象深刻，甚至会让你养成良好的思考学习习惯，影响到你在做其他事情的方式方法和效率。\n\n  \n    \n      底层逻辑的地位\n\n    \n    \n      所以底层逻辑就是一个大树的根部，你在思考所有问题的时候，就会无意间思考到底层逻辑，就像树木的养分会从根部流向各个树枝一样，你在思考运动的标准姿势的时候，也在考虑肌纤维断裂和长好；你在思考和哪个牌子的蛋白粉也是在思考哪个牌子的蛋白粉可以更有性价比地辅助断裂的肌纤维增长\n\n    \n  \n当然，事情说到这里，其实已然足够了，我不是想说懂的人自然懂这类抽象话，但确实找到大树的根部（底层逻辑）就和高中最难的数学物理一样，需要非常强的抽象思维和具体思维，既要能精准地总结概括，也要能随时展开。\n\n  \n    对于程序员，阅读源码，理解设计模式，了解技术发展历程，多看别人写的代码，多尝试，多总结，这就是去尝试摸透底层逻辑的好办法\n\n  \n在学习过程中，多去思考这么做的目的，原因，发展的历史，或许会对于你摸透底层逻辑有帮助\n","tags":["思考"]},{"title":"力扣11：盛最多水的容器","url":"/2023/04/18/%E5%8A%9B%E6%89%A311%EF%BC%9A%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","content":"题目\n给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。\n找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n返回容器可以储存的最大水量。\n说明：你不能倾斜容器。\n示例一\n\n\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49\n解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n\n示例二\n\n输入：height = [1,1]\n输出：1\n\n提示\n\nn == height.length\n2 &lt;= n &lt;= 105\n0 &lt;= height[i] &lt;= 104\n\n分析\n输入一个数组 height[] ，找两个数 height[i] 和 height[j]， i &lt; j ，返回 (j - i) * minOf(height[i], height[j])\n我们可以使用双指针（一左一右），并每次都移动小的那个指针，即可，因为只有移动小的指针，才可能会比现在的结果大。\n\n举个例子：[1, *, *, *, *, *, *, *, 7]\n我们在计算出 1,7 这两个数的结果 (7-1) * minOf(1,7) = 6 后，如果想要找更大的结果，只能移动将指向 1 的指针向右移动，因为无论移动那个指针都会缩短两指针之间的距离，而结果是两部分的乘积，所以需要将 minOf(1,7) 变大，只有将最小值变大 minOf() 才会变大\n相反，如果是 [6, *, *, *, *, *, *, *, 2] ，肯定就是移动指向 2 的指针，因为此时 改变 2 才有可能将 minOf() 变大\n\n代码\n然后我们的代码就是\nclass Solution &#123;    fun maxArea(height: IntArray): Int &#123;        var left = 0        var right = height.size - 1        var areaMax = 0        var areaNow: Int        var needMove: Int        while (right &gt; left) &#123;            needMove = minOf(height[left], height[right])            areaNow = minOf(height[left], height[right]) * (right - left)            if (areaNow &gt; areaMax) &#123;                areaMax = areaNow            &#125;            if (height[right] == needMove) &#123;                right--            &#125; else &#123;                left++            &#125;        &#125;        return areaMax    &#125;&#125;\n复杂度分析\n时间复杂度为 O(n)，空间复杂度为 O(1)\n总结\n这种题其实不难，只是算法不经常练，所以才会导致没有办法在短时间内做出来，所以算法还得靠积累总结，当然最重要的多练！！！\n","tags":["算法","力扣","leetcode"]},{"title":"优秀代码-01减少括号嵌套","url":"/2023/10/14/%E4%BC%98%E7%A7%80%E4%BB%A3%E7%A0%81-01%E5%87%8F%E5%B0%91%E6%8B%AC%E5%8F%B7%E5%B5%8C%E5%A5%97/","content":"前言\n这是我新起的一个系列，目的地总结一下写出优秀代码的方法。\n大家都知道，代码如果括号嵌套太多了，会影响代码的可读性和扩展性，这次就总结一些代码中减少嵌套的一些方法\n第一个例子\nfun test1(condition1: Boolean, condition2: Boolean, condition3: Boolean) &#123;  if (obj != null) &#123;    if (condition1) &#123;      while (true) &#123;        if (condition2) &#123;          if (condition3) &#123;          &#125;        &#125;      &#125;    &#125;  &#125; else &#123;    throw NullPointerException(&quot;obj is Null&quot;)  &#125;&#125;\n上面这个函数，下面一下子放了 6 层括号，已经很复杂了，我们可以进行如下更改\nfun test2(condition1: Boolean, condition2: Boolean, condition3: Boolean) &#123;  if (obj == null) &#123;    throw NullPointerException(&quot;obj is Null&quot;)  &#125;  if (!condition1) &#123;    return  &#125;  while (true) &#123;    if (!condition2) &#123;      continue    &#125;    if (condition3) &#123;    &#125;  &#125;&#125;\n\n\n提前抛异常\n我们在 obj = null 的时候，直接抛出异常，减少了一个 else 括号\n\n\n提前返回（Early Return）\n我们直接让在不满足 condition1 的情况下，直接返回。\n这样，我么就可以将满足 condition1 的情况直接拿出来，从而减少了一层嵌套。\n\n\n提前跳出循环\n我们遇到不满足 condition2 的情况，直接跳过本次循环，将满足 condition2 的情况拿了出来，从而减少了一层嵌套\n\n\n第二个例子\nfun onClick(v: View) &#123;  val id: Int = v.getId()  if (id == R.id.button1) &#123;    startActivity(Intent(this, StandardActivity::class.java))  &#125; else if (id == R.id.button2) &#123;    startActivity(Intent(this, SingleTopActivity::class.java))  &#125; else if (id == R.id.button3) &#123;    startActivity(Intent(this, SingleTaskActivity::class.java))  &#125; else if (id == R.id.button4) &#123;    startActivity(Intent(this, SingleInstanceActivity::class.java))  &#125; else if (id == R.id.button4) &#123;    startActivity(Intent(this, SingleInstanceActivity::class.java))  &#125; else if (id == R.id.button5) &#123;    startActivity(Intent(this, SingleTopActivity.SingleTopActivity1::class.java))  &#125; else if (id == R.id.button6) &#123;    startActivity(Intent(this, SingleTopActivity.SingleTopActivity2::class.java))  &#125; else if (id == R.id.button7) &#123;    startActivity(Intent(this, SingleTopActivity.SingleTopActivity3::class.java))  &#125; else if (id == R.id.button8) &#123;    startActivity(Intent(this, SingleTopActivity.SingleTopActivity4::class.java))  &#125; else if (id == R.id.button9) &#123;    startActivity(Intent(this, SingleTopActivity.SingleTopActivity5::class.java))  &#125; else if (id == R.id.button10) &#123;    startActivity(Intent(this, SingleTaskActivity.SingleTaskActivity1::class.java))  &#125; else if (id == R.id.button11) &#123;    startActivity(Intent(this, SingleTaskActivity.SingleTaskActivity2::class.java))  &#125; else if (id == R.id.button12) &#123;    startActivity(Intent(this, SingleTaskActivity.SingleTaskActivity3::class.java))  &#125; else if (id == R.id.button13) &#123;    startActivity(Intent(this, SingleTaskActivity.SingleTaskActivity4::class.java))  &#125;&#125;\n上述代码用了大量if-else\n并且都是判断id的，这种键值对判断，我们就可以改用switch-case，kotlin里用的是when，或者用map\nfun onClick(v: View) &#123;  val id: Int = v.getId()  when (id) &#123;    R.id.button1 -&gt; &#123;      startActivity(Intent(this, StandardActivity::class.java))    &#125;    R.id.button2 -&gt; &#123;      startActivity(Intent(this, SingleTopActivity::class.java))    &#125;    R.id.button3 -&gt; &#123;      startActivity(Intent(this, SingleTaskActivity::class.java))    &#125;    R.id.button4 -&gt; &#123;      startActivity(Intent(this, SingleInstanceActivity::class.java))    &#125;    R.id.button4 -&gt; &#123;      startActivity(Intent(this, SingleInstanceActivity::class.java))    &#125;    R.id.button5 -&gt; &#123;      startActivity(Intent(this, SingleTopActivity.SingleTopActivity1::class.java))    &#125;    R.id.button6 -&gt; &#123;      startActivity(Intent(this, SingleTopActivity.SingleTopActivity2::class.java))    &#125;    R.id.button7 -&gt; &#123;      startActivity(Intent(this, SingleTopActivity.SingleTopActivity3::class.java))    &#125;    R.id.button8 -&gt; &#123;      startActivity(Intent(this, SingleTopActivity.SingleTopActivity4::class.java))    &#125;    R.id.button9 -&gt; &#123;      startActivity(Intent(this, SingleTopActivity.SingleTopActivity5::class.java))    &#125;    R.id.button10 -&gt; &#123;      startActivity(Intent(this, SingleTaskActivity.SingleTaskActivity1::class.java))    &#125;    R.id.button11 -&gt; &#123;      startActivity(Intent(this, SingleTaskActivity.SingleTaskActivity2::class.java))    &#125;    R.id.button12 -&gt; &#123;      startActivity(Intent(this, SingleTaskActivity.SingleTaskActivity3::class.java))    &#125;    R.id.button13 -&gt; &#123;      startActivity(Intent(this, SingleTaskActivity.SingleTaskActivity4::class.java))    &#125;  &#125;&#125;\nval classMap = HashMap&lt;Int, Class&lt;out FragmentActivity&gt;&gt;().apply &#123;  put(R.id.button1, StandardActivity.class)  put(R.id.button2, SingleTopActivity.class)  put(R.id.button3, SingleTaskActivity.class)  put(R.id.button4, SingleInstanceActivity.class)  put(R.id.button5, SingleTopActivity.SingleTopActivity1.class)  put(R.id.button6, SingleTopActivity.SingleTopActivity2.class)  put(R.id.button7, SingleTopActivity.SingleTopActivity3.class)  put(R.id.button8, SingleTopActivity.SingleTopActivity4.class)  put(R.id.button9, SingleTopActivity.SingleTopActivity5.class)  put(R.id.button10, SingleTaskActivity.SingleTaskActivity1.class)  put(R.id.button11, SingleTaskActivity.SingleTaskActivity2.class)  put(R.id.button12, SingleTaskActivity.SingleTaskActivity3.class)  put(R.id.button13, SingleTaskActivity.SingleTaskActivity4.class)&#125;override fun onClick(v: View) &#123;  startActivity(Intent(this, classMap[v.id]))&#125;\n\nps：我推荐一个jetbrains插件，叫Better Highlights，他其中一个免费功能就是帮你检查方法的复杂度\n\n"},{"title":"力扣42 接雨水 （力扣11 盛最多水的容器 扩展）","url":"/2023/04/18/%E5%8A%9B%E6%89%A342%EF%BC%9A%E6%8E%A5%E9%9B%A8%E6%B0%B4%EF%BC%88%E5%8A%9B%E6%89%A311-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8-%E6%89%A9%E5%B1%95%EF%BC%89/","content":"题目\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n示例 1\n  \n\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。\n\n示例 2\n\n输入：height = [4,2,0,3,2,5]\n输出：9\n\n提示\n\nn == height.length\n1 &lt;= n &lt;= 2 * 104\n0 &lt;= height[i] &lt;= 105\n\n分析\n和 上一题 相比，这一题要求考虑柱子整体的排列规律\n而对于单个柱子能放下多少水，需要考虑左边最大柱子和右边最大柱子 中较小的那个，减去当前柱子的高度，也就是这样\n\n图可见，绿色柱子是由两个红柱子挡起来的，并且绿柱子位置是两个红柱子较小的那个高度决定的\n由此我们就可以编写代码\n记录下每个柱子的左边最高柱子和右边最高柱子，再遍历数组进行减法即可\n// i 位置的左边最高柱子，要么左临元素的左边最高柱子，要么是他自己// i 位置的右边最高柱子，要么右临元素的左边最高柱子，要么是他自己lMax[i] = maxOf(lMax[i - 1], height[i])rMax[i] = maxOf(rMax[i + 1], height[i])\n\n为什么要考虑他自己呢？\n因为最高的柱子如果不考虑自己，minOf(lMax,rMax) - height 就会是负值\n所以我们编码如下\n\n代码\n第一种\nclass Solution &#123;    fun trap(height: IntArray): Int &#123;        val lMax = IntArray(height.size)        val rMax = IntArray(height.size)        lMax[0] = height[0]        rMax[height.lastIndex] = height[height.lastIndex]        var left:Int        var right:Int        for (i in 1..height.lastIndex) &#123;            left = i            right = height.lastIndex - i            lMax[left] = maxOf(lMax[left - 1], height[left])            rMax[right] = maxOf(rMax[right + 1], height[right])        &#125;        var count = 0        for (i in height.indices) &#123;            count += (minOf(rMax[i], lMax[i]) - height[i])            println(count)        &#125;    &#125;&#125;\n这个时间复杂度是 O(n) ，空间复杂度是 O(n)\n优化后\n其实我们不需要确定两个最大值，只需确定一个最大值，并且另一个最大值一定比这个大，就可以了\n举个例子，我们知道一个柱子 lMax 是 2 ，而不知道 rMax，但是知道 rMax 肯定 &gt;=2 ，所以 minOf(lMax,rMax) 的结果就已经可以确定了\n这样我们就可以将记录 lMax rMax 的数组空间节省出来，并且立刻算出结果，不用最后再遍历一遍了\nclass Solution &#123;    fun trap(height: IntArray): Int &#123;        if (height.size &lt;= 2) &#123;            return 0        &#125;        var lM = 0        var rM = 0        var left = 0        var right = height.lastIndex        var count = 0        while (left &lt; right) &#123;            lM = maxOf(lM, height[left])            rM = maxOf(rM, height[right])            if (lM &lt; rM) &#123;                count += lM - height[left]                left++            &#125; else &#123;                count += rM - height[right]                right--            &#125;        &#125;        return count    &#125;&#125;\n这个时间复杂度是 O(n) ，空间复杂度是 O(1)\n总结\n没有总结\n","tags":["算法","力扣","leetcode"]},{"title":"学习 MakeFile [02] 初探 Makefile","url":"/2024/11/25/%E5%AD%A6%E4%B9%A0-MakeFile-02-%E5%88%9D%E6%8E%A2Makefile/","content":"\n本文主要参考了 跟我一起写 Makefile，甚至有一些是直接复制的，原因有三：\n\n因为我有一些自己见解浅薄的\n还有一些确实原文章作者写的很好了，但是不写出来又不完整的。\n\n\n前言\n其实我不太知道要咋写 Makefile 这篇文章，感觉可能会变成翻译官方文档\n所以…就随心写吧\n从一个例子开始\n首先我们得知道 Makefile 的规则\ntarget ... : prerequisites ...    recipe （命令）    ...    ...\n\n\ntarget\n可以是一个object file（目标文件），也可以是一个可执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的“伪目标”章节中会有叙述。\n\n\nprerequisites\n生成该target所依赖的文件和/或target。\n\n\nrecipe\n该target要执行的命令（任意的shell命令）。\n\n\n带着这个规则我们看看个官方的例子：\nedit : main.o kbd.o command.o display.o \\        insert.o search.o files.o utils.o    cc -o edit main.o kbd.o command.o display.o \\        insert.o search.o files.o utils.omain.o : main.c defs.h    cc -c main.ckbd.o : kbd.c defs.h command.h    cc -c kbd.ccommand.o : command.c defs.h command.h    cc -c command.cdisplay.o : display.c defs.h buffer.h    cc -c display.cinsert.o : insert.c defs.h buffer.h    cc -c insert.csearch.o : search.c defs.h buffer.h    cc -c search.cfiles.o : files.c defs.h buffer.h command.h    cc -c files.cutils.o : utils.c defs.h    cc -c utils.cclean :    rm edit main.o kbd.o command.o display.o \\        insert.o search.o files.o utils.o\n\n  \n    \n      注意事项\n\n    \n    \n      Makefile 的缩进都需要使用 tab 而不是 space 空格\n由于本文章是用 Markdown 写的所以可能会出现缩进使用空格的情况，如需复制请自己更改一下）\n\n    \n  \n这是一个简单的 Makefile\n\n\n其中第一行：edit 为 target，也就是生成的目标\n另外所有的冒号前面的都是 target，只不过由于 edit 在第一行，所以就成为了最终生成的目标\n\n\n这里 clean 是伪目标，伪目标只是长得像目标，并不应该生成一个叫 clean 的文件，他的目的是执行下一行的命令，就比如 rm ，在命令行输入 make clean 调用它。\n\n  \n    \n      关于伪目标\n\n    \n    \n      区分目标和伪目标，我们可以写上 .IPHONY : clean ，这样就相当于直接告诉 make clean 并不是需要输出文件的目标\n我认为，伪目标是一个很奇怪的规则，他完全可以使用其他的语法，这样设计出一个和目标差不多的东西，会 Makefile 新手感到疑惑，最起码我是这样的\n\n    \n  \n\n\n\\ 表示换行\n\n\ntarget : 后面是依赖\n\n\n基于上面的规则，我们到该就能明白，makefile 是一个逐步寻找依赖进行编译的文件\n比如 edit 依赖于后面的 .o 文件，而下面写了众多 .o 文件依赖于哪些 .c 和 .h 文件，这样在执行 make 命令的时候，就会像调用方法栈一样，一步步找到最开始需要编译的文件，然后出栈，最后调用完输出结果\n\n\nmake 如何工作\n在命令行中输入 make 命令，工作流程如下：\n\nmake会在当前目录下找名字叫“Makefile”或“makefile”的文件。\n如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。\n如果edit文件不存在，或是 edit 所依赖的后面的 .o 文件的文件修改时间要比 edit 这个文件新，那么，他就会执行后面所定义的命令来生成 edit 这个文件。\n如果 edit 所依赖的 .o 文件也不存在，那么 make 会在当前文件中找目标为 .o 文件的依赖性，如果找到则再根据那一个规则生成 .o 文件。\n你的 .c 文件和 .h 文件是存在的啦，于是 make 会生成 .o 文件，然后再用 .o 文件生成 make 的终极任务，也就是可执行文件 edit 了。\n\n\n  \n    第 4 步和第 5 步的工作流程就像方法栈一样\n\n  \n使用变量\n在上面的例子中，有些地方是大量重复的，此时我们就可以跟写代码一样，使用变量\n就比如我们可以设置一个名为 objects 的变量，让他代替所有的 .o 文件\nobjects = main.o kbd.o command.o display.o \\    insert.o search.o files.o utils.oedit : $&#123;objects&#125;    cc -o edit $&#123;objects&#125;main.o : main.c defs.h    cc -c main.ckbd.o : kbd.c defs.h command.h    cc -c kbd.ccommand.o : command.c defs.h command.h    cc -c command.cdisplay.o : display.c defs.h buffer.h    cc -c display.cinsert.o : insert.c defs.h buffer.h    cc -c insert.csearch.o : search.c defs.h buffer.h    cc -c search.cfiles.o : files.c defs.h buffer.h command.h    cc -c files.cutils.o : utils.c defs.h    cc -c utils.cclean :    rm edit $&#123;objects&#125;\n\n  \n    \n      这么做的好处\n\n    \n    \n      这么做的好处是显而易见的\n如果出现其他的 .o 文件，只用改定义处就可以了\n\n    \n  \nmake 自动推导\nmake 是一个智能的工具，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个 .o 文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。\n所以我们只保留依赖关系即可 Makefile 就可以改成这样\nobjects = main.o kbd.o command.o display.o \\    insert.o search.o files.o utils.oedit : $(objects)    cc -o edit $(objects)main.o : defs.hkbd.o : defs.h command.hcommand.o : defs.h command.hdisplay.o : defs.h buffer.hinsert.o : defs.h buffer.hsearch.o : defs.h buffer.hfiles.o : defs.h buffer.h command.hutils.o : defs.h.PHONY : cleanclean :    rm edit $(objects)\n更精简的 Makefile 自动推导文件\nMakefile 还提供了自动推导文件的功能，我们要生成 main.o 他会自动识别出来 依赖项为 main.c 或者 main.cpp\nobjects = main.o kbd.o command.o display.o \\    insert.o search.o files.o utils.oedit : $(objects)    cc -o edit $(objects)$(objects) : defs.hkbd.o command.o files.o : command.hdisplay.o insert.o search.o files.o : buffer.h.PHONY : cleanclean :    rm edit $(objects)\n\n第 7 行 .o 文件对应着 .c 文件，并且所有的 .o 文件都需要依赖于 defs.h\n第 8 行 kbd.o command.o files.o 这三个文件除了依赖于名字相同的 .c 文件，大家都依赖的 defs.h 文件，还会依赖 command.h 文件\n第 9 行 display.o insert.o search.o files.o 这三个文件除了依赖于名字相同的 .c 文件，大家都依赖的 defs.h 文件，还会依赖 buffer.h 文件\n\n\n  \n    \n      对于这种方式的评价\n\n    \n    \n      这种方式里面套的逻辑关系会更多，所以耦合更多，可读性差一些，如果要修改文件结构，则会很麻烦，而且 Makefile 并不是经常需要修改的文件，写的精简但是可读性差有点得不偿失\n\n    \n  \n伪目标（以 clean 为例）\n前面简答提到过伪目标，我们这里再总结一下\n伪目标是一个为了执行某些命令而写的东西，看着像目标，但实际上并不需要生成任何文件\n这种有些迷惑性的规则确实让很多新手小白困惑，因为你可以定义很多你需要的命令，比如你可以定义一个 make ql 的命令，只需要如下定义：\nql :    rm edit *.o\n可以想象，如果 Makefile 变大之后，就很难将 Makefile 里的目标和伪目标区分清楚\n所以，我们可以使用 .PHONY 来标明哪些是伪目标，并且将所有的伪目标写到一起。\n包含其他 Makefile\n在Makefile使用 include 指令可以把别的Makefile包含进来，这很像C语言的 #include ，被包含的文件会原模原样的放在当前文件的包含位置。 include 的语法是：\ninclude &lt;filenames or pathname&gt;...\n在 include 前面可以有一些空字符，但是绝不能是 Tab 键开始。 include 和 &lt;filenames&gt; 可以用一个或多个空格隔开。举个例子，你有这样几个 Makefile： a.mk 、 b.mk 、 c.mk ，还有一个文件叫 foo.make ，以及一个变量 $(bar) ，其包含了 bish 和 bash ，那么，下面的语句：\ninclude foo.make *.mk $(bar)\n等价于：\ninclude foo.make a.mk b.mk c.mk bish bash\nmake命令开始时，会找寻 include 所指出的其它 Makefile，并把其内容安置在当前的位置。就好像C/C++的 #include 指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：\n如果 make 执行时，有 -I 或 --include-dir 参数，那么make就会在这个参数所指定的目录下去寻找。\n接下来按顺序寻找目录 &lt;prefix&gt;/include （一般是 /usr/local/bin ）、 /usr/gnu/include 、 /usr/local/include 、 /usr/include 。\n环境变量 .INCLUDE_DIRS 包含当前 make 会寻找的目录列表。你应当避免使用命令行参数 -I 来寻找以上这些默认目录，否则会使得 make “忘掉”所有已经设定的包含目录，包括默认目录。\n如果有文件没有找到的话，make 会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成 makefile 的读取，make 会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让 make 不理那些无法读取的文件，而继续执行，你可以在 include 前加一个减号 - 。如：\n-include &lt;filenames&gt;...\n其表示，无论 include 过程中出现什么错误，都不要报错继续执行。如果要和其它版本 make 兼容，可以使用 sinclude 代替 -include 。\n环境变量 MAKEFILES\n如果你的当前环境中定义了环境变量 MAKEFILES ，那么 make 会把这个变量中的值做一个类似于 include 的动作。这个变量中的值是其它的 Makefile，用空格分隔。\n只是，它和 include 不同的是，从这个环境变量中引入的 Makefile 的“默认目标”(the default goal)不会起作用，如果环境变量中定义的文件发现错误，make 也会不理。\n但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用 make 时，所有的 Makefile 都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的 Makefile 出现了怪事，那么你可以看看当前环境中有没有定义这个变量。\nmake 的工作方式\nGNU 的 make工作时的执行步骤如下：（想来其它的 make 也是类似）\n\n读入所有的 Makefile。\n读入被 include 的其它 Makefile。\n初始化文件中的变量。\n推导隐式规则，并分析所有规则。\n为所有的目标文件创建依赖关系链。\n根据依赖关系，决定哪些目标要重新生成。\n执行生成命令。\n\n1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make 会把其展开在使用的位置。但 make 并不会完全马上展开，make 使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。\n当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对 make 更为熟悉。有了这个基础，后续部分也就容易看懂了。\n总结\nMakefile 里主要包含了五个东西：显式规则、隐式规则、变量定义、指令和注释。\n\n\n显式规则\n显式规则说明了如何生成一个或多个目标文件。这是由 Makefile 的书写者明显指出要生成的文件、文件的依赖文件和生成的命令。\n\n\n隐式规则\n由于我们的 make 有自动推导的功能，所以隐式规则可以让我们比较简略地书写 Makefile ，这是由 make 所支持的。\n\n\n变量的定义\n在 Makefile 中我们要定义一系列的变量，变量一般都是字符串，这个有点像你 C语言中的宏，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。\n\n\n指令\n其包括了三个部分，一个是在一个 Makefile 中引用另一个 Makefile ，就像C语言中的 include 一样；另一个是指根据某些情况指定 Makefile 中的有效部分，就像 C语言中的预编译 #if 一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。\n\n\n注释\nMakefile 中只有行注释，和 UNIX 的 Shell 脚本一样，其注释是用 # 字符，这个就像 C/C++ 中的 // 一样。如果你要在你的Makefile中使用 # 字符，可以用反斜杠进行转义，如： \\# 。\n\n\n最后，还值得一提的是，在 Makefile 中的命令，必须要以 Tab 键开始。\n\n  \n    \n      Makefile的文件名\n\n    \n    \n      默认的情况下，make命令会在当前目录下按顺序寻找文件名为 GNUmakefile 、 makefile 和 Makefile 的文件。在这三个文件名中，最好使用 Makefile 这个文件名，因为这个文件名在排序上靠近其它比较重要的文件，比如 README。最好不要用 GNUmakefile，因为这个文件名只能由GNU make ，其它版本的 make 无法识别，但是基本上来说，大多数的 make 都支持 makefile 和 Makefile 这两种默认文件名。\n当然，你可以使用别的文件名来书写Makefile，比如：“Make.Solaris”，“Make.Linux”等，如果要指定特定的Makefile，你可以使用make的 -f 或 --file 参数，如： make -f Make.Solaris 或 make --file Make.Linux 。如果你使用多条 -f 或 --file 参数，你可以指定多个 makefile。\n\n    \n  \n","tags":["C++","cpp","编译原理","C"]},{"title":"上传你的 SDK 到 MavenCentral","url":"/2024/01/29/%E4%B8%8A%E4%BC%A0%E4%BD%A0%E7%9A%84-SDK-%E5%88%B0-MavenCentral/","content":"参考链接：https://juejin.cn/post/7023219116534136840\n注册账号\nMaven Central 是由 Sonatype 公司负责维护的，所以我们要使用Maven Central 的话，首先需要注册 Sonatype 账号。\n链接：https://issues.sonatype.org/secure/Dashboard.jspa\n账号密码会在提交 SDK 的时候用到\n新建提交 SDK 的工单\n新建一个工单\n\n\nGroup Id 填你的域名\nProject URL 填你仓库的地址\nSCM url 填你仓库的 git 链接\n最后点击 新建 就会生成一个工单\n\n审核通过\n接下来就是等待审核，这个时长可能很短，也可能有点长，一般不到 24 小时\n审核通过后，会让你建一个 public 临时仓库，来证明这就是你自己的仓库\n新建完了之后回复一下就行，可以参考我的回复\n然后再等待，等他说 Congratulations! 就说明你拥有了上传的权限\n登录仓库\n登录链接：https://s01.oss.sonatype.org/\n使用一开始注册的 Sonatype 的账号密码\n现在你的仓库已经准备完毕了\n创建 GPG 签名\nGPG签名主要是给上传的library使用，每个上传的library都需要进行签名后才可以\n不同的library可以使用相同的签名文件，所以GPG密钥一般只需要申请一次即可\ngpg 工具：https://www.gnupg.org/download/index.html\n这个工具 Windows 和 MacOS 通用，并且推荐使用命令行\n我这里以 MacOS 为例：\n\n使用这行命令开始创建你的 gpg 签名\ngpg --gen-key\n然后会让你输入 real name （其实只要输入一个你记得的名字就行，不一定要是真实姓名）和 email address\n\n确认无误输入 O\n\n创建一个密码并记住他，点击 OK\n\n这样就生成成功了！（那串数字就是公钥，最后 8 位这就是你这个签名的 ID）\n上传 gpg\n使用这行命令（记得将最后的 8 位改成你的签名 ID，也就是你刚刚得到的那串数字的后8位）\ngpg --keyserver hkp://keyserver.ubuntu.com --send-keys 2918944A\n上传完之后，记得使用search-key验证一下\ngpg --keyserver hkp://keyserver.ubuntu.com --search-keys 2918944A\n导出私钥 gpg\n这里需要填写路径并命名 gpg 文件，同样使用你自己的 8 位 ID\ngpg -o ~/Desktop/test.gpg --export-secret-keys 2918944A\n这个 test.gpg 就是你的私钥，切记不要上传这个东西\n开始准备上传\n我这里使用的是大佬写的上传插件：https://github.com/vanniktech/gradle-maven-publish-plugin\n这里是官方文档：https://vanniktech.github.io/gradle-maven-publish-plugin/\n可以参考我的build.gradle.kts\nimport com.vanniktech.maven.publish.SonatypeHostplugins &#123;  kotlin(&quot;jvm&quot;)  id(&quot;com.vanniktech.maven.publish&quot;) version &quot;0.27.0&quot;&#125;group = &quot;io.github.darkflamemasterdev&quot;version = &quot;1.1.2&quot;// see the link:https://vanniktech.github.io/gradle-maven-publish-plugin/central/mavenPublishing &#123;  publishToMavenCentral(SonatypeHost.S01)  signAllPublications()  // groupId: artifactId: version cannot be wrong!!!  coordinates(group.toString(), &quot;MatrixKotlin&quot;, version.toString())  pom &#123;    name.set(&quot;MatrixKotlin&quot;)    description.set(&quot;a kotlin library for matrix calculations&quot;)    inceptionYear.set(&quot;2024&quot;)    url.set(&quot;https://github.com/darkflamemasterdev/MatrixKotlin&quot;)    licenses &#123;      license &#123;        name.set(&quot;GNU Lesser General Public License, Version 3.0&quot;)        url.set(&quot;https://www.gnu.org/licenses/gpl-3.0.txt&quot;)        distribution.set(&quot;https://www.gnu.org/licenses/gpl-3.0.txt&quot;)      &#125;    &#125;    developers &#123;      developer &#123;        id.set(&quot;DarkFlameMasterDev&quot;)        name.set(&quot;lucas&quot;)        url.set(&quot;https://github.com/darkflamemasterdev&quot;)      &#125;    &#125;    scm &#123;      url.set(&quot;https://github.com/darkflamemasterdev/MatrixKotlin&quot;)      connection.set(&quot;scm:git:git://github.com/darkflamemasterdev/MatrixKotlin.git&quot;)      developerConnection.set(&quot;scm:git:ssh://git@github.com/darkflamemasterdev/MatrixKotlin.git&quot;)    &#125;  &#125;&#125;repositories &#123;  mavenCentral()&#125;dependencies &#123;  implementation(&quot;com.vanniktech:gradle-maven-publish-plugin:0.27.0&quot;)&#125;kotlin &#123;  jvmToolchain(11)&#125;\n这个插件给了两种配置 MavenCentral 账号密码的方式，一种是配置在gradle.properties里\n一种是写在本地环境变量里\n我是直接写在了环境变量里，这个参考 https://vanniktech.github.io/gradle-maven-publish-plugin/central/#in-memory-gpg-key\n使用这个命令生成 signingInMemoryKey\ngpg2 --export-secret-keys --armor &lt;key id&gt; &lt;path to secring.gpg&gt; | grep -v &#x27;\\-\\-&#x27; | grep -v &#x27;^=.&#x27; | tr -d &#x27;\\n&#x27;\n参考我的环境变量配置 （.zshrc）\n# mavenCentralexport ORG_GRADLE_PROJECT_mavenCentralUsername=你的 MavenCentral 账号export ORG_GRADLE_PROJECT_mavenCentralPassword=你的 MavenCentral 密码# signingInMemoryKeyexport ORG_GRADLE_PROJECT_signingInMemoryKey=你自己的 key# signingInMemoryKeyIdexport ORG_GRADLE_PROJECT_signingInMemoryKeyId=你的 ID# signingInMemoryKeyPasswordexport ORG_GRADLE_PROJECT_signingInMemoryKeyPassword=你的 gpg 密码\n结尾\n另外，我介绍一下我的项目目录\n\n这里涉及三个模块\n\nMatrixKotlin 用来编写库的代码并上传\n总模块用来测试本地库运行情况\ntestInMavenCentral 用来引入已上传的代码\n\n","tags":["MavenCentral","lib"]},{"title":"学习 MakeFile [01] C语言编译（包含 C++）","url":"/2024/11/19/%E5%AD%A6%E4%B9%A0MakeFile-01-C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91-%E5%8C%85%E5%90%ABC++/","content":"C语言编译\n首先我们看看文件树\n$ tree   .└── src    ├── add.c    ├── main.c    └── minus.c2 directories, 3 files\n其中 add.c 、 minus.c 、 main.c 如下：\n// add.cint add(int a, int b) &#123;    return a + b;&#125;\n// minus.cint minus(int a, int b) &#123;    return a - b;&#125;\n// main.c#include &lt;stdio.h&gt;int add(int a, int b);int minus(int a, int b);int main(int argc, char const* argv[]) &#123;    int a = 3, b = 2;    int c = add(1, 2);    printf(&quot;a + b = %d\\n&quot;, c);    c = minus(a, b);s    printf(&quot;a - b = %d\\n&quot;, c);    return 0;&#125;\n编译步骤\n\n预处理\n\n展开所有宏定义（#define），将宏替换为它定义的值\n处理所有条件编译指令（#ifdef、#ifndef、#endif等）\n处理文件包含语句（#include），将包含的文件直接插s入到语句所在处\n删除所有注释\n添加行号和文件标识，以便在调s试和编译出错时快速定位到错误所在行\n\n\n\n\n  \n    ps: 代码中的编译器指令（#pragma）会被保留\n\n  \n\n编译（嗯…）\n汇编（嗯…）\n链接\n这里就是将函数的调用和函数的定义链接起来，如果没有定义或者定义的地方不止一处，则会出现链接错误\n\n编译命令\n常用的编译命令如下：\ngcc [参数] [文件列表]\n# -E 指定 .c 文件，激活预处理，但不会生成 .i 文件，除非用 -o 指定gcc -E main.cgcc -E main.c -o main.i# -S 指定 .c 或者 .i 文件，激活预处理和编译，生成 .s 文件gcc -S main.cgcc -S main.i# -c 指定 .c 、 .i 、.s 文件，激活预处理、编译和汇编，生成 .o 文件gcc -c main.cgcc -c main.igcc -c main.s# 指定任意类型文件，激活生成可执行文件gcc main.o add.i minus.c -o exec # 执行.exec\n编译静态库\n我在 src 目录下使用以下命令\n# 编译成 .o 的文件gcc -c [.c] -o [自定义文件名] gcc -c [.c] [.c] ...# 编译生成静态库ar -r [lib自定义库名.a] [.o] [.o] ...# 链接成可执行文件gcc [.c] [.a] -o [自定义输出文件名]gcc [.c] -o [自定义输出文件名] -l[库名] -L[库所在路径]\n\n  \n    \n      ps:\n\n    \n    \n      -l[库名] -L[库所在路径] l 和 L 后面没有间隔直接跟库名和路径，就像这样：\n#  编译成 .ogcc -c main.c add.c minus.c#  生成静态库rcs：命令选项：# r：插入文件到库中（替换已有文件）。# c：创建库文件，如果库文件不存在。# s：创建索引，提高库的访问速度。ar -rcs liboperation.a add.o minus.o# 链接生成可执行文件（方式 1）-loperation 用来指定库，-L.用来指定当前目录gcc main.c -loperation -L. -o exec# 链接生成可执行文件（方式 2）gcc main.c liboperation.a -o exec# 查看静态库内容ar -t liboperation.a# 输出结果__.SYMDEF SORTEDadd.ominus.o\n\n    \n  \n编译动态库\n同样在 src 目录下使用以下命令\ngcc -c -fpic [.c/.cpp][.c/.cpp]... gcc -shared [.o][.o]... -o [lib自定义库名.so]gcc [.c/.cpp] -l[库名] -L[库路径] -Wl,-rpath=[库路径] -o [自定义可执行文件名]\n# -fpic：生成位置无关代码，以便可以用于动态库gcc -c -fpic add.c minus.cgcc -shared add.o minus.o\ngcc main.c -loperation -L. -o exec\nC++ 编译\n\n  \n    非常简单，将 C语言编译的 gcc 改成 g++ 即可\n\n  \n","tags":["C++","cpp","编译原理","C"]},{"title":"咋写 Markdown","url":"/2023/09/25/%E5%92%8B%E5%86%99-Markdown/","content":"2023-09-25 改用 Typora\n最近不用 VSCode 了，改用 Typora 感觉还不错\n主要是 VSCode 没行号，就有点痛苦，快捷键也麻烦一点\n1. 改字体\n\n全局字体\n\n body&#123;  font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace;&#125;\n\n行内代码块\n\n code&#123;      font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace;&#125;\n\n代码块（代码段）\n\n pre &gt; * &#123;    font-family: &quot;&quot;&#125;\n\n\nMeta-data(也就分割线隔开，并不会加载到Markdown文档里那些)\n\n\n\n图片链接字体\n\n\n .md-image&gt;.md-meta &#123;  font-family: Menlo, Monaco, &quot;Courier New&quot;, monospace;&#125;\n  \n2. 图片引入\n\n2024-11-28 又改回 VSCode\nVSCode 虽然不显示行号，但我现在都直接在浏览器预览了，用了个自动刷新插件，还算方便\n另外 VSCode 可以避免一些奇奇怪怪的显示错误，尤其是在 latex 下\n比如：\n居中多行\n\\begin&#123;gather&#125;\\text&#123;第一行&#125; \\\\\\text&#123;第二二二行&#125;\\end&#123;gather&#125;\n\\begin{gather}\n\\text{第一行} \\\\\n\\text{第二二二行}\n\\end{gather}\n\n左对齐、右对齐和公式对齐\n&amp; 为对其位置\n左对齐\\begin&#123;align&#125;&amp; \\text&#123;第一行&#125; \\\\&amp; \\text&#123;第二行&#125;\\end&#123;align&#125;右对齐\\begin&#123;align&#125;\\text&#123;第一行&#125; &amp; \\\\\\text&#123;第二行&#125; &amp;\\end&#123;align&#125;公式（等号）对齐\\begin&#123;align&#125;1+2 &amp; = 3 \\\\1+2+3+4 &amp; = 10\\end&#123;align&#125;\n下面是实际效果\n\\begin{align}\n&amp; 123123第一行 \\\\\n&amp; 第二行\n\\end{align}\n\n\\begin{align}\n第一行123123 &amp; \\\\\n第二行 &amp;\n\\end{align}\n\n\\begin{align}\n1+2 &amp; = 3 \\\\\n1+2+3+4 &amp; = 10\n\\end{align}\n\n","tags":["Markdown","Typora","VSCode"]},{"title":"微星 4060 万图师 8G 游戏设置","url":"/2023/08/17/%E5%BE%AE%E6%98%9F-4060-%E4%B8%87%E5%9B%BE%E5%B8%88-8G-%E6%B8%B8%E6%88%8F%E8%AE%BE%E7%BD%AE/","content":"2499京东买的微星 4060 万图师 8G\n犹豫了一下3060 12G，最终还是买了4060 8G，心想着有dlss3还勉强可以战未来\n现在发现8G显存有点不够用\n尤其是巫师3显存占用高得离谱\n\n以下是4k60hz流畅不跳帧 尽可能高画质 的设置\n\n1. 巫师3\n值得注意的是，这个DLSS 帧生成非常不好用，他会禁用垂直同步，导致画面撕裂，所以不到万不得已，最好不要开\n\n\n2. 荒野大镖客2\n大表哥2本身并不支持最新的DLSS3，可以通过换文件来实现DLSS3，效果会比DLSS2多5~6帧，在DLSS2里均帧56，在DLSS3里就直接60\n下载地址是\nnvngx_dlss.dll\nhttps://www.techpowerup.com/download/nvidia-dlss-dll/\nnvngx_dlssg.dll\nhttps://www.techpowerup.com/download/nvidia-dlss-3-frame-generation-dll/\n第一个是画质优化，第二个是帧生成（插帧），改第一个就行，第二个个人感觉不好用（在巫师3 那里提到过）\n\n别忘了备份原文件\n\n\n","tags":["显卡","4060","游戏"]},{"title":"开发小知识、问题（持续更新）","url":"/2023/04/23/%E5%BC%80%E5%8F%91%E5%B0%8F%E7%9F%A5%E8%AF%86%E3%80%81%E9%97%AE%E9%A2%98%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/","content":"1. AS apk 安装包安装位置\n2022.3.1版本\n/app/build/intermediates/\n/app/build/outputs/apk/debug/app-debug.apk\n2. AS R 文件位置\n2022.3.1版本\n\n/app/build/intermediates/runtime_symbol_list/debug/R.txt\n3. AS OpenGL ES 相关库文件在什么位置\n2022.3.1版本\n在 ndk 目录里面，MacOS 在 /Users/yourUserName/Library/Android/sdk/ndk/\n4. Android 开发 OpenGL ES 找不到 GL_TEXTURE_BORDER_COLOR\n在 GLES3/gl3.h 里面没有，在 GLES3/gl32.h\n5. AS 写 C++ 的时候，一直提示当前文件不属于任何项目\n2022.3.1版本\n如果你确定你已经将文件添加到 CMakeList.txt 里面，但依旧没作用\n那大概率是下面的问题\nThis file is not part of the project. Please include it in the appropriate build file (build.gradle, CMakeLists.txt or Android.mk etc.) and sync the project.\n这是因为 CMake 没有重新加载，你可以 Sync Project with Gradle Files ，就是这个图标\n\n如果没有效果，那大概是直接用了缓存，没有重新加载\n你可以在 CMakeList.txt 里写几行 message ，直到右上角出现 Sync Project\nExternal build files have changed since last project sync. A project sync may be necessary for the IDE to work properly.\n6. AS C++ 没有代码提示，并且代码高亮多处爆红\n2022.3.1版本\n这是因为 Android Studio 在你没有 #include .h文件 或者没有调用某个 C++ 函数的时候，是不给你进行代码检查的\n我还专门跟 Google 发了邮件，得到了如上回复\n7. MacOS 删除 .DS_Store\nfind /Users/username/dir/ -name &quot;.DS_Store&quot; -exec rm &#123;&#125; \\;\n/Users/username/dir/ 这是你想删除 .DS_Store 的文件夹\n8. jni 中，类型映射\n写这个的主要原因是因为 Kotlin 类型需要对应到 Java 包名才可以\n基本类型（Primitive Type）\n\n\n\nJava 类型\nKotlin 类型\nNative 类型\n描述\n符号\n\n\n\n\nint\nInt\njint\n有符号32位整型（int）\nI\n\n\nshort\nShort\njshort\n有符号16位整型（short）\nS\n\n\nlong\nLong\njlong\n有符号64位整型（long）\nJ\n\n\nfloat\nFloat\njfloat\n32位浮点型（float）\nF\n\n\ndouble\nDouble\njdouble\n64位浮点型（double）\nD\n\n\nboolean\nBoolean\nJboolean\n无符号8位整型（unsigned char）\nZ\n\n\nchar\nChar\nJchar\n无符号16位整型（unsigned short）\nC\n\n\nbyte\nByte\njbyte\n有符号8位整型（char）\nB\n\n\n\n引用类型（Reference Type）\n\n\n\nJava 类型\nKotlin 类型\nNative 类型\n描述\n符号\n\n\n\n\nClass\nClass\njclass\nClass类对象\nLjava.lang.Class;\n\n\nObject\nAny\njobject\n-\nLjava.lang.Object;\n\n\nString\nString\njstring\n-\nLjava/lang/String;\n\n\nObject[]\nAnyArray\njobjectArray\n-\n[Ljava.lang.Object;\n\n\nboolean[]\nBooleanArray\njbooleanArray\n-\n[Z\n\n\nbyte[]\nByteArray\njbyteArray\n-\n[B\n\n\nchar[]\nCharArray\njcharArray\n-\n[C\n\n\nshort[]\nShortArray\njshortArray\n-\n[S\n\n\nint[]\nIntArray\njintArray\n-\n[I\n\n\nlong[]\nLongArray\njlongArray\n-\n[J\n\n\nfloat[]\nFloatArray\njfloatArray\n-\n[F\n\n\ndouble[]\nDoubleArray\njdoubleArray\n-\n[D\n\n\nvoid\nUnit\nVoid\n-\nV\n\n\n\n除了基本数据类型，以及 void ，基本都是 L+包名+; ，数组再在开头加一个 [\n9. Windows 的狗屎快捷键 🖕🖕🖕💩💩💩\n总有一些“才智冠绝”、“谦虚谨慎”的人，提出让大众“赞不绝口”的设计需求\n使用频率低，还无法更改的快捷键就是一种（他甚至连关闭都不让！！！）\nctrl + 空格切换中英文、win + → 改窗口位置…\n这些无法更改的快捷键对于一个使用大量快捷键的程序猿简直就是噩梦\n10. 什么是内存泄漏\n\n内存泄漏是指“逻辑”上某个实例无用了，但是仍旧没有回收\n并不能用是否持有引用来进行判断\n\npublic class MemoryLeak &#123;    public static void main(String[] args) &#123;        Person p = new Person();        Name n = new Name();        p.name = n;        n = null;    &#125;&#125;class Person &#123;    Name name;&#125;class Name &#123;    String firstName;    String SecondName;&#125;\n这里 n = null 但是 p 依旧持有 n 的引用，这不一定是内存泄漏，只是对 n 主动丢弃了一个引用，有可能后面还是要使用这个n\n11. mac 常用命令\n\n\n清除 app 的扩展属性\nsudo xattr -cr\n\n-c：表示 清除（clear）文件的所有扩展属性。\n-r：表示 递归（recursive），即对目录下的所有子文件和子目录也执行相同操作。\n\n当然还有其他操作：\n$ xattr -h用法：xattr [-l] [-r] [-s] [-v] [-x] 文件 [文件 ...]xattr -p [-l] [-r] [-s] [-v] [-x] 属性名称 文件 [文件 ...]xattr -w [-r] [-s] [-x] 属性名称 属性值 文件 [文件 ...]xattr -d [-r] [-s] 属性名称 文件 [文件 ...]xattr -c [-r] [-s] 文件 [文件 ...]第一种形式列出给定文件上所有 xattr 的名称。第二种形式 (-p) 打印 xattr 属性名称的值。第三种形式 (-w) 将 xattr 属性名称的值设置为字符串 attr_value。第四种形式 (-d) 删除 xattr 属性名称。第五种格式 (-c) 删除（清除）所有扩展属性。选项：-h：打印此帮助-l：打印长格式（属性名称：属性值，十六进制输出包含偏移量和ASCII 表示）-r：递归执行-s：对符号链接本身执行操作，而不是链接指向的内容-v：同时打印文件名（使用 -r 选项并处理多个文件时自动执行）-x：将属性值表示为十六进制字符串，用于输入和输出\n扩展属性是 Mac 给 app 添加的元数据，比如：\n\ncom.apple.quarantine ：表示文件是从网上下载的，macOS 会限制运行并弹出“来自不明开发者”的提示。\ncom.apple.metadata:kMDItemWhereFroms ：文件的来源网址或路径，用于 Finder “显示简介”中显示“从何处下载”。\ncom.apple.ResourceFork ：存储老式 Mac 资源分支的数据（已较少使用）。\ncom.apple.FinderInfo ：用于 Finder 显示图标、标签等信息。\ncom.apple.metadata:_kMDItemUserTags ：Finder 标签（颜色标签等）信息。\ncom.apple.metadata:kMDItemDownloadedDate ：下载日期。\ncom.apple.TextEncoding ：文件的文本编码信息（如 UTF-8）。\ncom.apple.backup.SnapshotVolumeUUID ：Time Machine 快照相关信息。\ncom.apple.provenance ：App 安装源标识（如 App Store）。\ncom.apple.lastuseddate#PS ：最近使用日期，Spotlight 使用的。\n\n\n如果在使用 Time Machine 就要谨慎使用这个命令，这可能会让你的存储信息损坏\n\n\n\n打开所有 app 安装来源\nsudo spctl --master-disable\n\n\n12. JvmPlatformAnnotations.kt\n\n@JvmOverloads\n在 Kotlin 中支持默认参数，写了默认参数的函数在调用的时候可以不写有默认值参数，但 Java 不支持。\n这个注解会为具有默认参数的函数生成多个重载方法，使 Java 调用时达到和 kotlin 类似的效果。\nclass JvmPlatformAnnotationsDemo &#123;    @JvmOverloads    fun testOverLoad(a: Int = 0, b: String = &quot;s&quot;, c: Double, d: Float = 0f, e: Long = 0) &#123;    &#125;&#125;\n这里有 5 个参数，其中就 c 是没有默认值的，所以编译器应该考虑所有的有默认值的参数不被写的情况，但实际呢？\n反编译成 java ：\npublic final class JvmPlatformAnnotationsDemo &#123;   @JvmOverloads   public final void testOverLoad(int a, @NotNull String b, double c, float d, long e) &#123;      Intrinsics.checkNotNullParameter(b, &quot;b&quot;);   &#125;   // $FF: synthetic method   public static void testOverLoad$default(JvmPlatformAnnotationsDemo var0, int var1, String var2, double var3, float var5, long var6, int var8, Object var9) &#123;      if ((var8 &amp; 1) != 0) &#123;         var1 = 0;      &#125;      if ((var8 &amp; 2) != 0) &#123;         var2 = &quot;s&quot;;      &#125;      if ((var8 &amp; 8) != 0) &#123;         var5 = 0.0F;      &#125;      if ((var8 &amp; 16) != 0) &#123;         var6 = 0L;      &#125;      var0.testOverLoad(var1, var2, var3, var5, var6);   &#125;   @JvmOverloads   public final void testOverLoad(int a, @NotNull String b, double c, float d) &#123;      Intrinsics.checkNotNullParameter(b, &quot;b&quot;);      testOverLoad$default(this, a, b, c, d, 0L, 16, (Object)null);   &#125;   @JvmOverloads   public final void testOverLoad(int a, @NotNull String b, double c) &#123;      Intrinsics.checkNotNullParameter(b, &quot;b&quot;);      testOverLoad$default(this, a, b, c, 0.0F, 0L, 24, (Object)null);   &#125;   @JvmOverloads   public final void testOverLoad(int a, double c) &#123;      testOverLoad$default(this, a, (String)null, c, 0.0F, 0L, 26, (Object)null);   &#125;   @JvmOverloads   public final void testOverLoad(double c) &#123;      testOverLoad$default(this, 0, (String)null, c, 0.0F, 0L, 27, (Object)null);   &#125;&#125;\n\n可以看到，编译器并是不排列组合生成重载，也就是说，如果你的 kotlin 这么调用：\nJvmPlatformAnnotationsDemo().testOverLoad(b = &quot;sss&quot;, c = 3.14)\njava 是没法调用的，java 只能调用 public final void testOverLoad(int a, @NotNull String b, double c) 方法\n这是为啥啊？大概就是防止指数级膨胀\n\n@JvmStatic\n用于将 Kotlin 的对象（object）或伴生对象中的方法标记为静态方法（static）供 Java 调用。\nobject Utils &#123;    @JvmStatic    fun foo() &#123;&#125;&#125;\nUtils.foo();\n@JvmName\n用于更改 Kotlin 生成的 Java 方法或类的名字。\n@file:JvmName(&quot;MyKt&quot;)@JvmName(&quot;addInt&quot;)fun add(a: Int, b: Int): Int = a + b\nint result = MyKt.addInt(1, 2);\n@JvmMultifileClass\n用于将多个 Kotlin 文件合并为一个 Java 类（通常用于多个 file 声明中带 @file:JvmName(&quot;...&quot;)）。\n@file:JvmName(&quot;Utils&quot;)@file:JvmMultifileClass\n多个文件的顶层函数会被合并到一个 Java 类中。\n@JvmPackageName\n指定生成的 Java 类的包名，避免 Kotlin 的文件在默认包中生成 Java 类。\n@file:JvmPackageName(&quot;com.example.utils&quot;)\n@JvmSynthetic\n该方法或属性对 Java 是不可见的，但在 Kotlin 中可用。常用于隐藏不安全的 API 或内部实现。\n@Throws\n声明 Kotlin 函数会抛出哪些异常，让 Java 可以正确捕获异常。\n@Throws(IOException::class)fun readFile() &#123;    throw IOException(&quot;Failed&quot;)&#125;\n@ImplicitlyActualizedByJvmDeclaration\n用于 expect/actual 多平台支持。这个注解通常由编译器自动处理，用于实际实现是 JVM 上的 API。\n@JvmField\n使属性在 Java 中可直接访问为字段，避免生成 getter/setter。\nclass MyClass &#123;    @JvmField    val id = 1&#125;\nJava 中可以直接 myClass.id，否则需要调用 getId()。\n@JvmSuppressWildcards\n抑制泛型类型中通配符的自动生成，常用于与 Java 泛型协作。\nfun acceptList(@JvmSuppressWildcards list: List&lt;Any&gt;)\n@JvmWildcard\n与 @JvmSuppressWildcards 相对，强制某个类型参数生成通配符。\nfun provide(): List&lt;@JvmWildcard String&gt;\n@JvmInline\n用于定义内联类（value class），它会在字节码中作为原始类型使用以提高性能。\n@JvmInlinevalue class UserId(val id: String)\n@JvmRecord\n用于标记 Kotlin 的数据类为 Java 16+ 的 record 类型，需配合 JVM target 17。\n@JvmRecorddata class Point(val x: Int, val y: Int)\n13. IDEA 快捷键（适用 Android Studio）\n1. 检索当前文件的变量和函数（File Structure）：cmd + F12\n2. 参数信息（Parameter Info）：cmd + P\n","tags":["Android","Gradle","Android Studio","C","OpenGL ES","MacOS","Mac","Linux","Cpp","Windows"]},{"title":"数据库-练习题","url":"/2024/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%BB%83%E4%B9%A0%E9%A2%98/","content":"练习题\n1. 力扣 1633. 各赛事的用户注册率 简单\n用户表： Users\n+-------------+---------+| Column Name | Type    |+-------------+---------+| user_id     | int     || user_name   | varchar |+-------------+---------+user_id 是该表的主键(具有唯一值的列)。该表中的每行包括用户 ID 和用户名。\n注册表： Register\n+-------------+---------+| Column Name | Type    |+-------------+---------+| contest_id  | int     || user_id     | int     |+-------------+---------+(contest_id, user_id) 是该表的主键(具有唯一值的列的组合)。该表中的每行包含用户的 ID 和他们注册的赛事。\n编写解决方案统计出各赛事的用户注册百分率，保留两位小数。\n返回的结果表按 percentage 的 降序 排序，若相同则按 contest_id 的 升序 排序。\n返回结果如下示例所示。\n示例 1：\n输入：Users 表：+---------+-----------+| user_id | user_name |+---------+-----------+| 6       | Alice     || 2       | Bob       || 7       | Alex      |+---------+-----------+Register 表：+------------+---------+| contest_id | user_id |+------------+---------+| 215        | 6       || 209        | 2       || 208        | 2       || 210        | 6       || 208        | 6       || 209        | 7       || 209        | 6       || 215        | 7       || 208        | 7       || 210        | 2       || 207        | 2       || 210        | 7       |+------------+---------+输出：+------------+------------+| contest_id | percentage |+------------+------------+| 208        | 100.0      || 209        | 100.0      || 210        | 100.0      || 215        | 66.67      || 207        | 33.33      |+------------+------------+解释：所有用户都注册了 208、209 和 210 赛事，因此这些赛事的注册率为 100% ，我们按 contest_id 的降序排序加入结果表中。Alice 和 Alex 注册了 215 赛事，注册率为 ((2/3) * 100) = 66.67%Bob 注册了 207 赛事，注册率为 ((1/3) * 100) = 33.33%\n\n题解:\n表结构很简单, 都是只有两个属性\n计算每个 contest_id 对应的注册率 , 我们只需要查询出每个 contest_id 对应的注册人数 , 有多少人 , 再除以 Users 中的用户人数即可\nSELECT    r.contest_id,    ROUND(COUNT(r.user_id)/(SELECT COUNT(*) FROM Users) * 100,2) as percentageFROM    Register AS r GROUP BY    r.contest_idORDER BY    percentage DESC,    contest_id ASC;\n应该还是挺好理解的 , 查询两个数据 contest_id 和 percentage , group by 按 contest_id 分组 , 计算的每组 user_id 数量 , 这样就可以计算出注册率 , 最后按要求排一下序\n\n2. 力扣 1661. 每台机器的进程平均运行时间 简单\n表: Activity\n+----------------+---------+| Column Name    | Type    |+----------------+---------+| machine_id     | int     || process_id     | int     || activity_type  | enum    || timestamp      | float   |+----------------+---------+该表展示了一家工厂网站的用户活动。(machine_id, process_id, activity_type) 是当前表的主键（具有唯一值的列的组合）。machine_id 是一台机器的ID号。process_id 是运行在各机器上的进程ID号。activity_type 是枚举类型 (&#x27;start&#x27;, &#x27;end&#x27;)。timestamp 是浮点类型,代表当前时间(以秒为单位)。&#x27;start&#x27; 代表该进程在这台机器上的开始运行时间戳 , &#x27;end&#x27; 代表该进程在这台机器上的终止运行时间戳。同一台机器，同一个进程都有一对开始时间戳和结束时间戳，而且开始时间戳永远在结束时间戳前面。\n现在有一个工厂网站由几台机器运行，每台机器上运行着 相同数量的进程 。编写解决方案，计算每台机器各自完成一个进程任务的平均耗时。\n完成一个进程任务的时间指进程的'end' 时间戳 减去 'start' 时间戳。平均耗时通过计算每台机器上所有进程任务的总耗费时间除以机器上的总进程数量获得。\n结果表必须包含machine_id（机器ID） 和对应的 average time（平均耗时） 别名 processing_time，且四舍五入保留3位小数。\n以 任意顺序 返回表。\n具体参考例子如下。\n示例 1:\n输入：Activity table:+------------+------------+---------------+-----------+| machine_id | process_id | activity_type | timestamp |+------------+------------+---------------+-----------+| 0          | 0          | start         | 0.712     || 0          | 0          | end           | 1.520     || 0          | 1          | start         | 3.140     || 0          | 1          | end           | 4.120     || 1          | 0          | start         | 0.550     || 1          | 0          | end           | 1.550     || 1          | 1          | start         | 0.430     || 1          | 1          | end           | 1.420     || 2          | 0          | start         | 4.100     || 2          | 0          | end           | 4.512     || 2          | 1          | start         | 2.500     || 2          | 1          | end           | 5.000     |+------------+------------+---------------+-----------+输出：+------------+-----------------+| machine_id | processing_time |+------------+-----------------+| 0          | 0.894           || 1          | 0.995           || 2          | 1.456           |+------------+-----------------+解释：一共有3台机器,每台机器运行着两个进程.机器 0 的平均耗时: ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894机器 1 的平均耗时: ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995机器 2 的平均耗时: ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456\n\n题解:\nselect a1.machine_id , round((sum(a2.timestamp)-sum(a1.timestamp))/count(a1.machine_id),3) processing_timefrom     Activity as a1 join Activity as a2     on a1.machine_id = a2.machine_id     and a1.process_id=a2.process_id     and a1.activity_type = &#x27;start&#x27;     and a2.activity_type = &#x27;end&#x27;group by a1.machine_id;\n举例:\n| machine_id | process_id | activity_type | timestamp || ---------- | ---------- | ------------- | --------- || 0          | 0          | start         | 0.712     || 0          | 0          | end           | 1.52      || 0          | 1          | start         | 3.14      || 0          | 1          | end           | 4.12      || 1          | 0          | start         | 0.55      || 1          | 0          | end           | 1.55      || 1          | 1          | start         | 0.43      || 1          | 1          | end           | 1.42      || 2          | 0          | start         | 4.1       || 2          | 0          | end           | 4.512     || 2          | 1          | start         | 2.5       || 2          | 1          | end           | 5         |\n调用如下 sql 代码\nselect a1.machine_id as machine_id , a1.process_id as a1process_id , a1.timestamp as start_time , a2.timestamp as end_timefrom     Activity as a1 join Activity as a2     on a1.machine_id = a2.machine_id     and a1.process_id=a2.process_id     and a1.activity_type = &#x27;start&#x27;     and a2.activity_type = &#x27;end&#x27;\n得到如下\n| machine_id | a1process_id | start_time | end_time || ---------- | ------------ | ---------- | -------- || 0          | 0            | 0.712      | 1.52     || 0          | 1            | 3.14       | 4.12     || 1          | 0            | 0.55       | 1.55     || 1          | 1            | 0.43       | 1.42     || 2          | 0            | 4.1        | 4.512    || 2          | 1            | 2.5        | 5        |\n所以 sum(a2.timestamp) - sum(a1.timestamp) / count(a1.machine_id) 就是每个机器平均每个进程的运行时间\n当然也可以简化 avg(a2.timestamp - a1.timestamp)\nPs : 我是后来才之后有求平均数的函数的(╯°□°）╯︵┻━┻\n\n3. 力扣 1667. 修复表中的名字 简单\n表： Users\n+----------------+---------+| Column Name    | Type    |+----------------+---------+| user_id        | int     || name           | varchar |+----------------+---------+user_id 是该表的主键(具有唯一值的列)。该表包含用户的 ID 和名字。名字仅由小写和大写字符组成。\n编写解决方案，修复名字，使得只有第一个字符是大写的，其余都是小写的。\n返回按 user_id 排序的结果表。\n返回结果格式示例如下。\n示例 1：\n输入：Users table:+---------+-------+| user_id | name  |+---------+-------+| 1       | aLice || 2       | bOB   |+---------+-------+输出：+---------+-------+| user_id | name  |+---------+-------+| 1       | Alice || 2       | Bob   |+---------+-------+\n\n解答:\n感觉这个题就是纯粹考函数\nselect user_id, concat(Upper(substring(name,1,1)),lower(substring(name,2))) as namefrom Usersorder by user_id;\nconcat 字符串连接\nUpper 字母大写\nLower 字母小写\nsubstring 截取字符串\n\n","tags":["数据库","关系代数","集合"]},{"title":"教资-信息技术-知识点","url":"/2024/04/25/%E6%95%99%E8%B5%84-%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF-%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"1 CRC 循环冗余校验（Cyclic Redundancy Check， CRC）\n1.1 原理解释\nCRC 的原理是模二除法。\n模二运算是一种二进制算法。与四则运算相同，模二运算也包括加、减、乘、除四种运算，运算符也是相同的。\n\n模二除法\n\n当最后余数的位数小于除数位数时，除法停止。\n当被除数的位数小于除数位数时，则商数为0，被除数就是余数。\n只要被除数或部分余数的位数与除数一样多，且最高位为1，不管其他位是什么数，皆可商1。\n\n1.2 实际应用\n实际应用时，发送方和接收方按以下方式通信：\n\n发送方和接收方在通信前，约定好一个预设整数作为除数。\n发送方在发送前根据原始数据和约定好的除数进行模二除法运算生成余数（即CRC码），然后将其附加到原始数据后面一起发送给接收方。\n接收方收到后将其模二除以约定好的除数，当且仅当余数为 0 时接收方认为没有差错。\n\n示例:\n假设要传输的原始数据为 1101011011B，发送方和接收方在通信前约定好的除数为 10011B。由于除数10011B是五位数（5bit），那么假设余数（即CRC码）为四位数（4bit）。因为现在余数未知，所以在进行模二除法运算前先将余数设为 0000B，即待发送的数据为11010110110000B。\n下面开始进行模二除法运算来确定余数（即CRC码）：\n\n可见余数（即CRC码）为 1110B，因此发送方实际发送的是 11010110111110B。\n接收方在接收后需要将其模二除以10011B来进行CRC校验：\n\n可见余数为0，因此本次通信没有差错。\n1.3 数学描述\n1.3.1 基本原理\n设原始数据为 D(x)D(x)D(x) ，约定好的除数为 P(x)P(x)P(x)，P(x)P(x)P(x) 最高次数为 rrr ，模二除法运算的余数为 R(x)R(x)R(x) ，即 R(x)=[2rD(x)]modP(x)R(x) = [2^r D(x)]mod P(x)R(x)=[2rD(x)]modP(x)，CRC码为 F(x)F(x)F(x)，实际发送的数据为 T(x)T(x)T(x)。\n显然，T(x)=2rD(x)+F(x)T(x)=2^{r}D(x)+F(x)T(x)=2rD(x)+F(x)。\n所以CRC算法问题变为：求解 F(x)F(x)F(x) 使 T(x)modP(x)=0T(x)modP(x)=0T(x)modP(x)=0。（这里不考虑正负，所以取模和取余等效）\nT(x)modP(x)=[2rD(x)+F(x)]modP(x)=[2rD(x)]modP(x)+F(x)modP(x)=R(x)+F(x)\\begin{aligned}\n&amp;T(x)modP(x) \\\\\n&amp;=[2^{r}D(x)+F(x)]modP(x) \\\\\n&amp;=[2^{r}D(x)]modP(x)+F(x)modP(x) \\\\\n&amp;=R(x)+F(x) \\\\\n\\end{aligned}\n​T(x)modP(x)=[2rD(x)+F(x)]modP(x)=[2rD(x)]modP(x)+F(x)modP(x)=R(x)+F(x)​\n注意，这里是模二加法，模二加法里，两个相同的数，相加会等于 0\n取 F(x)=R(x)F(x) = R(x)F(x)=R(x)\nR(x)+F(x)=R(x)+R(x)=0modP(x)=0\\begin{aligned}\n&amp; R(x)+F(x) \\\\\n&amp;=R(x)+R(x) \\\\\n&amp;=0 \\\\\n&amp;modP(x)=0 \\\\\n\\end{aligned}\n​R(x)+F(x)=R(x)+R(x)=0modP(x)=0​\n故 F(x)=R(x)=[2rD(x)]modP(x)F(x)=R(x)=[2^{r}D(x)]modP(x)F(x)=R(x)=[2rD(x)]modP(x)。\n1.3.2  如何确定 P(x)P(x)P(x)\n所以，CRC 主要涉及 3 个数\n\n原始数据 D(x)D(x)D(x)\n约定除数 P(x)P(x)P(x)\n余数 R(x)R(x)R(x)\n\n原始数据是已经确定好的要发送的数据，余数是通过 2rD(x)÷p(x)2^rD(x)\\div p(x)2rD(x)÷p(x) 来计算出的\n那么 P(x)P(x)P(x) 该如何确定呢\n实际上，P(x)P(x)P(x) 是由一种称为 本原元 的特殊多项式计算而来的，P(x)应该满足：\n\n最高位和最低位都是 1\n当被传送信息任何一位发生错误时，P(x)P(x)P(x) 不被 T(x)T(x)T(x) 整除（ T(x)T(x)T(x) 是实际发送的数据 ）\n不同位发生错误时，余数应该不同\n对余数继续做模二除法时，应该使余数循环\n\n1.4 常见 CRC 类型（部分）\n\n上表中，\n\n多项式公式代表着除数，也就是 P(X)P(X)P(X)，你会发现他的除数 符合最高位最低位都是 1\n宽度就是 CRC 码的二进制位数\n初始值是运算初始值。需要将被除数先减去初始值再进行计算\n结果异或值和输入输出反转都是对结果进行的操作\n\n上面局的计算例子就是 CRC-4/ITU，具体流程如下：\n\n我们确定被除数是否需要反转（反转就是0变1，1变0），这里不需要反转\n先减去初始值，这里是0\n然后通过多项式公式确定除数为10011\n计算完之后在看是否需要异或运算，这里不需要\n最后再看是否需要反转，这里也不需要\n\n2 数据库\n2.1 关系代数\n数据库-关系代数\n2.2 SQL 语句\n2.2.1 概述\n语句分4类\n\nDQL 数据查询（select）\nDDL 数据定义（create table，alter table，drop table）\nDML 数据操作（insert，update，delete）\nDCL 数据控制（grant，revoke）\n\n基本操作？我也不知道这些属于什么类型的语句\n# 创建数据库create database 数据库名# 显示所有的数据库show databases;# 切换到指定数据库use 数据库名;# 显示表结构desc 表名;# 显示 sql 语句（以 table 为例）show create table &lt;table&gt;;\n2.2.2 DDL\n# 创建表create table 表名(  列名 类型 [列-完整性约束],  列名 类型 [列-完整性约束],  列名 类型 [列-完整性约束],  ...) 表-完整性约束;\n# 修改表alter table 表名 [操作语句];\n操作语句有\n\nadd 列名 类型 [列-完整性约束] 增加新列和新的完整性约束\ndrop column 列名 删除列和指定的完整性约束条件\nalter column 列名 类型 修改列名和数据类型\nadd primary key(列名，...) 增加主键\nadd foreign key(列名) referneces (列名) 增加外键\nadd default key [默认值] for (列名)\nadd check (约束表达式)\nadd unique (列名)\n\n# 删除表drop table 表名 [restrict|cascade]; # 默认是 restrict ，cascade 是删除相关的其他依赖，包括索引、视图、触发器等等# 删除并重建表（格式化）truncate table 表名;\n2.2.3 DML\ninsert [into] 表名 [(属性列,...)]values (常量,...);\n3 算法\n3.1 快速排序\n直接上代码\nfun quickSort(a: IntArray, l: Int, r: Int) &#123;    if (l &lt; r) &#123;        var i = l        var j = r        val x = a[i]        while (i &lt; j) &#123;            while (i &lt; j &amp;&amp; a[j] &gt; x) &#123;                j--            &#125;            if (i &lt; j) &#123;                a[i++] = a[j]            &#125;            while (i &lt; j &amp;&amp; a[i] &lt; x) &#123;                i++            &#125;            if (i &lt; j) &#123;                a[j--] = a[i]            &#125;        &#125;        a[i] = x        quickSort(a, l, i - 1)        quickSort(a, i + 1, r)    &#125;&#125;\n我不知道为什么，快排我每次都要重新学，每次学完，过了半年，再问我，我就只记得“选一个基准数，把比他小的放在左边，比他大的放在右边”，然后后面的就不记得了\n感觉是因为我，对于数据的精细操作，不够熟练，比如链表，数组，while 循环之类的\n首先，假设我们有一个数组 a[6] = 3，4，6，1，2，5\n\n\n我们首先要选一个基准数，比如 a[0] = 3 对应第 6 行代码\n\n\n然后我们要先从右找比基准数小的数，这里使用 while 循环 j-- ，循环的条件是当没有找到比基准数小，并且 i&lt;j\n同样，我们在左边找到比基准数更小的，循环条件也要对应改变\n对应第 8 到 第 19 行代码\n这里有一个知识点，在将右边那个较小得数赋值到左边 i 位置的时候，可以直接赋值而不是交换，因为 i 位置已经被赋值给了 基准数 pri ，所以不会丢数据\n并且在后续，将左边那个较大的数赋值到右边 j 的时候，可以直接赋值，因为 j 位置的数据已经在刚才赋值给左边了\n我称之为 连环存储 不丢数据 赋值\n\n\n\n请注意，这是我觉的一个难点，就是 while 循环的条件\n这里一级循环条件是 i&lt;j ，因为在找到一大一小并进行赋值之后，进行判断，是否需要再进行下一次循环\n而内部的二级循环，是为了判断，当前这次循环是否符合大小关系，并且当前这个数是否符合大小关系，是否需要判断下一个数\n所以 while 有 if 的作用\n\n\n最后 i 和 j 相遇，将 连环存储 不丢数据 赋值 最开始的基准数 pri 赋值到最后 i 的位置（此时 i=j ，用谁其实都一样），完成第一趟将数据大小分开的操作\n\n\n然后将左边的分过一次的较小的数，进行二次分开操作，同样右边也需要二次分开操作\n\n\n最后，我们需要一个判断条件，也就是判断什么时候递归停止，当然是数组里元素等于 1 的时候，此时当然也就是 l=r 的时候，所以我们只需要在 l&lt;r 的时候，进行操作就可以了\n对应 第 3 行的代码\n\n\n这就是快排的整体思路\n4 数据格式\n4.1 数据大小的单位\n1MB=1024KB=1024×1024B=1024×1024×8bit1MB=1024KB=1024×1024B=1024×1024×8bit\n1MB=1024KB=1024×1024B=1024×1024×8bit\nbit 是 位，也叫比特Byte 是 字节Kbit 是 Kbit，也就是千比特KB 是 KByte，也就是千字节MB 是 兆比特...\\begin{aligned}\nbit\\ &amp;是\\ 位，也叫比特\\\\\nByte\\ &amp;是\\ 字节\\\\\nKbit\\ &amp;是\\ Kbit，也就是千比特\\\\\nKB\\ &amp;是\\ KByte，也就是千字节\\\\\nMB\\ &amp;是\\ 兆比特\\\\\n...\n\\end{aligned}\nbit Byte Kbit KB MB ...​是 位，也叫比特是 字节是 Kbit，也就是千比特是 KByte，也就是千字节是 兆比特​\n4.2 图像存储的计算\n4.2.1 例题\n\n\n将 800×600800\\times 600800×600 像素、24 位真彩色 BMP 格式的图像转换为 256 级灰度 BMP 格式图像，其它参数不变，则新图像存储容量为原图像的多少？\nA. 18\\displaystyle\\frac{1}{8}81​          B. 14\\displaystyle\\frac{1}{4}41​            C. 13\\displaystyle\\frac{1}{3}31​             D. 12\\displaystyle\\frac{1}{2}21​\n\n原图像大小为 800×600×24800\\times600\\times24800×600×24\n256=28256=2^8256=28\n新图像大小为 800×600×8800\\times 600\\times8800×600×8\n所以新图像为原图像大小的 13\\frac{1}{3}31​ ，选 CCC\n\n\n\n一个大小为 1.68MB1.68MB1.68MB 且未经压缩的 WAV 音频文件，其参数如下，则量化位数 YYY 的值为多少（）\nWave pcm signed (Y位),44.1kHz,1376kbps,立体声,10秒Wave\\ pcm\\ signed\\ (Y\\text{位}), 44.1kHz,1376kbps, \\text{立体声}, 10 \\text{秒}\nWave pcm signed (Y位),44.1kHz,1376kbps,立体声,10秒\nA. 4          B. 8         C. 16          D. 32\n\n44.1kHz44.1kHz44.1kHz 为采样频率，决定了模拟信号转化为数字信号每秒的采样次数，越高，越还原现实生活中的声音\n1376kbps1376kbps1376kbps 是比特率，这是音频的元数据，代表音频播放时候的负载\n立体声，代表声道数\n10秒10 秒10秒，代表音频的时长\n音频文件大小的计算公式为 采样频率×量化位数×声道数×时间，单位为比特\\text{采样频率}×\\text{量化位数}×\\text{声道数}×时间，单位为比特采样频率×量化位数×声道数×时间，单位为比特\n用到这道题，就是 44100×量化位数×2×10=1.68×1024×1024×844100\\times 量化位数\\times2\\times10=1.68\\times1024\\times1024\\times844100×量化位数×2×10=1.68×1024×1024×8\n量化位数=1.68×1024×1024×844100×2×10≈15.9783量化位数=\\displaystyle\\frac{1.68\\times1024\\times1024\\times8}{44100\\times2\\times10} \\approx 15.9783量化位数=44100×2×101.68×1024×1024×8​≈15.9783\n所以这道题选 CCC\n\n\n\n有一段 25帧/秒未经压缩的 AVI 格式无声视频，每帧画面为 512*384 像素、24 位真彩色、视频时长为 10 秒，压缩为 MP4 格式后的文件大小约为 1.3MB，则压缩比约为（）\nA. 11:1           B. 32:1            C. 80:1             D. 108:1\n\n512×384×24×25×101.3×1024×1024×8≈108.173\\displaystyle\\frac{512\\times384\\times24\\times25\\times10}{1.3\\times1024\\times1024\\times8} \\approx 108.1731.3×1024×1024×8512×384×24×25×10​≈108.173\n选 DDD\n\n\n\n5 致命的网络\n5.1 子网划分\n\n\n已知某主机 IP 地址是 141.14.72.24 ，子网掩码是 255.255.192.0。该主机的网络号是（）\nA. 141.14.64.0            B. 141.14.72.0             C. 141.14.192.0             D. 141.14.64.72\n\n网络号，就是网段\n子网掩码是 255.255.192.0 ，192=128+64 =&gt; 11000000\n我们把主机 IP 后面两段改写成二进制：\n72 = 64+8 =&gt; 1001000\n24 = 16+8 =&gt; 11000\n进行与运算\n100100011000000=01000000\\begin{aligned}\n1001000&amp;\\\\\n11000000&amp;\\\\\n=01000000&amp;\n\\end{aligned}\n100100011000000=01000000​​\n转为十进制为 646464 ，答案选 A\n\n\n\nIP 地址 20.112.17.12 所属的子网可能是（）\nA. 20.96.0.0/11       B. 20.112.16.0/24       C. 20.112.17.8/30        D. 20.112.18.0/23\n\n首先，IP 所属的子网的意思是，这个 IP 是哪个 IP 的子网，也就是说 20.112.17.12 本身就是一个子网 IP\n将 IP 地址转成二进制\n20 = 16+4 =&gt; 10100\n112 = 64+32+16 =&gt; 1110000\n17 = 16+1 =&gt; 10001\n12 = 8+4 =&gt; 1100\n我们先看 A ，网络位是 11，所以他的子网掩码是 255.224.0.0，IP 范围是 20.96.0.0~20.127.255.255，其中 20.96.0.0 为网关，20.127.255.255 为广播地址，在范围里，所以 AAA 可能是\n再看 B，网络为是 24，所以他的子网掩码是 255.255.255.0，IP 范围是 20.112.16.0~20.112.16.255，其中 20.112.16.0 是网关，20.112.16.255 是广播地址，明显不在范围里，所以 B 不对\n再看 C，网络位是 30，这一看就不对，就最后两位可以作为子网使用，范围直接写 20.112.17.8~20.112.17.11 ，其中 20.112.17.8 为网关，20.112.17.11 为广播地址，明显错误\n再看 D，网络位是 23，所以他的子网掩码是 255.255.254.0，IP 范围是 20.112.18.0~20.112.18.255，其中 20.112.18.0 为网关，20.112.18.255 为广播地址，明显错误\n\n\n\n6 进制\n二进制, 八进制, 十进制, 十六进制\n6.1 二进制 转 十进制\n\n比如: 100110111001101110011011 , 四位四位地看 , 后四位是 8+2+1=118+2+1=118+2+1=11 , 前四位是 128+16=144128+16=144128+16=144 所以 11+144=15511+144=15511+144=155\n\n其实二进制转十进制是最特殊的一个 , 因为十进制没法完美地二分 , 所以采用的拆分 , 然后加和 , 其他那些可以完美拆分的进制只需要拆分完 , 然后把拆分的部分单独拿出来进行进制换算就可以,我们下面就会提到\n\n6.2 二进制 八进制 互转\n\n还是比如: 1001 10111001\\ 10111001 1011 , 三位三位地看 ,  后三位是 2+1=32+1=32+1=3 , 再往前 (16+8)÷8=3(16+8)\\div 8=3(16+8)÷8=3 , 再往前是 128÷64=2128\\div 64=2128÷64=2 , 所以 , 最后是 233233233\n同样八进制 转 二进制 , 比如 374637463746 , 直接展开即可 , 3=0113=0113=011 , 7=1117=1117=111 , 4=1004=1004=100 , 6=1106=1106=110 , 拼起来就是 0111 1110 01100111\\ 1110\\ 01100111 1110 0110\n\n记住 , 每一个八进制都是 3 位二进制 , 即使有 000 也得写上 , 不能省略\n\n6.3 二进制 十六进制 互转\n\n十六进制和八进制是类似的 , 只是八进制每一位对应 3 位二进制 , 十六进制则每一位对应 4 位二进制\n还是比如: 100110111001101110011011 , 四位四位地看 , 后四位是 8+2+1=11=B8+2+1=11=B8+2+1=11=B , 前四位是 8+1=98+1=98+1=9 , 拼起来就是 9B9B9B\n反过来 , 十六进制转二进制 , 8CF30A8CF30A8CF30A , 8=10008=10008=1000 , C=12=1100C=12=1100C=12=1100 , F=1111F=1111F=1111 , 3=00113=00113=0011 , 0=00000=00000=0000 , A=1010A=1010A=1010 , 拼起来就是 1000 1100 1111 0011 0000 10101000\\ 1100\\ 1111\\ 0011\\ 0000\\ 10101000 1100 1111 0011 0000 1010\n6.4 十进制转各个进制\n除 x 取余法除\\ x\\ 取余法\n除 x 取余法\n6.4.1 转二进制 , x=2x=2x=2\n我们转一下 196196196\n\n答案是 1100 01001100\\ 01001100 0100\n6.4.2 转八进制 , x=8x=8x=8\n同样还是 196196196\n\n答案是 304304304\n6.4.3 转十六进制 , x=16x=16x=16\n同样还是 196196196\n\n答案是 C4C4C4\n7 原码 , 反码 , 补码\n为了运算方便 , 机器数有 3 种表示法 , 原码 , 反码 , 补码\n7.1 原码\n原码表示法在数值前面增加了一位符号位（即最高位为符号位）\n正数该位为 0，负数该位为 1（0 有两种表示：+0 和 -0），其余位表示数值的大小。\n举个例子，我们用 8 位二进制表示一个数，+12 的原码为 0000 11000000\\ 11000000 1100，-12 的原码就是 1000 11001000\\ 11001000 1100。\n7.2 反码\n使用原码在进行加法时，计算机需要先识别某个二进制原码是正数还是负数，识别出来之后再进行相应的运算。\n这样效率不高，能不能让计算机在进行运算时不用去管符号位，也就是让符号位参与运算。\n要实现这个功能，我们就要用到反码\n正数的反码和原码一样，负数的反码就是在原码的基础上符号位保持不变，其他位取反。\n\n\n\n十进制\n原码\n反码\n\n\n\n\n6\n0000 0110\n0000 0110\n\n\n-3\n1000 0011\n1111 1100\n\n\n\n然后我们计算 6−36-36−3 也就是 6+(−3)6+(-3)6+(−3)\n//6 - 3 ==&gt; 6 + (-3)  0000 0110 // 6(反码)+ 1111 1100 // -3(反码)----------------------  0000 0010 // (反码)  0000 0010 // 2(原码)\n很明显通过反码进行 6+(−3)6 + (-3)6+(−3) 加法运算时，输出值比预期值差了一个 111。接着我们再来看下 1+(−1)1 + (-1)1+(−1) 的运算结果：\n//1 - 1 ==&gt; 1 + (-1)  0000 0001 // 1(反码)+ 1111 1110 // -1(反码)----------------------  1111 1111 // (反码)  1000 0000 // -0(原码)\n由上可知 1+(−1)1 + (-1)1+(−1) 的运算结果为 −0-0−0，而我们预期的值是 +0+0+0。我们继续看个示例 0+00 + 00+0 ：\n//0 + 0 ==&gt; 0 + 0  0000 0000 // 0(反码)+ 0000 0000 // 0(反码)----------------------  0000 0000 // (反码)  0000 0000 // 0(原码)\n这里我们可以知道 −0-0−0 对应的原码是 1000 00001000\\ 00001000 0000 , 而 +0+0+0 对应的原码是 0000 00000000\\ 00000000 0000。虽然 −0-0−0 和 +0+0+0 代表的数值是一样的，但是在用原码和反码表示时它们是不同的。\n通过以上的多个示例，我们发现使用反码进行加法运算并不能保证得出正确的结果。\n原因是用一个字节表示数字的取值范围时，这些数字中多了一个 −0-0−0。为了解决反码出现的问题，就出现了补码。\n7.3 补码\n正数和 000 的补码就是该数字本身.\n负数的补码则是将其对应正数按位取反再加 111 .\n\n\n\n十进制\n原码\n反码\n补码\n\n\n\n\n666\n0000 01100000\\ 01100000 0110\n0000 01100000\\ 01100000 0110\n0000 01100000\\ 01100000 0110\n\n\n−3-3−3\n1000 00111000\\ 00111000 0011\n1111 11001111\\ 11001111 1100\n1111 11011111\\ 11011111 1101\n\n\n\n6+(−3)6 + (-3)6+(−3) 以补码形式的计算过程如下：\n//6 - 3 ==&gt; 6 + (-3)  0000 0110 // 6(补码)+ 1111 1101 // -3(补码)----------------------  0000 0011 // 3(补码)\n很明显这时我们得到了正确的结果，那么我们再来看一下以补码形式计算 1−11 - 11−1 的计算过程：\n//1 - 1 ==&gt; 1 + (-1)  0000 0001 // 1(补码)+ 1111 1111 // -1(补码)----------------------  0000 0000 // 0(补码)\n可以发现，补码完美解决了反码的问题\n8 移位运算\n位移运算需要使用按位移动操作符，它有两个操作数：第一个是要被移动的数字，而第二个是要移动的长度。移动的方向根据操作符的不同而不同。\n按位移动会先将操作数转换为大端字节序顺序（big-endian order）的 32 位整数，并返回与左操作数相同类型的结果。右操作数应小于 32 位，否则只有最低 5 个字节会被使用。\n8.1 左移(&lt;&lt;)\n该操作符会将第一个操作数向左移动指定的位数。\n向左被移出的位被丢弃，右侧用 0 补充。以 9 &lt;&lt; 2 为例：\n     9 (base 10): 00000000000000000000000000001001 (base 2)                  --------------------------------9 &lt;&lt; 2 (base 10): 00000000000000000000000000100100 (base 2) = 36 (base 10)\n在数字 x 上左移 y 位时，得出的结果是 x×2yx \\times 2^yx×2y，即 9 &lt;&lt; 2 = 9∗229 * 2^29∗22。\n8.2 有符号右移(&gt;&gt;)\n该操作符会将第一个操作数向右移动指定的位数。\n向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。\n由于新的最左侧的位总是和以前相同，符号位没有被改变。\n所以被称作 “符号传播”。\n例如， 9 &gt;&gt; 2 得到 2：\n     9 (base 10): 00000000000000000000000000001001 (base 2)                  --------------------------------9 &gt;&gt; 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)\n相比之下， -9 &gt;&gt; 2 得到 -3，因为符号被保留了。\n     -9 (base 10): 11111111111111111111111111110111 (base 2)                   ---------------------------------9 &gt;&gt; 2 (base 10): 11111111111111111111111111111101 (base 2) = -3 (base 10)\n8.3 无符号右移(&gt;&gt;&gt;)\n该操作符会将第一个操作数向右移动指定的位数。\n向右被移出的位被丢弃，左侧用 0 填充。\n因为符号位变成了 0，所以结果总是非负的。\n对于非负数，有符号右移和无符号右移总是返回相同的结果。例如 9 &gt;&gt;&gt; 2 和 9 &gt;&gt; 2 一样返回 2：\n      9 (base 10): 00000000000000000000000000001001 (base 2)                   --------------------------------9 &gt;&gt;&gt; 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)\n但是对于负数却不尽相同。 -9 &gt;&gt;&gt; 2 产生 1073741821 这和 -9 &gt;&gt; 2 不同：\n      -9 (base 10): 11111111111111111111111111110111 (base 2)                    ---------------------------------9 &gt;&gt;&gt; 2 (base 10): 00111111111111111111111111111101 (base 2) = 1073741821 (base 10) -9 &gt;&gt; 2 (base 10): 11111111111111111111111111111101 (base 2) = -3 (base 10) \n","tags":["教资","CRC"]},{"title":"虚幻5 乱七八糟的小问题","url":"/2024/03/25/%E8%99%9A%E5%B9%BB5%20%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/","content":"背景\n我最近在玩 虚幻5，并且还为此买了张显卡\n为啥不用 Mac 开发 虚幻5 呢？\n使用 虚幻5 会发生什么问题呢？\n问题\n\n首先是就是没有 VS，无法打开 sln项目，Uproject 还有一些限制，但好像使用 Xcode 也可以，我还没试过\n我感觉这就是 Bug，Mac 会出现输入中文失灵的情况，就是无法输入中文，时好时坏，目前很多教程都是纯中文，不能输入中文会很麻烦\n随时保存，这是很多博主经常说的，因为虚幻编辑器崩溃时有发生，而且是直接闪退\n\n","tags":["游戏","虚幻引擎","虚幻5","game"]},{"title":"斐波那契数列多解","url":"/2023/11/15/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%A4%9A%E8%A7%A3/","content":"\n斐波那契数列在算法中占有很高的地位，\n主要是很多题目背后的根源都是斐波那契数列\n\n递归法\n算法思路\n递归\n代码\nprivate fun fibonacci(n: Int): Int &#123;  if (n &lt; 0) &#123;    return -1  &#125;  if (n == 0) &#123;    return 0  &#125;  if (n == 1) &#123;    return 1  &#125;  return fibonacci(n - 1) + fibonacci(n - 2)&#125;\n复杂度分析\n时间复杂度O(2n2^n2n) , 空间复杂度 O(n)\n时间复杂度怎么算呢？\n首先这个斐波那契数列 递归求解 的数据结构是二叉树，并且一次只访问一个结点\n怎么回事呢？\n因为fibonacci这个函数一次值返回一个数值，也就是每一次调用这个函数，就相当于访问一个节点，而 return说明了这是二叉树，也就是两个分支\n迭代法\n算法思路\n迭代，打表法\n代码\nprivate fun fibonacci2(n: Int): Long &#123;  if (n &lt; 0) &#123;    return -1  &#125;  if (n == 0) &#123;    return 0  &#125;  if (n == 1) &#123;    return 1  &#125;  val intArray = LongArray(n + 1) &#123; 0 &#125;  intArray[0] = 0  intArray[1] = 1  for (i in 2..n) &#123;    intArray[i] = intArray[i - 1] + intArray[i - 2]  &#125;  return intArray[n]&#125;\n可以通过滚动数组节省空间\nprivate fun fibonacci2(n: Int): Long &#123;  if (n &lt; 0) &#123;    return -1  &#125;  if (n == 0) &#123;    return 0  &#125;  if (n == 1) &#123;    return 1  &#125;  val longArray = LongArray(2) &#123; 0 &#125;  longArray[0] = 0  longArray[1] = 1  var result: Long = -1  for (i in 2..n) &#123;    result = longArray[0] + longArray[1]    longArray[0] = longArray[1]    longArray[1] = result  &#125;  return result&#125;\n复杂度分析\n第一个时间复杂度是 O(n)，空间复杂度是 O(n)\n第一个时间复杂度是 O(n)，空间复杂度是 O(1)\n通项公式法\n算法思路\n首先我们看 斐波那契数列的递推公式：\n\n我们假设两个常数 A、B 他们能组成下面形式，这是数学的惯用手法，递推公式求解通项公式的很多时候可以用这个方法，为的就是将递推公式变成等比数列的形式：\n\n也就是这样的形式：\n\n\n既然 A、B 可以有确定值，剩下的就是等比数列求解了：\n\n\n\n这里我们用同样的方法，假设一个常数 C，然后等比数列求解：\n\n\n\n最后代数进去，就是我们的通项公式了:\n\n代码\n然后我们就能可以使用通项公式来写这个函数了\nfun fibonacci3(n: Int): Double &#123;  val v1 = (1 + sqrt(5.0)) / 2  val v2 = (1 - sqrt(5.0)) / 2  val v3 = sqrt(5.0)  return (pow(v1, n) - pow(v2, n)) / v3&#125;\n复杂度分析\n很多文章写这种方式时间复杂度为 O(1)，这是明显错误的，因为计算 pow 的时间复杂度本就不是 O(1)，总不能因为你调用了某个方法，就默认他方法的复杂度是 O(1) 吧\n无论是官方的还是第三方的次幂运算（pow），最低也就能将复杂度降到O(logn)\n而对于根号运算（sqrt），这个通常都是在操作系统底层，这种运算都是高度优化的，复杂度绝对不会高于 O(logn)\n下面我展示一下我自己写的一个 pow 运算\nfun pow(x: Int, n: Int): Int &#123;  var m = n  var r = 1  var v = x  while (m &gt; 0) &#123;        // 如果 m 是奇数，那么 r 先乘以 v ,消耗 m 一次    if (m % 2 == 1) &#123;      // 此处计算的是平奇操作，也就是将奇数的次幂先乘到 r 上，      // 再让底数相乘，次幂减半，最后当 m=1 时，将 底数再与 人相乘，得到最终结果      r *= v      m -= 1    &#125;    // 此时 m 一定是偶数，让底数平方，次数除以 2    v *= v    m /= 2        // 一次循环结束，此时结果进行了平奇处理，底数平方了，次数变为了一半  &#125;  return r&#125;\n所以时间复杂度是 O(logn)，空间复杂度是 O(1)\n","tags":["算法","斐波那契"]},{"title":"直播方案分享","url":"/2023/09/13/%E7%9B%B4%E6%92%AD%E6%96%B9%E6%A1%88%E5%88%86%E4%BA%AB/","content":"9-13 直播方案分享\n拓扑图\n\n硬件设备\n\nMacBook 写代码用\nWindows 推流用，因为老 MacBook 性能太羸弱\n两个显示器（4k 接 MacBook，2k 接 Windows 用来监看推流）\n一个 150 元左右的采集卡（4k60 环出，1080p 60 采集）\n\n软件设备\n\nobs（Windows 端）\nloopback（Mac 端）\n\n软件设置\n\n\nobs 设置\n\n\n\n\n\n\nloopback 设置\n\n这样将Chrome和MacBook麦克风分开传输，可以准确控制音源的输入输出\n将Chrome输出给蓝牙音响和HDMI\n将麦克风输出给HDMI\n还可以添加其他应用\n\n\n","tags":["Mac","Windows","直播","设备","方案"]},{"title":"读《深入理解 kotlin 协程》- 01 同步异步","url":"/2023/10/29/%E8%AF%BB%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-kotlin-%E5%8D%8F%E7%A8%8B%E3%80%8B-01-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5/","content":"\n  \n    \n      特别提醒\n\n    \n    \n      如果可以，购买《深入理解 kotlin 协程》支持作者 bennyhuo 霍丙乾！！！\n\n    \n  \n异步和同步\n异步和同步主要说的是代码执行的逻辑顺序\n异步的概念\nfun main() &#123;  // 同步代码  print(&quot;A&quot;)  print(&quot;B&quot;)  print(&quot;C&quot;)  print(&quot;D&quot;)  // 异步代码  print(&quot;A&quot;)  thread &#123;    print(&quot;C&quot;)    print(&quot;D&quot;)  &#125;  print(&quot;B&quot;)&#125;\n对于同步代码，输出的肯定是ABCD\n而对于异步代码，最早输出的是A，但是B会在CD之前、之间还是之后，可就不一定了\n如图：\n\n异步设计的关键问题\n结果传递\nfun asyncBitmap(    url: String,    callback: (Bitmap) -&gt; Unit): Bitmap? &#123;    return when (val bitmap = Cache.get(url)) &#123;        null -&gt; &#123;            thread &#123;                download(url)                    .also &#123; Cache.put(url, it) &#125;                    .also(callback)            &#125;            null        &#125;        else -&gt; bitmap    &#125;&#125;\n当Cache有bitmap的时候，就直接返回，否则就起一个线程来下载，并返回null\nfun main() &#123;  callAsync &#123;    println(&quot;End 0&quot;)    callAsync &#123;      println(&quot;End 1&quot;)    &#125;  &#125;&#125;fun callAsync(callback: (Bitmap) -&gt; Unit) &#123;  val bitmap = asyncBitmap(    &quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;  ) &#123; bitmap -&gt;    println(&quot;Async: $bitmap&quot;)    callback(bitmap)  &#125;  println(&quot;Main $bitmap&quot;)  if (bitmap != null) &#123;    callback(bitmap)  &#125;&#125;\n\n这里异步调用略微有点多，我们一点点看\n首先我们先不看第二个callAsync，只假设main函数里callAsync只调用了println(&quot;End 0&quot;)，并没有调用第二个callAsync，这样会容易一些\n\n我们先看callAsync的定义，里面只有 3 个操作\n\n调用asyncBitmap去获取bitmap\n打印Main $bitmap\n在bitmap非空的时候，调用callback这个 callback 就是println(&quot;End 0&quot;)\n\n然后再看asyncBitmap，发现Cache里没有bitmap，就会起一个线程下载图片并返回null\n在下载成功的时候调用callback，这个callback就是比println(&quot;End 0&quot;)多打印了一个println(&quot;Async: $bitmap&quot;)\nprintln(&quot;Async: $bitmap&quot;)println(&quot;End 0&quot;)\n所以应该很清楚了\n它去缓存里看是否有bitmap，如果有就返回，然后在同步代码调用println(&quot;End 0&quot;)\n如果缓存没有bitmap，就下载，在异步代码里调用println(&quot;End 0&quot;)\n所以这个println(&quot;End 0&quot;)是在获取到bitmap之后，再调用的\n然后我们再回过头来看我们忽略的第二个callAsync，是不是就是在上一段callAsync之后，再进行一次callAsync啊！\n而这次我们Cache里面就有bitmap了，就不用再下载了，所以直接返回就行了\n根据我们的猜测他的输出结果应该是什么呢？\nMain nullAsync: [B@4bd36c21End 0Main [B@4bd36c21End 1\n前三行就是第一个callAsync\n后两行就是第二个callAsync\n\n当然，通常我们不会如此设计回调API，因为这样反而让程序写起 来更复杂了。更为常见的做法是，在结果就绪的情况下仍然立即以回 调的形式传递给调用方，以保证结果传递方式的透明性。\nKotlin协程的挂起函数（suspend function）本质上就采取 了这个异步返回值的设计思路\n\n异常处理\n我们改写一下asyncBitmap，去掉返回值，加上异常处理\nfun asyncBitmap(  url: String, onSuccess: (Bitmap) -&gt; Unit,  onError: (Throwable) -&gt; Unit) &#123;  thread &#123;    try &#123;      download(url).also(onSuccess)    &#125; catch (e: Exception) &#123;      onError(e)    &#125;  &#125;&#125;fun callAsync2() &#123;  try &#123;    val url = &quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;    checkUrl(url)    asyncBitmap(url, onSuccess = ::show, onError = ::showError)  &#125; catch (e: Exception) &#123;    showError(e)  &#125;&#125;\n可以看到，我们不仅仅对download进行了异常捕获，而对于url也进行了异常捕获（毕竟一个不合法的url你怎么都没法处理，只能抛异常了）\n通常情况下，我们需要在同步代码和异步代码都进行异常捕获，为什么呢？\n你们看callAsync2，如果只在这个函数里进行异常捕获，那么还能捕获到download的异常吗？\n很显然不能，因为它起了另一个线程，已经不是同一个栈了\n\n而协程他就是想解决将异步逻辑同步化，让异步的异常处理可以向同步处理一样\n就像这样：\n\n\n取消响应\n稍微了解过Java多线程的肯定都知道，取消或者中断一个线程并不是一件容易的事\n现在往往是调用interrupt()函数，然后等待线程判断到interrupted()，再自我执行中断逻辑\n也就是需要被中断的线程配合才能中断，但线程如果不配合，你也没办法，这时的异步任务颇有断线风筝的意思，能否回来只能看风筝自己的“心情”了。\nfun asyncBitmapCancellable(  url: String, onSuccess: (Bitmap) -&gt; Unit,  onError: (Throwable) -&gt; Unit) = thread &#123;  try &#123;    downloadCancellable(url).also(onSuccess)  &#125; catch (e: Exception) &#123;    onError(e)  &#125;&#125;fun downloadCancellable(url: String): Bitmap &#123;  return getAsStream(url).use &#123; inputStream -&gt;    val bos = ByteArrayOutputStream()    val buffer = ByteArray(1024)    while (true) &#123;      val length = inputStream.read(buffer, 0, 1024)      ......      if (Thread.interrupted())        throw InterruptedException(&quot;Task is cancelled.&quot;)    &#125;    bos.toByteArray()  &#125;&#125;\n\nJDK最初提供了停止线程的API，但它很快就被废弃 了，因为强行停止一个线程会导致该线程中持有的资源无法正常释 放，进而出现不安全的程序状态。\n\n添加分支\n我们可以为同步的逻辑添加分支甚至循环操作，这非常容易，但对于异步的逻辑而言，想要做到这一点就相对困难了。\n\n当然这里同步逻辑的分支肯定也是同步的，异步逻辑的分支肯定也是异步的\n\nval urls = arrayOf(  &quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;,  &quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;,  &quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;)fun loopOnAsyncCalls() &#123;  val countDownLatch = CountDownLatch(urls.size)  val map = urls.associateWithTo(ConcurrentHashMap&lt;String, Bitmap&gt;()) &#123; EMPTY_BITMAP &#125;  urls.map &#123; url -&gt;    asyncBitmap(url, onSuccess = &#123;      map[url] = it      countDownLatch.countDown()    &#125;, onError = &#123;      showError(it)      countDownLatch.countDown()    &#125;)  &#125;  countDownLatch.await()  val bitmaps = map.values&#125;fun asyncBitmap(  url: String, onSuccess: (Bitmap) -&gt; Unit,  onError: (Throwable) -&gt; Unit) &#123;  thread &#123;    try &#123;      download(url).also(onSuccess)    &#125; catch (e: Exception) &#123;      onError(e)    &#125;  &#125;&#125;\n\ncountDownLatch是一个计数器，我们这里让系统下载3个图片，就初始化为3\n每下载完成或者下载失败就调用countDownLatch.countDown()让数值减1\n然后调用countDownLatch.await()在这里阻塞，等待数值降到0\n\n\n我们再写一个同步流程，同样下载三个图片\nval urls = arrayOf(  &quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;,  &quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;,  &quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;)fun loopOnSyncCalls() &#123;  val bitmaps = urls.map &#123; download(url) &#125;&#125;\n然后再测量这两次的耗时\nfun main() &#123;  download(&quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;)  measureTimeMillis &#123;    loopOnAsyncCalls()  &#125;.let(::println)  measureTimeMillis &#123;    loopOnSyncCalls()  &#125;.let(::println)&#125;\ndownload是为了先握手，这样后续就可以直接下载，无需握手，让对比更公平\n181279\n可以看到，确实有一些差距，异步分支确实可以节省一些时间，更充分地利用性能\n\n想想，如果你需要在异步逻辑里写循环，你还希望回收这些个线程，还有可能中断线程，这可就复杂了，因为在循环里，异步逻辑有多少个，还不清楚。\n\n常见异步程序的设计思路\nJava Future\nval urls = arrayOf(  &quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;,  &quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;,  &quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;)fun bitmapFuture(url: String): Future&lt;Bitmap&gt; &#123;  return ioExecutor.submit(Callable &#123;    download(url)  &#125;)&#125;val ioExecutor =  Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors())fun main() &#123;  val bitmaps = urls.map &#123;    bitmapFuture(it)  &#125;.map &#123;    it.get()  &#125;&#125;\n在这里，我们创建了一个线程池，通过submit获取一个Future\n\nkotlin map函数，翻译过来是映射函数，没错这个map是个动词，就是映射\npublic inline fun &lt;T, R&gt; Array&lt;out T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; &#123;    return mapTo(ArrayList&lt;R&gt;(size), transform)&#125;public inline fun &lt;T, R, C : MutableCollection&lt;in R&gt;&gt; Array&lt;out T&gt;.mapTo(destination: C, transform: (T) -&gt; R): C &#123;    for (item in this)        destination.add(transform(item))    return destination&#125;\n两个都是inline，我直接第二个合并到第一个\npublic inline fun &lt;T, R&gt; Array&lt;out T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; &#123;    val arrayList = ArrayList&lt;R&gt;(size)    for (item in this)        arrayList.add(transform(item))    return arrayList&#125;\n可以看到，返回值是List&lt;R&gt;，仅仅只调用transform(item)并添加到这个List里面\n\n第一个map返回一个List&lt;Future&gt;\n第二个map返回一个List&lt;Bitmap&gt;\n第一个map肯定很快就返回了，但是第二个map相当于在for循环里调用get函数，而get是一个阻塞函数。所以第二个map代码逻辑大概就是这样：\nfor (item in this)\tarrayList.add(future.get())\n所以，单纯使用get并不好用\n我们往往会搭配isDone来使用\n比如：\nfun main() &#123;  val bitmapLists = urls.map &#123;    bitmapFuture(it)  &#125;  val bitmaps = bitmapLists.map &#123;    while(true)&#123;      if(it.isDone())&#123;        it.get()        break      &#125;      // 执行额外逻辑    &#125;  &#125;&#125;\n你看，Future的get的阻塞性质，导致我们写出的代码都不太像异步了\nJava CompletableFuture\nJDK 1.8又新增了一个CompletableFuture类，它实现了Future接口， 通过它我们可以拿到异步任务的结果，此外，它还有很多更好用的方 法。\nfun bitmapCompletableFuture(url: String): CompletableFuture&lt;Bitmap&gt; =  CompletableFuture.supplyAsync &#123;    download(url)  &#125;fun callCompletableFuture() &#123;  urls.map &#123;    bitmapCompletableFuture(it)  &#125;.let &#123; futureList -&gt;    CompletableFuture.allOf(*futureList.toTypedArray())      .thenApply &#123;        futureList.map &#123; it.get() &#125;      &#125;  &#125;.thenAccept &#123; bitmaps -&gt;    println(bitmaps.size)  &#125;.join()&#125;\n这里allof是用于等待所有CompletableFuture。\nthenApply用于在所有CompletableFuture完成后，将结果映射为一个包含所有Bitmap的列表\nthenAccept用于在所有图片都下载完成后执行指定的操作，这里只是输出图片的数量。\n\n虽然CompletableFuture解决了异步结果不阻塞主调用流程的问题，但却让结果的获取脱离了主调用流程。\n就类似retrofit默认回调那样\n\nJavaScript Promise 与 async/await\nCompletableFuture还实现了另一个接口——CompletionStage， 前面我们用到的thenAccept类似的方法也都是这个接口的API。从定义 和功能来看，CompletionStage是一个Promise。\n那么Promise又是什么呢?按照  Promises/A+ ，Promise是一个异步任务，它存在挂起、完成、拒绝三个状态，当它处在完成状态时，结果 通过调用then方法的参数进行回调；出现异常拒绝时，通过catch方法 传入的参数来捕获拒绝的原因。\n从ECMAScript 6开始，JavaScript就已经支持Promise了，我们先 来看之前的例子怎么用Promise来实现\nconst urls = [    &quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;,    &quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;,    &quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;];function main() &#123;    Promise.all(urls.map(url =&gt; bitmapPromise(url)))        .then(bitmaps =&gt; console.log(bitmaps.length))        .catch(e =&gt; console.error(e));&#125;function bitmapPromise(url) &#123;    return new Promise((resolve, reject) =&gt; &#123;        try &#123;            download(url, resolve)        &#125; catch (e) &#123;            reject(e)        &#125;    &#125;)&#125;function download(url, callback) &#123;    https.get(url, (res) =&gt; &#123;            let data = &#x27;&#x27;;            res.on(&#x27;data&#x27;, chunk =&gt; &#123;                data += chunk;            &#125;);            res.on(&#x27;end&#x27;, () =&gt; &#123;                callback(data)            &#125;);        &#125;    );&#125;\n第8行，Promise.all会将多个Promise整合到一起，这与我们前面为整合CompletableFuture而定义的List&lt;CompletableFuture&lt;T&gt;&gt;.allOf如出 一辙。\n最终我们得到一个新的Promise，它的结果是整合了前面所有bitmapPromise函数返回的结果的bitmaps，因此我们在then当中传入 的Lambda表达式就是用来处理消费这个bitmaps的。\n这样看起来很不错，达到了与CompletableFuture同样的效果，不 过还可以更简洁。\n我们可以通过async/await将上面的代码进一步简化\nasync function asyncMain() &#123;    try &#123;        const bitmaps = await Promise.all(urls.map(url =&gt; bitmapPromise(url)));        console.log(bitmaps);    &#125; catch (e) &#123;        console.error(e);    &#125;&#125;\n给整个逻辑的外部函数加上了async关键字，这样就可以在异 步调用返回Promise的位置加上await，这个语法糖可以把前面的then和catch调用转换成我们熟悉的同步调用语法。\n这样就非常像样了，我们通过同步代码执行了异步流程\n响应式编程\n写过rxJava、liveData、 观察者模式之类的代码坑你定对响应式编程比较熟悉\nfun main() &#123;  Single.just(&quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;)    .map &#123; download(it) &#125;    .subscribeOn(Schedulers.io())    .subscribe(&#123; bitmap -&gt;      show(bitmap)    &#125;, &#123; throwable -&gt;      showError(throwable)    &#125;)  Thread.sleep(10000)&#125;\nSingle是RxJava提供的一个像Promise的API\n不过，Observable跟前面提到的Future和Promise有一个很大的不 同，它的逻辑执行取决于订阅，而不是立即执行。\n此外，它还提供了 任意变换之间可以切换线程调度器的能力，这一能力让复杂的数据变 换和流转可以轻易实现异步。\n当然，这也曾一度让它被滥用为线程切换的工具。\nkotlin 协程\nsuspend fun bitmapSuspendable(url: String): Bitmap =  suspendCoroutine &#123; continuation -&gt;    thread &#123;      try &#123;        continuation.resume(download(url))      &#125; catch (e: Exception) &#123;        continuation.resumeWithException(e)      &#125;    &#125;  &#125;suspend fun main() &#123;  try &#123;    val bitmap = bitmapSuspendable(&quot;https://www.bennyhuo.com/assets/avatar.jpg&quot;)    show(bitmap)  &#125; catch (e: Exception) &#123;    println(&quot;下载失败&quot;)    e.printStackTrace()  &#125;  println(&quot;hello world!&quot;)&#125;\n我们使用标准库APIsuspendCoroutine&lt;T&gt;函数的返回值类型作为 挂起函数bitmap-Suspendable的返回值类型，也就是泛型参数T的实参Bitmap。\n这个函数除了确定返回值类型外，还能够帮我们拿到一个Continuation的实例，负责保存和恢复挂起状态，逻辑效果上类似于Promise，其中几个函数意义如下。\n-resume: 类似于Promise的resolve，将正常的结果返回，它的参数实际上就是bitmapSuspendable的返回值Bitmap。\n-resumeWithException: 类似于Promise的reject，将异常返回，它的参数实际上就是bitmapSuspendable调用时会抛出的异常。\n看我们调用的时候，直接try-catch\n现在我们关掉网络，跑一遍\n下载失败hello world!java.net.UnknownHostException: www.bennyhuo.com: nodename nor servname provided, or not known    at java.base/java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)    at java.base/java.net.InetAddress$PlatformNameService.lookupAllHostAddr(InetAddress.java:930)    at java.base/java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1543)    at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:848)    at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1533)    at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1386)    at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1307)    at okhttp3.Dns.lambda$static$0(Dns.java:39)    at okhttp3.internal.connection.RouteSelector.resetNextInetSocketAddress(RouteSelector.java:171)    at okhttp3.internal.connection.RouteSelector.nextProxy(RouteSelector.java:135)    at okhttp3.internal.connection.RouteSelector.next(RouteSelector.java:84)    at okhttp3.internal.connection.ExchangeFinder.findConnection(ExchangeFinder.java:187)    at okhttp3.internal.connection.ExchangeFinder.findHealthyConnection(ExchangeFinder.java:108)    at okhttp3.internal.connection.ExchangeFinder.find(ExchangeFinder.java:88)    at okhttp3.internal.connection.Transmitter.newExchange(Transmitter.java:169)    at okhttp3.internal.connection.ConnectInterceptor.intercept(ConnectInterceptor.java:41)    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:142)    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:117)    at okhttp3.internal.cache.CacheInterceptor.intercept(CacheInterceptor.java:94)    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:142)    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:117)    at okhttp3.internal.http.BridgeInterceptor.intercept(BridgeInterceptor.java:93)    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:142)    at okhttp3.internal.http.RetryAndFollowUpInterceptor.intercept(RetryAndFollowUpInterceptor.java:88)    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:142)    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:117)    at common.api.ApiKt$httpClient$2.invoke$lambda$1(Api.kt:12)    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:142)    at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:117)    at okhttp3.RealCall.getResponseWithInterceptorChain(RealCall.java:229)    at okhttp3.RealCall.execute(RealCall.java:81)    at ch01.Listing05_06Kt.getAsStream(Listing05_06.kt:61)    at ch01.Listing05_06Kt.download(Listing05_06.kt:51)    at ch01.Listing23_24Kt$bitmapSuspendable$2$1.invoke(Listing23_24.kt:12)    at ch01.Listing23_24Kt$bitmapSuspendable$2$1.invoke(Listing23_24.kt:10)    at kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)\n这里看到，信息都清楚地打印出来了\n总结\n\n\n本质上，异步和同步这两个概念探讨的是程序的控制流程，异步的同时也经常伴随着并发，但这不是必然的。\n\n\nKotlin协程是用来简化异步程序设计的，可以在实现任务的异步调用的同时，降低代码的设计复杂度，进而提升代码可读性。\n\n\n","tags":["线程","协程","异步","同步"]},{"title":"数据库-关系代数","url":"/2024/04/22/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/","content":"传统的集合运算\n1. 并\nR∪SR \\cup SR∪S\n2. 交\nR∩SR \\cap SR∩S\n3. 差\nR−SR - SR−S\n4. 笛卡尔积\nR×SR \\times SR×S\n4.1 域\n域是一组具有相同数据类型的值的集合, 例如: { 李明, 张三 , 王五} , { 男, 女 } , { 计算机 , 旅游管理 }\n4.2 笛卡尔积\n笛卡尔积是域上的集合运算, 允许某些域上是相同的\n按域的顺序, 每个域任取一个值, 列出所有的组合, 就是笛卡尔积\nD1×D2×⋅⋅⋅Dn={(d1,d2⋅⋅⋅dn)∣di∈Di, i=1,2, ⋅⋅⋅ ,n}D_1\\times D_2\\times \\cdot\\cdot\\cdot D_n=\\{(d_1,d_2\\cdot \\cdot \\cdot d_n)|d_i\\in D_i,\\ i=1,2,\\ \\cdot\\cdot\\cdot \\ ,n\\}D1​×D2​×⋅⋅⋅Dn​={(d1​,d2​⋅⋅⋅dn​)∣di​∈Di​, i=1,2, ⋅⋅⋅ ,n}\n\n\n\n姓名\n性别\n专业\n\n\n\n\n李明\n男\n计算机\n\n\n李明\n男\n旅游管理\n\n\n李明\n女\n计算机\n\n\n李明\n女\n旅游管理\n\n\n张三\n男\n计算机\n\n\n张三\n男\n旅游管理\n\n\n张三\n女\n计算机\n\n\n张三\n女\n旅游管理\n\n\n王五\n男\n计算机\n\n\n王五\n男\n旅游管理\n\n\n王五\n女\n计算机\n\n\n王五\n女\n旅游管理\n\n\n\n专门的关系运算符\n前置知识\n关系模式\n表示一张表的首行信息，是一个关系的抽象，例如：关系模式：R(A1,A2,...,An)关系模式：R(A_1, A_2,...,A_n)关系模式：R(A1​,A2​,...,An​)，A1,A2,...,AnA_1, A_2,...,A_nA1​,A2​,...,An​ 是属性抽象\n比如下图表的第一行:\n\n关系\n一张表代表一个关系，n 目，表示 n 列，例如：RnR_nRn​ , 上面的图表就是一个 5 目关系\n属性\n表内的首行的每个元素叫属性，一个属性对应一列，从第二行开始，下面的都是属性的具体数值\n例如: 属性集合 A={(Ai1,Ai2,...,Aik)，i∈[1,n]}, i 是行数,k 是列数A=\\{(A_{i1}, A_{i2},...,A_{ik})，i\\in[1,n]\\},\\ i\\ \\text{是行数},k\\ \\text{是列数}A={(Ai1​,Ai2​,...,Aik​)，i∈[1,n]}, i 是行数,k 是列数，这表示第 iii 行的每列的分量集合，叫做属性组（属性列）。\nA‾\\overline{A}A 表示取反，也就是除去第 i 行的其他属性组 ( 集合 ) , 其实就是集合取反\n元组\n表内的一行叫关系的一个元组\n例如：t∈Rt\\in Rt∈R，t[Ai]t[A_i]t[Ai​] 表示 t 元组中的 AiA_iAi​ 分量，也就是属性 AAA 的第 iii 行\nStudent 表的 元组一共有 4 个 ( 不包含第一行, 也就是不包含关系模式 )\nt[Sname2]=刘晨t[Sname_2]=\\text{刘晨}\nt[Sname2​]=刘晨\nt[A]=(t[Ai1],t[Ai2],...,t[Aik])t[A] = (t[A_{i1}], t[A_{i2}], ..., t[A_{ik}])t[A]=(t[Ai1​],t[Ai2​],...,t[Aik​]) 表示元组 ttt 在属性列 AAA 上各分量的集合\n元组连接\n{trts⌢  tr∈Rn ts∈Sm}\\{\\overset{\\LARGE{\\frown}}{t_rt_s}\\,\\ t_r\\in R_n\\, t_s\\in S_m\\}{tr​ts​⌢​ tr​∈Rn​ts​∈Sm​}\n成为元组连接，形成一个 n+mn+mn+m 列的元组，前 nnn 个分量为 RRR 中的一个 nnn 元组，也就是 nnn 列，前 mmm 个分量为 SSS 中的一个 mmm 元组，也就是 mmm 列。\n其实就是把两个元组直接拼到一起\n例如将李勇和刘晨这两个元组进行连接:\n\n连接还有一些其他的形式: 等值连接, 非等值连接, 自然连接……后面会说到\n象集\n关系 R(X,Y)R(X, Y)R(X,Y) , XXX 和 YYY 为属性组。当 t[X]=xt[X]=xt[X]=x 时，xxx 在 RRR 中的象集（images set）为：Yx={ t[Y] ∣ t∈R ,t[X]=x }Y_x=\\{\\ t[Y]\\ |\\ t\\in R\\ , t[X]=x\\ \\}Yx​={ t[Y] ∣ t∈R ,t[X]=x }\n下图是 t[Y]=2t[Y]=2t[Y]=2 , yyy 在 RRR 中的象集：\n\n如果你看了后面的计算，那么象集你可以直接用选择加投影来计算象集，比如图中的就是先选择 Y=2 再做 x 的投影\n选择\nσF(R)\\sigma _F\\left(R\\right)σF​(R) 表示在 R 中选出符合条件 FFF 的元组(也就是行)\nσF(R)=t∈R∧F(t)=′真′\\sigma _F\\left(R\\right) = t \\in R \\land F(t)=&#x27;真&#x27;\nσF​(R)=t∈R∧F(t)=′真′\n\n查询所在系为 ISISIS 的学生，则 σSdept=CS(Student)\\sigma _{Sdept=CS} \\left(Student\\right)σSdept=CS​(Student) 结果如图所示\n\n查询年龄小于 20 的学生，则  σSage&lt;20(Student)\\sigma _{Sage&lt;20} \\left(Student\\right)σSage&lt;20​(Student) 结果如图所示\n\n投影\nΠA(R)\\Pi _A \\left(R\\right)ΠA​(R) 表示关系 RRR 上 AAA 的投影，是 RRR 中对应若干属性列组成新的关系 (A 是属性列) , 是只对应属性 A 的集合。\n在 StudentStudentStudent 中查询姓名与所在系的关系，ΠSname,Sdept(Student)\\Pi _{Sname,Sdept} \\left(Student\\right)ΠSname,Sdept​(Student) 结果如图所示\n   \n连接\n连接也称 θ\\thetaθ 连接. 他是从两个关系的笛卡尔积中选取属性间满足一定条件的元组\nR⋈AθBS={trts⌢ ∣ tr∈R∧ts∈S∧tr[A]θts[B]}R \\substack{\\Join \\\\ A\\theta B} S=\\{\\overset{\\LARGE{\\frown}}{t_rt_s}\\ |\\ t_r\\in R \\land t_s\\in S\\land t_r[A]\\theta t_s[B]\\}\nR⋈AθB​S={tr​ts​⌢​ ∣ tr​∈R∧ts​∈S∧tr​[A]θts​[B]}\nAθBA\\theta BAθB 是条件,  AAA 和 BBB 分别为 RRR 和 SSS 上列数相等且可比的属性组, θ\\thetaθ 是比较运算符.\n连接运算从 RRR 和 SSS 的笛卡尔积 R×SR\\times SR×S 中 , 选取 RRR 关系在 AAA 属性组上的值 与 SSS 关系在 BBB 属性组上的值 满足比较关系 θ\\thetaθ 的元组\n等值连接\nθ\\thetaθ 为 === 的连接运算称为等值连接\n非等值连接、等值连接、自然连接\n自然连接是一种特殊的等值连接。它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉。\n如图就是非等值连接，等值连接，自然连接的对比\n可以看到，\n\n\n非等值连接是符合 C&lt;EC&lt;EC&lt;E 的笛卡尔积元组，\n\n\nR⋈R.B=S.BSR\\substack{\\Join \\\\ R.B=S.B}SR⋈R.B=S.B​S 是符合 R.B=S.BR.B=S.BR.B=S.B 的等值连接，\n\n\n自然连接要求进行比较的属性 ( 分量 ) 必须是同名的属性组, 并且在结果中把重复的属性组列去掉\n也就是将同属性的两列合并成一列\n\n\n\n\n举一个 非等值连接 的计算过程 , 如图是笛卡尔积 , 黄色的是满足 C&lt;EC&lt;EC&lt;E 的\n\n外连接\n做自然连接的时候，会有一些不满足条件的元组被舍弃，叫 悬浮元组。\n\nR⋉⋊SR \\mathrel{\\mathrlap{\\ltimes}\\rtimes} SR⋉⋊S，外连接是保留（不舍弃）悬浮元组的连接\nR⋉SR \\ltimes SR⋉S，左外连接是保留左边关系的悬浮元组的连接\nR⋊SR \\rtimes SR⋊S，右外连接是保留右边关系的悬浮元组的连接\n\n在下图可以看到，\nRRR 中 a2a_2a2​ b4b_4b4​ 121212 没有对应的 EEE 值，所以填 NULLNULLNULL\n同样，SSS 中 b5b_5b5​ 也没有对应的 AAA 和 EEE 值，也填 NULLNULLNULL\n\n除运算\nT=R÷ST=R\\div ST=R÷S 表示 关系 TTT 是 关系 RRR 除以 关系 SSS 的结果（商）\nTTT 包含所有在 RRR 但不在 SSS 中的属性及其值， 且 TTT 的元组与 SSS 的元组的所有都在 RRR  中, 也就是 SSS 和 TTT 的组合都是 RRR 的子集。（所以这个有排除的意思, 更像减法）\n给定关系 R(X,Y)R(X,Y)R(X,Y) 和 S(Y,Z)S(Y,Z)S(Y,Z) , 其中 X,Y,ZX,Y,ZX,Y,Z 为属性组, R 中的 Y 和 S 中的 Y 可以有不同的属性名, 但必须出自相同的域集 ( 也就是有相同的类型 )\n\n我们看这个式子，给定关系 R(X,Y)R(X, Y)R(X,Y) 和 S(Y,Z)S(Y, Z)S(Y,Z)\n\n\nR÷SR\\div SR÷S 的结果是一个集合, 集合里的元素是 tr[X]t_r[X]tr​[X] 也就是 属性 XXX 的一个分量\n\n\ntr∈Rt_r\\in Rtr​∈R 表示元组属于关系 RRR , 表示 新关系 TTT 是 RRR 的子集 ( 集合里的元素是元组 )\n\n\nΠY(S)⊆Yx\\Pi _Y(S) \\subseteq Y_xΠY​(S)⊆Yx​ 表示 关系 SSS 中的 YYY 属性, 应该在 xxx 在 RRR 中的象集里\n象集 YxY_xYx​ 是为了逐一比较, 不同 xxx 下的 YYY 是否包含 SSS 中 YYY 的投影\n\n\n举例: 下图可以看到，只有 RRR 中的 a1a_1a1​ b1b_1b1​ c2c_2c2​，a1a_1a1​ b2b_2b2​ c3c_3c3​，a1a_1a1​ b2b_2b2​ c1c_1c1​\n\n\n首先看，包含在 RRR 但是不包含在 SSS 的属性显然是属性 AAA，所以我们求解的答案肯定是一个 AAA 分量 的列\n\n\n其次，求出 AAA 的所有值对应的象集，也就是 a1,a2,a3,a4a_1, a_2,a_3,a_4a1​,a2​,a3​,a4​ 的象集\n各象集\nBCa1={(b1,c1),(b3,c7),(b2,c1)}BC_{a_1}=\\{(b_1,c_1),(b_3,c_7),(b_2,c_1)\\}BCa1​​={(b1​,c1​),(b3​,c7​),(b2​,c1​)}\nBCa2={(b3,c7),(b2,c3)}BC_{a_2}=\\{(b_3,c_7),(b_2,c_3)\\}BCa2​​={(b3​,c7​),(b2​,c3​)}\nBCa3={(b4,c6)}BC_{a_3}=\\{(b_4,c_6)\\}BCa3​​={(b4​,c6​)}\nBCa4={(b6,c6)}BC_{a_4}=\\{(b_6,c_6)\\}BCa4​​={(b6​,c6​)}\n\n\n求出 SSS 中 BCBCBC 的投影\nΠBC(S)={(b1,c2),(b2,c1),(b2,c3)}\\Pi_{BC}(S)=\\{(b_1,c_2),(b_2,c_1),(b_2,c_3)\\}ΠBC​(S)={(b1​,c2​),(b2​,c1​),(b2​,c3​)}\n\n\n然后确定包含关系，发现只有 a1a_1a1​ 包含 SSS 中的 BCBCBC 所有组合\n\n\n答案就是 a1a_1a1​\n\n\n\n","tags":["数据库","关系代数","集合"]},{"title":"部署hexo到github.io的一些小问题（持续更新）","url":"/2023/04/18/%E9%83%A8%E7%BD%B2hexo%E5%88%B0github.io%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/","content":"1. 操作没问题，但就是部署失败\nhexo 在部署主题到 github.io 的时候，会有不小的延迟，如果确信你的操作没问题，但就是主题没有生效，那很有可能是github-Pages正在处理( github-pages 会显示一个 Queued ，意思就是在队列里面，还没处理)\n   \n2. 加载图片\n加载图片是一个稍微复杂一点的操作\n官方文档推荐了两种方法\n\n\n自己设置文件夹：应该将图片文件放进 source/img 里面（文件夹名字可以自定义），然后这样写 ![1.png](/img/图片路径)\n但是我在使用这种方法的时候，会出现本地编写的时候，无法识别图片导致实时预览效果很差\n所以我尝试将路径前面加了两个点 -&gt; ![1.png](../img/图片路径) 发现没有问题，预览和 hexo g 都没有出现差错。\n\n\n自动创建 asset_folder ：还有就是将 config.yml 里的 post_asset_folder 设置为 true ，他就会在你 new 一篇文章的时候，自动在 _post 文件夹下创建一个和文章同名的文件夹，来存放你所有的资源文件，然后你引用图片就可以 -&gt; ![1.png](文章名/图片名) 这样做的好处就是可以自动创建文件夹，并按不同文章分类，当然，你可以可以创建一个经常在各个文章调用资源的公共文件夹\n\n\n相对路径引用的标签插件：这个是一个新功能，但是在本地编写的时候没法预览还是不太方便，详细可以看官方文档，我把链接贴在这里 hexo官方文档\n\n\n最后也是我在用的，使用 Markdown 嵌入图片，这个也是会在你 new 一篇文章的时候，自动在 _post 文件夹下创建一个和文章同名的文件夹，来存放你所有的资源文件，但是你写地址的时候，会直接将 ![](image.jpg) 解析为 &lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt; ，但是如果你在本地编辑， ![](image.jpg) 则无法显示预览，填写 ![1.png](文章名/图片名) 则无法在 html 上正确显示链接，所以我们可以在 hexo 转化的过程中，做一下改动，直接改代码！！！\n\n\n先看你使用的是哪个渲染器，直接在你博客主目录执行\n npm list\n $ npm listhexo-site@0.0.0 /Users/darkFlameMaster/BlogSpace├── hexo-deployer-git@4.0.0├── hexo-filter-mathjax@0.9.0├── hexo-generator-archive@2.0.0├── hexo-generator-category@2.0.0├── hexo-generator-index@3.0.0├── hexo-generator-searchdb@1.4.1├── hexo-generator-tag@2.0.0├── hexo-renderer-ejs@2.0.0├── hexo-renderer-markdown-it@7.1.0├── hexo-renderer-stylus@3.0.0├── hexo-server@3.0.0├── hexo-theme-landscape@1.0.0├── hexo-theme-redefine@2.5.0├── hexo@6.3.0├── markdown-it-deflist@2.1.0├── markdown-it-imsize@2.0.1├── markdown-it-mark@3.0.1├── markdown-it-regexp@0.4.0├── markdown-it-sub@1.0.0├── markdown-it-sup@1.0.0└── markdown-it-task-checkbox@1.0.6\n看到第 11 行 就是渲染器\n\n\nhexo-renderer-markdown-it 渲染器\n如果你的渲染器是 hexo-renderer-marked\n搜索 post_asset_folder ，改成 true ，然后添加\nmarkdown:  # ...  images:    # ...    prepend_root: true    post_asset: true\n如果没有，那就在底下自己添加一下\n然后修改代码 node_modules/hexo-renderer-markdown-it/lib/images.js\n//###########################################// 如果路径中有 / 就转成 第一个斜杠后面的路径if (href.indexOf(&#x27;/&#x27;) &gt; -1) &#123;  href = href.split(&#x27;/&#x27;)[1];&#125;//###########################################\n\n\n\n\n\nhexo-renderer-marked 渲染器\n如果你的渲染器是 hexo-renderer-marked\n搜索 post_asset_folder ，改成 true ，然后添加\n marked:  prependRoot: true  postAsset: true\n\n\n然后打开这个文件 node_modules/hexo-renderer-marked/lib/renderer.js 并添加如下代码\n   //###########################################// 如果路径中有 / 就转成 第一个斜杠后面的路径if (href.indexOf(&#x27;/&#x27;) &gt; -1) &#123;  href = href.split(&#x27;/&#x27;)[1];&#125;//###########################################\n\n\n\n这样他就可以帮我们把链接转成正确显示的了，本地显示， github 显示都没有问题了\n\nps: 有的文章写的是将处理链接的代码放到了\nif (!/^(#|\\/\\/|http(s)?:)/.test(href) &amp;&amp; !relative_link &amp;&amp; prependRoot)（123行）\n这行代码之前，这完全是错误的，因为这样会导致你无法引入网络连接的图片\n\n这里有一个小小的缺陷，那就是 本地的图片 只能引入固定位置的资源了，也就是前面所说的自动创建的与文章同名的文件夹\n如果我们想要引用其他位置的资源文件，除了将文件拷贝过来，就只能将文件上传到指定的云端来引入了\n当前大部分情况下我们 本地文件夹+网络连接 已经可以覆盖90%的情况了，如果我们有一些公共的资源文件，可以将文件放在 source/img 没有就自己新建一个， hexo d 提交到 github 后，可以直接引用 博客地址/img/文件名 来引用了非常好用！！！\n就像这样：![updating.png](https://darkflamemasterdev.github.io/img/updating.png)\n3. 上传 github 报权限问题\n如果你感觉自己配置完全没问题，那你可以试着把代理关掉\nPlease make sure you have the correct access rightsand the repository exists.FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed    at ChildProcess.&lt;anonymous&gt; (/Users/DarkFlameMaster/BlogSpace/node_modules/hexo-util/lib/spawn.js:51:21)    at ChildProcess.emit (node:events:513:28)    at ChildProcess._handle.onexit (node:internal/child_process:291:12)\n同样我在这里也提到过类似的问题 git 的奇怪问题 kex_exchange_identification: Connection closed by remote host\n","tags":["hexo"]},{"title":"记录扔物线的三个协程视频","url":"/2023/11/30/%E8%AE%B0%E5%BD%95%E6%89%94%E7%89%A9%E7%BA%BF%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8D%8F%E7%A8%8B%E8%A7%86%E9%A2%91/","content":"第一个视频（学不会协程？很可能因为你看过的教程都是错的）\n学不会协程？很可能因为你看过的教程都是错的\n协程的概念\n开头就说了，我们没有必要关注协程是什么！因为协程并没有一个官方的或者统一的定义，包括维基百科（作者一直在说 kotlin 协程，而不是只说协程，应该也是在表示，视频里只是讲解 kotlin 协程，而不是所有协程）\n而对于 kotlin 协程，明确给出了，就是一套线程 API\n\n协程的好处\n基本的好处\n协程和其他的线程框架类似，比如 Handler、Executor、AsyncTask。都是是方便调度线程，但是由于 kotlin 的语言特性，协程会更方便。\n最有用的好处：非阻塞式挂起\n最重要的是，协程可以通过同步方式，写出异步代码\n同样，这里作者说了很多教程并没有正确理解和使用这种非阻塞式挂起，写出的教程都是错的\n协程长什么样？\n\n如图所示，我们可以用同步方式写异步代码\n这样就不用写回调了，大大减少了并发开发的难度，减少了回调地域\n这是对于我们的开发工作带来了质变，减小开发难度，就可以让开发者写出了更优质高效的代码\n协程怎么用？\n\n我们写在大括号里的那部分代码就是写成本身（看到这里，就基本猜到 kotlin 协程将 kotlin 的高阶函数 lambda 联系到一起）\n这个 launch 函数的意思是，我要创建一个协程，并在指定线程上运行协程\n切线程\n我们可以方便地通过协程来切线程\n\nwithContext 可以让我们把协程切回去再切回来，这样就可以方便地把异步代码写成同步代码了\nsuspend 关键字\nsuspend 函数需要在协程里调用，或者 suspend 函数里调用（其实也就是最终会在协程里调用，毕竟 suspend 函数也在协程调用）\n第二个视频（Kotlin 协程的挂起好神奇好难懂？今天我把它的皮给扒了）\nKotlin 协程的挂起好神奇好难懂？今天我把它的皮给扒了\nsuspend 挂起的是什么\n挂起的是协程，不是函数，也不是线程\n挂起就是：协程脱离当前线程，不是停下来了，而是跑到另一个线程了\n例子：主线程启动一个协程\n\n当你的协程挂起的时候，实际上就是 post 这个任务提前结束了，主线程就会继续刷新界面了\n那协程被挂起到哪里了？其实就是你调用的挂起函数指定的线程。\n并且如果你使用了 WithContext ，协程可以在执行结束后，将线程再切回来。\n这个切回来的实现，是 Dispatcher 来实现的，当然你也可以自定义一个 Dispatcher ，然后决定它的实现细节，切回来还是什么其他操作\n\n所谓挂起，其实就是一个可以被切回来的线程切换\n而切回来这个在协程里叫 resume\n\n  \n    suspend 函数之所以必须在协程里，就是有很多功能，就比如 “切回来”（resume）必须在协程里面才能实现\n\n  \nsuspend 并没有起到挂起的作用\nsuspend 只是一个关键字，并没有起到挂起作用，起到挂起作用的是 WithContext 之类的函数，或者某个 suspend 函数里的某一行代码\n也就是需要直接或者间接地调用那个 切换线程或者挂起协程 的代码，才能实现所谓的 挂起或者切线程\n\n  \n    \n      那suspend是干嘛用的？\n\n    \n    \n      suspend 是 给开发者的提醒，提醒开发者这个函数是一个耗时操作，有更多的可读性。\n对于调用者，只需要放到协程里，不需要关心其他的。\n并且，当你自己写一个 suspend 函数的时候，如果里面没调用 suspend 函数，那 IDE 就会提醒你，这个 suspend 关键字是没必要的，也能防止给其他调用者进行错误的“提醒”。\n\n    \n  \n怎么自定义 suspend\n什么时候定义成 suspend\n原则是，如果这个是耗时操作，就可以给他添加 suspend\n怎么写 suspend\n直接写一个 suspend 关键字，然后在实现里，调用 suspend 函数就行了\n第三个视频（到底什么是「非阻塞式」挂起？协程真的比线程更轻量级吗？）\n到底什么是「非阻塞式」挂起？协程真的比线程更轻量级吗？\n非阻塞式是协程独有的吗？\n其实，主线程里新启动一个子线程，然后将耗时操作放进子线程里，这也是耗时操作\n\n  \n    \n      非阻塞式到底要说啥？？？\n\n    \n    \n      包括 nio 的非阻塞式，其实都是一个道理，都是在说明当前线程（也有可能是进程、协程）是不会把耗时操作放在当前位置，然后让后续的操作一直等着，就是这个意思\n并没有任何其他暗示，只是说在这里位置不会执行耗时操作（其实所有的代码其实都是阻塞的，毕竟你再牛逼计算机的计算耗时以及各种 IO 耗时又不会凭空消失，所以非阻塞就是把耗时操作丢到别的地方）\n对于协程自然也就是，在当前 “协程” ，不会阻塞，因为非阻塞式挂起，就是将进行耗时操作的协程（协程就是代码块）切到子线程了\n\n    \n  \n\nkotlin官方的错误\nkotlin 官方用下图的左边两段代码对比，来证明协程更更高效，这是偷换概念\n\n只有使用绿色框框里的才是正确的对比方式，而且就没有性能差异了\n","tags":["kotlin","协程","Coroutine","扔物线"]},{"title":"阅读 OKHttp 源码","url":"/2025/04/26/%E9%98%85%E8%AF%BB-OKHttp-%E6%BA%90%E7%A0%81/","content":"\nOkHttp 是 Square 公司的开发框架\n早期，Android 提供的是两种 HttpApi 一个是 Android 的 HttpUrlConncection，另一个是 Apache 的 HttpClient\nOkHttp 觉的这俩都不好用不好用，就基于这两个 Api 进行了二次开发和封装，但最后还是不好用，所以最后就干脆彻底开发了一个自己的 Http 框架————OkHttp。\n后来 Google 在 Android4.4 开始，基于 OkHttp 的实现替换了原先 Android 中基于 Apache Harmony 的 HttpURLConnection 实现。正如安卓核心开发者 CommonsWare 所指出的：“从 Android 4.4 开始，Android 内部的 HttpURLConnection 实现使用了 OkHttp”\nOkHttp 4 以 Kotlin 重写了原有 Java 代码\n此次我们读的是 4.12.0 版本\n\n我们先看 OkHttp 的最基本用法\nval url = &quot;https://api.github.com/users/octocat/repos&quot;val client: OkHttpClient = OkHttpClient()val request: Request = Request.Builder()    .url(url)    .build()client.newCall(request).enqueue(object : Callback &#123;    override fun onFailure(call: Call, e: IOException) &#123;    &#125;    override fun onResponse(call: Call, response: Response) &#123;        println(response.code)    &#125;&#125;)\n我们从一个个看里面的代码\nOkHttp 框架结构解析\nOkHttpClient\n首先我们看 OkHttpClient\n@get:JvmName(&quot;dispatcher&quot;) val dispatcher: Dispatcher = builder.dispatcher@get:JvmName(&quot;connectionPool&quot;) val connectionPool: ConnectionPool = builder.connectionPool/** * Returns an immutable list of interceptors that observe the full span of each call: from before * the connection is established (if any) until after the response source is selected (either the * origin server, cache, or both). */@get:JvmName(&quot;interceptors&quot;) val interceptors: List&lt;Interceptor&gt; =    builder.interceptors.toImmutableList()/** * Returns an immutable list of interceptors that observe a single network request and response. * These interceptors must call [Interceptor.Chain.proceed] exactly once: it is an error for * a network interceptor to short-circuit or repeat a network request. */@get:JvmName(&quot;networkInterceptors&quot;) val networkInterceptors: List&lt;Interceptor&gt; =    builder.networkInterceptors.toImmutableList()@get:JvmName(&quot;eventListenerFactory&quot;) val eventListenerFactory: EventListener.Factory =    builder.eventListenerFactory@get:JvmName(&quot;retryOnConnectionFailure&quot;) val retryOnConnectionFailure: Boolean =    builder.retryOnConnectionFailure@get:JvmName(&quot;authenticator&quot;) val authenticator: Authenticator = builder.authenticator@get:JvmName(&quot;followRedirects&quot;) val followRedirects: Boolean = builder.followRedirects@get:JvmName(&quot;followSslRedirects&quot;) val followSslRedirects: Boolean = builder.followSslRedirects@get:JvmName(&quot;cookieJar&quot;) val cookieJar: CookieJar = builder.cookieJar@get:JvmName(&quot;cache&quot;) val cache: Cache? = builder.cache@get:JvmName(&quot;dns&quot;) val dns: Dns = builder.dns@get:JvmName(&quot;proxy&quot;) val proxy: Proxy? = builder.proxy@get:JvmName(&quot;proxySelector&quot;) val proxySelector: ProxySelector =    when &#123;      // Defer calls to ProxySelector.getDefault() because it can throw a SecurityException.      builder.proxy != null -&gt; NullProxySelector      else -&gt; builder.proxySelector ?: ProxySelector.getDefault() ?: NullProxySelector    &#125;@get:JvmName(&quot;proxyAuthenticator&quot;) val proxyAuthenticator: Authenticator =    builder.proxyAuthenticator@get:JvmName(&quot;socketFactory&quot;) val socketFactory: SocketFactory = builder.socketFactoryprivate val sslSocketFactoryOrNull: SSLSocketFactory?@get:JvmName(&quot;sslSocketFactory&quot;) val sslSocketFactory: SSLSocketFactory  get() = sslSocketFactoryOrNull ?: throw IllegalStateException(&quot;CLEARTEXT-only client&quot;)@get:JvmName(&quot;x509TrustManager&quot;) val x509TrustManager: X509TrustManager?@get:JvmName(&quot;connectionSpecs&quot;) val connectionSpecs: List&lt;ConnectionSpec&gt; =    builder.connectionSpecs@get:JvmName(&quot;protocols&quot;) val protocols: List&lt;Protocol&gt; = builder.protocols@get:JvmName(&quot;hostnameVerifier&quot;) val hostnameVerifier: HostnameVerifier = builder.hostnameVerifier@get:JvmName(&quot;certificatePinner&quot;) val certificatePinner: CertificatePinner@get:JvmName(&quot;certificateChainCleaner&quot;) val certificateChainCleaner: CertificateChainCleaner?/** * Default call timeout (in milliseconds). By default there is no timeout for complete calls, but * there is for the connect, write, and read actions within a call. */@get:JvmName(&quot;callTimeoutMillis&quot;) val callTimeoutMillis: Int = builder.callTimeout/** Default connect timeout (in milliseconds). The default is 10 seconds. */@get:JvmName(&quot;connectTimeoutMillis&quot;) val connectTimeoutMillis: Int = builder.connectTimeout/** Default read timeout (in milliseconds). The default is 10 seconds. */@get:JvmName(&quot;readTimeoutMillis&quot;) val readTimeoutMillis: Int = builder.readTimeout/** Default write timeout (in milliseconds). The default is 10 seconds. */@get:JvmName(&quot;writeTimeoutMillis&quot;) val writeTimeoutMillis: Int = builder.writeTimeout/** Web socket and HTTP/2 ping interval (in milliseconds). By default pings are not sent. */@get:JvmName(&quot;pingIntervalMillis&quot;) val pingIntervalMillis: Int = builder.pingInterval/** * Minimum outbound web socket message size (in bytes) that will be compressed. * The default is 1024 bytes. */@get:JvmName(&quot;minWebSocketMessageToCompress&quot;)val minWebSocketMessageToCompress: Long = builder.minWebSocketMessageToCompressval routeDatabase: RouteDatabase = builder.routeDatabase ?: RouteDatabase()...override fun newCall(request: Request): Call = RealCall(this, request, forWebSocket = false)...constructor() : this(Builder())constructor() : this(Builder())...    class Builder constructor() &#123;        internal var dispatcher: Dispatcher = Dispatcher()        internal var connectionPool: ConnectionPool = ConnectionPool()        internal val interceptors: MutableList&lt;Interceptor&gt; = mutableListOf()        internal val networkInterceptors: MutableList&lt;Interceptor&gt; = mutableListOf()        internal var eventListenerFactory: EventListener.Factory = EventListener.NONE.asFactory()        internal var retryOnConnectionFailure = true        internal var authenticator: Authenticator = Authenticator.NONE        internal var followRedirects = true        internal var followSslRedirects = true        internal var cookieJar: CookieJar = CookieJar.NO_COOKIES        internal var cache: Cache? = null        internal var dns: Dns = Dns.SYSTEM        internal var proxy: Proxy? = null        internal var proxySelector: ProxySelector? = null        internal var proxyAuthenticator: Authenticator = Authenticator.NONE        internal var socketFactory: SocketFactory = SocketFactory.getDefault()        internal var sslSocketFactoryOrNull: SSLSocketFactory? = null        internal var x509TrustManagerOrNull: X509TrustManager? = null        internal var connectionSpecs: List&lt;ConnectionSpec&gt; = DEFAULT_CONNECTION_SPECS        internal var protocols: List&lt;Protocol&gt; = DEFAULT_PROTOCOLS        internal var hostnameVerifier: HostnameVerifier = OkHostnameVerifier        internal var certificatePinner: CertificatePinner = CertificatePinner.DEFAULT        internal var certificateChainCleaner: CertificateChainCleaner? = null        internal var callTimeout = 0        internal var connectTimeout = 10_000        internal var readTimeout = 10_000        internal var writeTimeout = 10_000        internal var pingInterval = 0        internal var minWebSocketMessageToCompress = RealWebSocket.DEFAULT_MINIMUM_DEFLATE_SIZE        internal var routeDatabase: RouteDatabase? = null          internal constructor(okHttpClient: OkHttpClient) : this() &#123;            this.dispatcher = okHttpClient.dispatcher            this.connectionPool = okHttpClient.connectionPool            this.interceptors += okHttpClient.interceptors            this.networkInterceptors += okHttpClient.networkInterceptors            this.eventListenerFactory = okHttpClient.eventListenerFactory            this.retryOnConnectionFailure = okHttpClient.retryOnConnectionFailure            this.authenticator = okHttpClient.authenticator            this.followRedirects = okHttpClient.followRedirects            this.followSslRedirects = okHttpClient.followSslRedirects            this.cookieJar = okHttpClient.cookieJar            this.cache = okHttpClient.cache            this.dns = okHttpClient.dns            this.proxy = okHttpClient.proxy            this.proxySelector = okHttpClient.proxySelector            this.proxyAuthenticator = okHttpClient.proxyAuthenticator            this.socketFactory = okHttpClient.socketFactory            this.sslSocketFactoryOrNull = okHttpClient.sslSocketFactoryOrNull            this.x509TrustManagerOrNull = okHttpClient.x509TrustManager            this.connectionSpecs = okHttpClient.connectionSpecs            this.protocols = okHttpClient.protocols            this.hostnameVerifier = okHttpClient.hostnameVerifier            this.certificatePinner = okHttpClient.certificatePinner            this.certificateChainCleaner = okHttpClient.certificateChainCleaner            this.callTimeout = okHttpClient.callTimeoutMillis            this.connectTimeout = okHttpClient.connectTimeoutMillis            this.readTimeout = okHttpClient.readTimeoutMillis            this.writeTimeout = okHttpClient.writeTimeoutMillis            this.pingInterval = okHttpClient.pingIntervalMillis            this.minWebSocketMessageToCompress = okHttpClient.minWebSocketMessageToCompress            this.routeDatabase = okHttpClient.routeDatabase        &#125;&#125;\n很长，但是其实没啥难的，我们挑几个看看\nConnectionPool\n连接池，目的是连接复用，如果地址相同的话，可以省略握手流程，省略新创建连接的内存\n\n还支持 HTTP2.0 的多路复用\n\nnetworkInterceptors\n它是一个 List&lt;Interceptor&gt;\nEventListener.Factory\n构建 EventListener\nretryOnConnectionFailure\n连接失败是否重试\nAuthenticator\n处理身份验证的工具，可以用来刷新 token，或者重新登录，以下是示例代码：\nval client = OkHttpClient.Builder()    .authenticator(object : Authenticator &#123;        @Throws(IOException::class)        override fun authenticate(route: Route?, response: Response): Request? &#123;            if (response.request.header(&quot;Authorization&quot;) != null) &#123;                return null // Give up, we&#x27;ve already attempted to authenticate.            &#125;            val credential = Credentials.basic(&quot;name&quot;, &quot;password&quot;)            return response.request.newBuilder()                .header(&quot;Authorization&quot;, credential)                .build()        &#125;    &#125;)\n这段代码，判断了 Response 的 header 的 Authorization 为空的时候，返回一个 request ，这里使用了 response.request.newBuilder() 而不是重新生成一个，是因为这个重新生成的可以保留一些信息，我们看看代码\nfun newBuilder(): Builder = Builder(this)\n我们看看这 Builder 的构造函数\ninternal constructor(request: Request) &#123;  this.url = request.url  this.method = request.method  this.body = request.body  this.tags = if (request.tags.isEmpty()) &#123;    mutableMapOf()  &#125; else &#123;    request.tags.toMutableMap()  &#125;  this.headers = request.headers.newBuilder()&#125;open fun url(url: HttpUrl): Builder = apply &#123;  this.url = url&#125;\nfollowRedirects\n是否支持重定向\nfollowSsLRedirects\nhttp 与 https 的重定向\ncookieJar\n存放 Cookie 的“罐子” （cookie jar 就是饼干罐的意思，是一种英语的双关）\n这个 CookieJar 默认是 NoCookie\nCache\n是使用一个 DiskLruCache 实现的\nDns\n通过 hostname ，返回一个 List&lt;InetAddress&gt;\nProxy\n代理，分为三种\npublic enum Type &#123;    /**     * Represents a direct connection, or the absence of a proxy.     */    DIRECT,    /**     * Represents proxy for high level protocols such as HTTP or FTP.     */    HTTP,    /**     * Represents a SOCKS (V4 or V5) proxy.     */    SOCKS&#125;;\nProxySelector\n代理服务器选择器\nproxyAuthenticator\n代理服务器授权\nSocketFactory\nSocket 建立的工厂\nSslSocketFactory\n加密的 Socket 建立工厂\nx509TrustManager\n证书验证工具，x509 是一种证书格式\nconnectionSpecs\n是一个 List&lt;ConnectionSpec&gt; ， ConnectionSpec 是连接协议的意思，点进去就能看到里面有一些加密套件的变量，包括 TlsVersion ，cipherSuites\nConnectionSpec 里面有几个提供的加密协议选项：\n\nRESTRICTED_TLS：最严格的 TLS 支持，偏向于安全\nMODERN_TLS：最大泛用的 TLS 支持，是 Okhttp 默认值\nCOMPATIBLE_TLS：最宽松的 TLS 支持，偏向于兼容性\nCLEARTEXT：明文，也就是 HTTP 不加密\n\nprotocols\n协议：分为 HTTP_1_0，HTTP_1_1，SPDY_3（HTTP_2前身），HTTP_2 ，H2_PRIOR_KNOWLEDGE（不加密的 HTTP_2），QUIC\nhostnameVerifier\n主机名验证\ncertificatePinner\n约束哪些证书被信任。相当于给证书增加需要验证的步骤，比如 hash\nval url = &quot;https://api.github.com/users/octocat/repos&quot;val hostname = &quot;api.github.com&quot;val certificatePinner = CertificatePinner.Builder()    .add(hostname, &quot;sha256/qwerty&quot;)    .build()val client = OkHttpClient.Builder()    .certificatePinner(certificatePinner)    .build()\n输出结果：\njavax.net.ssl.SSLPeerUnverifiedException: Certificate pinning failure!  Peer certificate chain:    sha256/1EkvzibgiE3k+xdsv+7UU5vhV8kdFCQiUiFdMX5Guuk=: CN=*.github.com    sha256/6YBE8kK4d5J1qu1wEjyoKqzEIvyRY5HyM/NB2wKdcZo=: CN=Sectigo ECC Domain Validation Secure Server CA, O=Sectigo Limited, L=Salford, ST=Greater Manchester, C=GB    sha256/ICGRfpgmOUXIWcQ/HXPLQTkFPEFPoDyjvH7ohhQpjzs=: CN=USERTrust ECC Certification Authority, O=The USERTRUST Network, L=Jersey City, ST=New Jersey, C=US  Pinned certificates for api.github.com:    sha256/qwertw==\n这样第一次错了，后续就知道了证书的 sha256，就可以进行验证了\n\n但这也有风险，由于 hash 是写在本地的，所以如果更换证书没有及时更新软件，就会导致验证失败\n\ncertificateChainCleaner\n清洁证书链条返回一个证书列表\nCall\noverride fun newCall(request: Request): Call = RealCall(this, request, forWebSocket = false)\n这个 Call 有三个参数\n\n\n第一个 OkHttpClient 刚才我们已经看过了，它包含了很多配置信息，相当于一个大总管。\n\n\n第二个 request 刚才我们也看了，他就是一个 Http 请求的代码化文件\n这里写了 originalRequest 这是一个初始的 Request\n\n\n第三个是 forWebSocket 这个是一个是否支持 WebSocket 的开关\n\n\n传统 HTTP 是请求-响应模式：客户端发请求，服务器返回数据，然后连接断开。\n\n\nWebSocket 则是在最开始通过 HTTP 协议进行一次握手（“升级协议”），握手成功后，客户端和服务器之间的连接会保持打开，双方可以随时主动发送数据。\n\n\n\n\n所以，newCall 本质是创建了一个 RealCall ，我们看看这个 RealCall，同时也看看这个 RealCall 的 enqueue\nCall.enqueue()\n// RealCall.ktoverride fun enqueue(responseCallback: Callback) &#123;  check(executed.compareAndSet(false, true)) &#123; &quot;Already Executed&quot; &#125;  callStart()  client.dispatcher.enqueue(AsyncCall(responseCallback))&#125;\n\n\n第一行是检查是不是已经在运行了\n\n\n第二行 callStart 我们看看\n// RealCall.ktprivate fun callStart() &#123;  this.callStackTrace = Platform.get().getStackTraceForCloseable(&quot;response.body().close()&quot;)  eventListener.callStart(this)&#125;\n\n\n这里生成了一个 callStackTrace 这个是用来跟踪堆栈，跟踪错误信息的\n\n\n然后是一个 eventListener 事件监听器，用于监听各种事件，比如 TCP 的建立和关闭，Header 开始发送接收…\n\n\n\n\n第三行是 enqueue 这个函数的核心逻辑，里面调用了一个 client.dispatcher.enqueue 参数填写的是 AsyncCall\n\n\n我们先看看 dispatcher ，这个 Dispatcher 这个类是做线程调度的，里面用的是 Java 的 Executor ，代码不用深究\n// Dispatcher.ktinternal fun enqueue(call: AsyncCall) &#123;  synchronized(this) &#123;    readyAsyncCalls.add(call)    // Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to    // the same host.    if (!call.call.forWebSocket) &#123;      val existingCall = findExistingCallWithHost(call.host)      if (existingCall != null) call.reuseCallsPerHostFrom(existingCall)    &#125;  &#125;  promoteAndExecute()&#125;\n这个函数就是将 AsyncCall 添加进 readyAsyncCalls 里面，然后调用 promoteAndExecute\nreadyAsyncCall 是一个双向队列，里面放的是那些准备要执行的 Call，我们看看 promoteAndExecute\n// Dispatcher.ktprivate fun promoteAndExecute(): Boolean &#123;  this.assertThreadDoesntHoldLock()  val executableCalls = mutableListOf&lt;AsyncCall&gt;()  val isRunning: Boolean  synchronized(this) &#123;    val i = readyAsyncCalls.iterator()    while (i.hasNext()) &#123;      val asyncCall = i.next()      if (runningAsyncCalls.size &gt;= this.maxRequests) break // Max capacity.      if (asyncCall.callsPerHost.get() &gt;= this.maxRequestsPerHost) continue // Host max capacity.      i.remove()      asyncCall.callsPerHost.incrementAndGet()      executableCalls.add(asyncCall)      runningAsyncCalls.add(asyncCall)    &#125;    isRunning = runningCallsCount() &gt; 0  &#125;  for (i in 0 until executableCalls.size) &#123;    val asyncCall = executableCalls[i]    asyncCall.executeOn(executorService)  &#125;  return isRunning&#125;\n\npromote 有提升的意思，在这里是将等待执行的 Call 从 readyAsyncCalls 中拿出来，放进 executableCalls 和 runningAsyncCalls 里面\n\n我们看下后面的 25 行，asyncCall.executeOn(executorService) 是用来将 Call 执行的，我们来看看他到底怎么执行的\nfun executeOn(executorService: ExecutorService) &#123;    client.dispatcher.assertThreadDoesntHoldLock()    var success = false    try &#123;        executorService.execute(this)        success = true    &#125; catch (e: RejectedExecutionException) &#123;        val ioException = InterruptedIOException(&quot;executor rejected&quot;)        ioException.initCause(e)        noMoreExchanges(ioException)        responseCallback.onFailure(this@RealCall, ioException)    &#125; finally &#123;        if (!success) &#123;            client.dispatcher.finished(this) // This call is no longer running!        &#125;    &#125;&#125;\n这里面的核心代码是 executorService.execute(this) ，这个 execute 方法参数是 Runnable 我们看看 run 里面怎么实现的\noverride fun run() &#123;  threadName(&quot;OkHttp $&#123;redactedUrl()&#125;&quot;) &#123;    var signalledCallback = false    timeout.enter()    try &#123;      val response = getResponseWithInterceptorChain()      signalledCallback = true      responseCallback.onResponse(this@RealCall, response)    &#125; catch (e: IOException) &#123;      if (signalledCallback) &#123;        // Do not signal the callback twice!        Platform.get().log(&quot;Callback failure for $&#123;toLoggableString()&#125;&quot;, Platform.INFO, e)      &#125; else &#123;        responseCallback.onFailure(this@RealCall, e)      &#125;    &#125; catch (t: Throwable) &#123;      cancel()      if (!signalledCallback) &#123;        val canceledException = IOException(&quot;canceled due to $t&quot;)        canceledException.addSuppressed(t)        responseCallback.onFailure(this@RealCall, canceledException)      &#125;      throw t    &#125; finally &#123;      client.dispatcher.finished(this)    &#125;  &#125;&#125;\n这里代码里的核心代码是 val response = getResponseWithInterceptorChain()\n这里获得 response ，然后后面回调 responseCallback.onResponse\n\n从这里我们知道了 OkHttp 的回调是在子线程里也就是 ExecutorService 的线程里，所以在 Android 开发中需要进行切回主线程，而且当遇到返回 token 需要再一次进行访问的时候，可以直接在回调里使用 Call.execute()\n\n\n\n\n\n自此，我们就知道了这个 enqueue 的流程\n我们再看看 Call.execute()\nCall.execute()\noverride fun execute(): Response &#123;  check(executed.compareAndSet(false, true)) &#123; &quot;Already Executed&quot; &#125;  timeout.enter()  callStart()  try &#123;    client.dispatcher.executed(this)    return getResponseWithInterceptorChain()  &#125; finally &#123;    client.dispatcher.finished(this)  &#125;&#125;\n这个是个 Call.enqueue 和相似的，核心代码就是 try 的两行：\nclient.dispatcher.executed(this)return getResponseWithInterceptorChain()\n然后我们接下来直接来看这个 getResponseWithInterceptorChain 到底是干嘛的\n网络请求流程\ngetResponseWithInterceptorChain()\n// RealCall.kt@Throws(IOException::class)internal fun getResponseWithInterceptorChain(): Response &#123;  // Build a full stack of interceptors.  val interceptors = mutableListOf&lt;Interceptor&gt;()  interceptors += client.interceptors  interceptors += RetryAndFollowUpInterceptor(client)  interceptors += BridgeInterceptor(client.cookieJar)  interceptors += CacheInterceptor(client.cache)  interceptors += ConnectInterceptor  if (!forWebSocket) &#123;    interceptors += client.networkInterceptors  &#125;  interceptors += CallServerInterceptor(forWebSocket)  val chain = RealInterceptorChain(      call = this,      interceptors = interceptors,      index = 0,      exchange = null,      request = originalRequest,      connectTimeoutMillis = client.connectTimeoutMillis,      readTimeoutMillis = client.readTimeoutMillis,      writeTimeoutMillis = client.writeTimeoutMillis  )  var calledNoMoreExchanges = false  try &#123;    val response = chain.proceed(originalRequest)    if (isCanceled()) &#123;      response.closeQuietly()      throw IOException(&quot;Canceled&quot;)    &#125;    return response  &#125; catch (e: IOException) &#123;    calledNoMoreExchanges = true    throw noMoreExchanges(e) as Throwable  &#125; finally &#123;    if (!calledNoMoreExchanges) &#123;      noMoreExchanges(null)    &#125;  &#125;&#125;\n我们看到他先是声明了一个名为 interceptors 的 mutableListOf&lt;Interceptor&gt;()\n然后依次添加各种 interceptor 到这个 List 里面\n\n然后继续往下看，它生成了一个名为 chain 的 RealInterceptorChain\n然后后面调用了 chain.proceed(originalRequest)，我们继续往里追\n// RealInterceptorChain.kt@Throws(IOException::class)override fun proceed(request: Request): Response &#123;  check(index &lt; interceptors.size)  calls++  if (exchange != null) &#123;    check(exchange.finder.sameHostAndPort(request.url)) &#123;      &quot;network interceptor $&#123;interceptors[index - 1]&#125; must retain the same host and port&quot;    &#125;    check(calls == 1) &#123;      &quot;network interceptor $&#123;interceptors[index - 1]&#125; must call proceed() exactly once&quot;    &#125;  &#125;  // Call the next interceptor in the chain.  val next = copy(index = index + 1, request = request)  val interceptor = interceptors[index]  @Suppress(&quot;USELESS_ELVIS&quot;)  val response = interceptor.intercept(next) ?: throw NullPointerException(      &quot;interceptor $interceptor returned null&quot;)  if (exchange != null) &#123;    check(index + 1 &gt;= interceptors.size || next.calls == 1) &#123;      &quot;network interceptor $interceptor must call proceed() exactly once&quot;    &#125;  &#125;  check(response.body != null) &#123; &quot;interceptor $interceptor returned a response with no body&quot; &#125;  return response&#125;\n我们看第 18 行，它从 interceptors 中选了一个去执行 interceptor.intercept(next) ，并且我们看第 17 行他每次调用都会将 index + 1 传入，而 next 本身值并没有变（index 从 RealInterceptorChain 的构造函数中传进来），我们简单看一下这个 copy 函数\nRealInterceptorChain.copy()\n// RealInterceptorChain.ktinternal fun copy(  index: Int = this.index,  exchange: Exchange? = this.exchange,  request: Request = this.request,  connectTimeoutMillis: Int = this.connectTimeoutMillis,  readTimeoutMillis: Int = this.readTimeoutMillis,  writeTimeoutMillis: Int = this.writeTimeoutMillis) = RealInterceptorChain(call, interceptors, index, exchange, request, connectTimeoutMillis,    readTimeoutMillis, writeTimeoutMillis)\n可以看到，这个 copy 函数的 index 默认值是当前 RealInterceptorChain 的 index ，所以传入 index + 1 就是在这个链上往后移动一下\n为了搞清楚这个 interceptor.intercept(Chain) 具体干了什么，我们得去看看它的实现类 Interceptor\n既然如此我们一个个看刚才的 Interceptor：\nclient.interceptors\n这个 client 是 OkHttpClient，我们返回看到 OkHttpClient 里看：\n@get:JvmName(&quot;interceptors&quot;) val interceptors: List&lt;Interceptor&gt; =    builder.interceptors.toImmutableList()\n这个 interceptors 是一个 List&lt;Interceptor&gt; ，并且在 builder 中初始化，我们看看 Builder\nfun addInterceptor(interceptor: Interceptor) = apply &#123;  interceptors += interceptor&#125;\n这个 Builder 的 addInterceptor 就是来添加拦截器的，也就是用户自定义的拦截器，里面的实现要用户自己实现\nRetryAndFollowUpInterceptor\n这个拦截器的工作就是将出现失败的网络连接或者需要重定向的网络连接进行重试请求\n// RetryAndFollowUpInterceptor.kt@Throws(IOException::class)override fun intercept(chain: Interceptor.Chain): Response &#123;  val realChain = chain as RealInterceptorChain  var request = chain.request  val call = realChain.call  var followUpCount = 0  var priorResponse: Response? = null  var newExchangeFinder = true  var recoveredFailures = listOf&lt;IOException&gt;()  while (true) &#123;    call.enterNetworkInterceptorExchange(request, newExchangeFinder)    var response: Response    var closeActiveExchange = true    try &#123;      if (call.isCanceled()) &#123;        throw IOException(&quot;Canceled&quot;)      &#125;      try &#123;        response = realChain.proceed(request)        newExchangeFinder = true      &#125; catch (e: RouteException) &#123;        // The attempt to connect via a route failed. The request will not have been sent.        if (!recover(e.lastConnectException, call, request, requestSendStarted = false)) &#123;          throw e.firstConnectException.withSuppressed(recoveredFailures)        &#125; else &#123;          recoveredFailures += e.firstConnectException        &#125;        newExchangeFinder = false        continue      &#125; catch (e: IOException) &#123;        // An attempt to communicate with a server failed. The request may have been sent.        if (!recover(e, call, request, requestSendStarted = e !is ConnectionShutdownException)) &#123;          throw e.withSuppressed(recoveredFailures)        &#125; else &#123;          recoveredFailures += e        &#125;        newExchangeFinder = false        continue      &#125;      // Attach the prior response if it exists. Such responses never have a body.      if (priorResponse != null) &#123;        response = response.newBuilder()            .priorResponse(priorResponse.newBuilder()                .body(null)                .build())            .build()      &#125;      val exchange = call.interceptorScopedExchange      val followUp = followUpRequest(response, exchange)      if (followUp == null) &#123;        if (exchange != null &amp;&amp; exchange.isDuplex) &#123;          call.timeoutEarlyExit()        &#125;        closeActiveExchange = false        return response      &#125;      val followUpBody = followUp.body      if (followUpBody != null &amp;&amp; followUpBody.isOneShot()) &#123;        closeActiveExchange = false        return response      &#125;      response.body?.closeQuietly()      if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;        throw ProtocolException(&quot;Too many follow-up requests: $followUpCount&quot;)      &#125;      request = followUp      priorResponse = response    &#125; finally &#123;      call.exitNetworkInterceptorExchange(closeActiveExchange)    &#125;  &#125;&#125;\n可以看到这个 RetryAndFollowUpInterceptor.intercept，里面是一个 while(true) 循环，并且你找不到 break，但是他有 continue 、 return 和 throw 这意味着这个死循环并不会被主动取消，而是会不断重试，直到出现错误或者获得结果\n继续往后执行的代码在于第 23 行的 response = realChain.proceed(request)\n同样的调用就已经在 RealCall 里调用过了，我们来具体分析下这里的代码逻辑\n\n\ngetResponseWithInterceptorChain 里生成一个 RealInterceptorChain ，调用 chain.proceed\nchain 默认内容如下：\n\n\n\n然后在 chain.proceed 里调用如下代码：\nval next = copy(index = index + 1, request = request)val interceptor = interceptors[index]@Suppress(&quot;USELESS_ELVIS&quot;)val response = interceptor.intercept(next) ?: throw NullPointerException(&quot;interceptor $interceptor returned null&quot;)\n\n这段代码挺让人疑惑的，尤其是这个 index\ncopy 只是生成一个 index+1 的 chain\n而这个 interceptors[index] 使用的还是当前 chain 的 index\n\n在默认情况下，第一次调用的时候，就是使用 copy 生成一个 index 为 1 的 chain ，然后用第 0 个 interceptor 也就是 RetryAndFollowUpInterceptor 调用 intercept(next)\n\n\n调用了 interceptor.intercept(next) 就会调用 RetryAndFollowUpInterceptor.intercept(next)\n这个函数里有一个 while 循环，因为这是 RetryAndFollowUpInterceptor ，需要实现的功能就是一遍遍的重试\n然后调用 response = realChain.proceed(request) 继续推进\n\n\n重复第 2 步，继续调用下一个 Interceptor\n\n\n这也就是这拦截链请求的代码逻辑\n回到 RetryAndFollowUpInterceptor ，它往后推进逻辑就是 proceed(requset) ，所以就会在 request 里进行更改，以便下次请求\n我们大体框架了解了之后，现在继续回归 RetryAndFollowUpInterceptor 在执行推进逻辑的时候，会有一些前置工作和一些后置工作\ncall.enterNetworkInterceptorExchange(request, newExchangeFinder)\n这个函数我们看看里面做了什么\nfun enterNetworkInterceptorExchange(request: Request, newExchangeFinder: Boolean) &#123;  check(interceptorScopedExchange == null)  synchronized(this) &#123;    check(!responseBodyOpen) &#123;      &quot;cannot make a new request because the previous response is still open: &quot; +          &quot;please call response.close()&quot;    &#125;    check(!requestBodyOpen)  &#125;  if (newExchangeFinder) &#123;    this.exchangeFinder = ExchangeFinder(        connectionPool,        createAddress(request.url),        this,        eventListener    )  &#125;&#125;\n这里的最关键的代码就是\nthis.exchangeFinder = ExchangeFinder(        connectionPool,        createAddress(request.url),        this,        eventListener    )\n\n在 HTTP 协议中，“exchange”（交换）指的是 一次完整的请求-响应交互过程，也就是：客户端发送一个请求，服务器返回一个响应，这整个过程称为一次 HTTP exchange。\n\n可以看到参数里有一个 connectionPool ，而这 ExchangeFinder 就是在这里连接池里寻找一个连接\n后置工作就是在失败或者重复的时候，就调用 continue 进行再次请求\n\n\n\n也就是说这个拦截器，会有一些前置工作\n\n\n做完前置工作之后，会使用 chain.proceed(request) 推进到下一个 Interceptor.intercept() 里面\n\n\n等到返回 response 之后，或者被 try-catch 捕捉之后，再执行一些后置工作\n\n\n\n然后我们此时就应该继续看 chain.proceed 也就是继续看下一个 Interceptor 的 intercept 了\nBridgeInterceptor\n// BridgeInterceptor.kt@Throws(IOException::class)override fun intercept(chain: Interceptor.Chain): Response &#123;  val userRequest = chain.request()  val requestBuilder = userRequest.newBuilder()  val body = userRequest.body  if (body != null) &#123;    val contentType = body.contentType()    if (contentType != null) &#123;      requestBuilder.header(&quot;Content-Type&quot;, contentType.toString())    &#125;    val contentLength = body.contentLength()    if (contentLength != -1L) &#123;      requestBuilder.header(&quot;Content-Length&quot;, contentLength.toString())      requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;)    &#125; else &#123;      requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;)      requestBuilder.removeHeader(&quot;Content-Length&quot;)    &#125;  &#125;  if (userRequest.header(&quot;Host&quot;) == null) &#123;    requestBuilder.header(&quot;Host&quot;, userRequest.url.toHostHeader())  &#125;  if (userRequest.header(&quot;Connection&quot;) == null) &#123;    requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;)  &#125;  // If we add an &quot;Accept-Encoding: gzip&quot; header field we&#x27;re responsible for also decompressing  // the transfer stream.  var transparentGzip = false  if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123;    transparentGzip = true    requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)  &#125;  val cookies = cookieJar.loadForRequest(userRequest.url)  if (cookies.isNotEmpty()) &#123;    requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies))  &#125;  if (userRequest.header(&quot;User-Agent&quot;) == null) &#123;    requestBuilder.header(&quot;User-Agent&quot;, userAgent)  &#125;  val networkResponse = chain.proceed(requestBuilder.build())  cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)  val responseBuilder = networkResponse.newBuilder()      .request(userRequest)  if (transparentGzip &amp;&amp;      &quot;gzip&quot;.equals(networkResponse.header(&quot;Content-Encoding&quot;), ignoreCase = true) &amp;&amp;      networkResponse.promisesBody()) &#123;    val responseBody = networkResponse.body    if (responseBody != null) &#123;      val gzipSource = GzipSource(responseBody.source())      val strippedHeaders = networkResponse.headers.newBuilder()          .removeAll(&quot;Content-Encoding&quot;)          .removeAll(&quot;Content-Length&quot;)          .build()      responseBuilder.headers(strippedHeaders)      val contentType = networkResponse.header(&quot;Content-Type&quot;)      responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer()))    &#125;  &#125;  return responseBuilder.build()&#125;\n这个拦截器的目的是在应用层和网络层之间架起桥梁，完成 HTTP 请求和响应过程中的一些标准化处理，比如：\n\n添加请求头\n\n\nUser-Agent：如果用户没有手动添加，会自动添加一个默认的。\nHost、Connection：如果没有，会自动补充。\nAccept-Encoding：默认添加 &quot;gzip&quot;，以支持响应内容的压缩。\nCookie：如果使用了 CookieJar，会自动添加相应的 Cookie。\nContent-Type、Content-Length / Transfer-Encoding：根据请求体的存在情况自动补充。\n\n\n处理请求体压缩\n\n\n如果 Accept-Encoding: gzip 被添加，BridgeInterceptor 会自动处理对响应体的解压。\n\n\n接收响应并处理压缩内容\n\n\n如果响应头中有 Content-Encoding: gzip，它会自动将响应体解压缩（GZIP 解码）。\n\n\n接收 Set-Cookie\n\n\n会将服务器返回的 Set-Cookie 交给 CookieJar 进行持久化或保存。\n\n所以我们发现和 RetryAndFollowUpInterceptor 一样，都有一些前置工作、中置工作和后置工作，但中置工作都是 chain.proceed 推进到下个拦截器，前置工作是衔接上个拦截器，而后置工作是处理下个拦截器返回的 response\nCacheInterceptor\noverride fun intercept(chain: Interceptor.Chain): Response &#123;  val call = chain.call()  val cacheCandidate = cache?.get(chain.request())  val now = System.currentTimeMillis()  val strategy = CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()  val networkRequest = strategy.networkRequest  val cacheResponse = strategy.cacheResponse  cache?.trackResponse(strategy)  val listener = (call as? RealCall)?.eventListener ?: EventListener.NONE  if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;    // The cache candidate wasn&#x27;t applicable. Close it.    cacheCandidate.body?.closeQuietly()  &#125;  // If we&#x27;re forbidden from using the network and the cache is insufficient, fail.  if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;    return Response.Builder()        .request(chain.request())        .protocol(Protocol.HTTP_1_1)        .code(HTTP_GATEWAY_TIMEOUT)        .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)        .body(EMPTY_RESPONSE)        .sentRequestAtMillis(-1L)        .receivedResponseAtMillis(System.currentTimeMillis())        .build().also &#123;          listener.satisfactionFailure(call, it)        &#125;  &#125;  // If we don&#x27;t need the network, we&#x27;re done.  if (networkRequest == null) &#123;    return cacheResponse!!.newBuilder()        .cacheResponse(stripBody(cacheResponse))        .build().also &#123;          listener.cacheHit(call, it)        &#125;  &#125;  if (cacheResponse != null) &#123;    listener.cacheConditionalHit(call, cacheResponse)  &#125; else if (cache != null) &#123;    listener.cacheMiss(call)  &#125;  var networkResponse: Response? = null  try &#123;    networkResponse = chain.proceed(networkRequest)  &#125; finally &#123;    // If we&#x27;re crashing on I/O or otherwise, don&#x27;t leak the cache body.    if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123;      cacheCandidate.body?.closeQuietly()    &#125;  &#125;  // If we have a cache response too, then we&#x27;re doing a conditional get.  if (cacheResponse != null) &#123;    if (networkResponse?.code == HTTP_NOT_MODIFIED) &#123;      val response = cacheResponse.newBuilder()          .headers(combine(cacheResponse.headers, networkResponse.headers))          .sentRequestAtMillis(networkResponse.sentRequestAtMillis)          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)          .cacheResponse(stripBody(cacheResponse))          .networkResponse(stripBody(networkResponse))          .build()      networkResponse.body!!.close()      // Update the cache after combining headers but before stripping the      // Content-Encoding header (as performed by initContentStream()).      cache!!.trackConditionalCacheHit()      cache.update(cacheResponse, response)      return response.also &#123;        listener.cacheHit(call, it)      &#125;    &#125; else &#123;      cacheResponse.body?.closeQuietly()    &#125;  &#125;  val response = networkResponse!!.newBuilder()      .cacheResponse(stripBody(cacheResponse))      .networkResponse(stripBody(networkResponse))      .build()  if (cache != null) &#123;    if (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;      // Offer this request to the cache.      val cacheRequest = cache.put(response)      return cacheWritingResponse(cacheRequest, response).also &#123;        if (cacheResponse != null) &#123;          // This will log a conditional cache miss only.          listener.cacheMiss(call)        &#125;      &#125;    &#125;    if (HttpMethod.invalidatesCache(networkRequest.method)) &#123;      try &#123;        cache.remove(networkRequest)      &#125; catch (_: IOException) &#123;        // The cache cannot be written.      &#125;    &#125;  &#125;  return response&#125;\n依据前两个拦截器的信息，我们可以猜到这个拦截器也是分为前置工作、中置工作、后置工作\n而 CatchInterceptor 也确实，前置工作就是找找缓存里有没有数据，没有的话直接返回，没有的话，再去做请求\nConnectInterceptor\n// ConnectInterceptor.ktoverride fun intercept(chain: Interceptor.Chain): Response &#123;  val realChain = chain as RealInterceptorChain  val exchange = realChain.call.initExchange(chain)  val connectedChain = realChain.copy(exchange = exchange)  return connectedChain.proceed(realChain.request)&#125;\n这是最重要的一个拦截器，这个拦截器我们发现它没有前面的后置工作，到 connectedChain.proceed(realChain.request) 就结束了\n这个拦截器的工作就是建立连接，前置工作的关键在于 realChain.call.initExchange(chain) 我们点开看看：\nrealChain.call.initExchange(chain)\n// RealCall.ktinternal fun initExchange(chain: RealInterceptorChain): Exchange &#123;  synchronized(this) &#123;    check(expectMoreExchanges) &#123; &quot;released&quot; &#125;    check(!responseBodyOpen)    check(!requestBodyOpen)  &#125;  val exchangeFinder = this.exchangeFinder!!  val codec = exchangeFinder.find(client, chain)  val result = Exchange(this, eventListener, exchangeFinder, codec)  this.interceptorScopedExchange = result  this.exchange = result  synchronized(this) &#123;    this.requestBodyOpen = true    this.responseBodyOpen = true  &#125;  if (canceled) throw IOException(&quot;Canceled&quot;)  return result&#125;\n先是通过 HTTP 的格式找到一个 codec (编解码器) ，然后用这个 codec 拼成一个 exchange\n这个 codec 就是 Encodes HTTP requests and decodes HTTP responses.\n我们看看它是如何生成的，我们点进 exchangeFinder.find(client, chain)\n// ExchangeFinder.ktfun find(client: OkHttpClient,chain: RealInterceptorChain): ExchangeCodec &#123;  try &#123;    val resultConnection = findHealthyConnection(        connectTimeout = chain.connectTimeoutMillis,        readTimeout = chain.readTimeoutMillis,        writeTimeout = chain.writeTimeoutMillis,        pingIntervalMillis = client.pingIntervalMillis,        connectionRetryEnabled = client.retryOnConnectionFailure,        doExtensiveHealthChecks = chain.request.method != &quot;GET&quot;    )    return resultConnection.newCodec(client, chain)  &#125; catch (e: RouteException) &#123;    trackFailure(e.lastConnectException)    throw e  &#125; catch (e: IOException) &#123;    trackFailure(e)    throw RouteException(e)  &#125;&#125;\n这里有一个 findHealthyConnection 找到一个健康的连接，然后再通过 resultConnection.newCodec 生成一个 codec\n我们再追这个 findHealthyConnection\nfindHealthyConnection\n// ExchangeFinder.kt@Throws(IOException::class)private fun findHealthyConnection(  connectTimeout: Int,  readTimeout: Int,  writeTimeout: Int,  pingIntervalMillis: Int,  connectionRetryEnabled: Boolean,  doExtensiveHealthChecks: Boolean): RealConnection &#123;  while (true) &#123;    val candidate = findConnection(        connectTimeout = connectTimeout,        readTimeout = readTimeout,        writeTimeout = writeTimeout,        pingIntervalMillis = pingIntervalMillis,        connectionRetryEnabled = connectionRetryEnabled    )    // Confirm that the connection is good.    if (candidate.isHealthy(doExtensiveHealthChecks)) &#123;      return candidate    &#125;    // If it isn&#x27;t, take it out of the pool.    candidate.noNewExchanges()    // Make sure we have some routes left to try. One example where we may exhaust all the routes    // would happen if we made a new connection and it immediately is detected as unhealthy.    if (nextRouteToTry != null) continue    val routesLeft = routeSelection?.hasNext() ?: true    if (routesLeft) continue    val routesSelectionLeft = routeSelector?.hasNext() ?: true    if (routesSelectionLeft) continue    throw IOException(&quot;exhausted all routes&quot;)  &#125;&#125;\n这里面就分三步\n\n先 findConnection 找到一个连接\n再 candidate.isHealthy 判断这个连接是否健康，健康就返回，不健康就将他移出连接池\n如果还有其他可尝试从途径，就 continue 再次进入循环再找个连接\n\n我们看看如何拿到这个连接，我们点进 findConnection\nfindConnection\n// ExchangeFinder.kt@Throws(IOException::class)private fun findConnection(  connectTimeout: Int,  readTimeout: Int,  writeTimeout: Int,  pingIntervalMillis: Int,  connectionRetryEnabled: Boolean): RealConnection &#123;  if (call.isCanceled()) throw IOException(&quot;Canceled&quot;)  // Attempt to reuse the connection from the call.  val callConnection = call.connection // This may be mutated by releaseConnectionNoEvents()!  if (callConnection != null) &#123;    var toClose: Socket? = null    synchronized(callConnection) &#123;      if (callConnection.noNewExchanges || !sameHostAndPort(callConnection.route().address.url)) &#123;        toClose = call.releaseConnectionNoEvents()      &#125;    &#125;    // If the call&#x27;s connection wasn&#x27;t released, reuse it. We don&#x27;t call connectionAcquired() here    // because we already acquired it.    if (call.connection != null) &#123;      check(toClose == null)      return callConnection    &#125;    // The call&#x27;s connection was released.    toClose?.closeQuietly()    eventListener.connectionReleased(call, callConnection)  &#125;  // We need a new connection. Give it fresh stats.  refusedStreamCount = 0  connectionShutdownCount = 0  otherFailureCount = 0  // Attempt to get a connection from the pool.  if (connectionPool.callAcquirePooledConnection(address, call, null, false)) &#123;    val result = call.connection!!    eventListener.connectionAcquired(call, result)    return result  &#125;  // Nothing in the pool. Figure out what route we&#x27;ll try next.  val routes: List&lt;Route&gt;?  val route: Route  if (nextRouteToTry != null) &#123;    // Use a route from a preceding coalesced connection.    routes = null    route = nextRouteToTry!!    nextRouteToTry = null  &#125; else if (routeSelection != null &amp;&amp; routeSelection!!.hasNext()) &#123;    // Use a route from an existing route selection.    routes = null    route = routeSelection!!.next()  &#125; else &#123;    // Compute a new route selection. This is a blocking operation!    var localRouteSelector = routeSelector    if (localRouteSelector == null) &#123;      localRouteSelector = RouteSelector(address, call.client.routeDatabase, call, eventListener)      this.routeSelector = localRouteSelector    &#125;    val localRouteSelection = localRouteSelector.next()    routeSelection = localRouteSelection    routes = localRouteSelection.routes    if (call.isCanceled()) throw IOException(&quot;Canceled&quot;)    // Now that we have a set of IP addresses, make another attempt at getting a connection from    // the pool. We have a better chance of matching thanks to connection coalescing.    if (connectionPool.callAcquirePooledConnection(address, call, routes, false)) &#123;      val result = call.connection!!      eventListener.connectionAcquired(call, result)      return result    &#125;    route = localRouteSelection.next()  &#125;  // Connect. Tell the call about the connecting call so async cancels work.  val newConnection = RealConnection(connectionPool, route)  call.connectionToCancel = newConnection  try &#123;    newConnection.connect(        connectTimeout,        readTimeout,        writeTimeout,        pingIntervalMillis,        connectionRetryEnabled,        call,        eventListener    )  &#125; finally &#123;    call.connectionToCancel = null  &#125;  call.client.routeDatabase.connected(newConnection.route())  // If we raced another call connecting to this host, coalesce the connections. This makes for 3  // different lookups in the connection pool!  if (connectionPool.callAcquirePooledConnection(address, call, routes, true)) &#123;    val result = call.connection!!    nextRouteToTry = route    newConnection.socket().closeQuietly()    eventListener.connectionAcquired(call, result)    return result  &#125;  synchronized(newConnection) &#123;    connectionPool.put(newConnection)    call.acquireConnectionNoEvents(newConnection)  &#125;  eventListener.connectionAcquired(call, newConnection)  return newConnection&#125;\n代码有点长，但是其实还好，还是不难读的\n\n\n首先他判断这个 Call 是否被取消了，被取消了就在第一时间停止寻找这个 Connection\n\n\n然后再判断这个 Call 是否有了 Connection ，目的是为了尝试重复使用这个连接\n\n\n如果没有 Connection 就使用 connectionPool.callAcquirePooledConnection(address, call, null, false) 在连接池里找一个连接，我们进去看看这方法\n\n\ncallAcquirePooledConnection()\n// RealConnectionPool.ktfun callAcquirePooledConnection(  address: Address,  call: RealCall,  routes: List&lt;Route&gt;?,  requireMultiplexed: Boolean): Boolean &#123;  for (connection in connections) &#123;    synchronized(connection) &#123;      if (requireMultiplexed &amp;&amp; !connection.isMultiplexed) return@synchronized      if (!connection.isEligible(address, routes)) return@synchronized      call.acquireConnectionNoEvents(connection)      return true    &#125;  &#125;  return false&#125;\n这个方法很简单，就是在循环中遍历找一个符合条件的连接，我们再看看这里面的 call.acquireConnectionNoEvents(connection)\n// RealCall.ktfun acquireConnectionNoEvents(connection: RealConnection) &#123;  connection.assertThreadHoldsLock()  check(this.connection == null)  this.connection = connection  connection.calls.add(CallReference(this, callStackTrace))&#125;\n这里就是做一些检查然后赋值、添加引用\nconnection.isEligible\n那么该如何进行判断这个连接是不是可用呢？我们看看这个 connection.isEligible\ninternal fun isEligible(address: Address, routes: List&lt;Route&gt;?): Boolean &#123;  assertThreadHoldsLock()  // If this connection is not accepting new exchanges, we&#x27;re done.  if (calls.size &gt;= allocationLimit || noNewExchanges) return false  // If the non-host fields of the address don&#x27;t overlap, we&#x27;re done.  if (!this.route.address.equalsNonHost(address)) return false  // If the host exactly matches, we&#x27;re done: this connection can carry the address.  if (address.url.host == this.route().address.url.host) &#123;    return true // This connection is a perfect match.  &#125;  // At this point we don&#x27;t have a hostname match. But we still be able to carry the request if  // our connection coalescing requirements are met. See also:  // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding  // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/  // 1. This connection must be HTTP/2.  if (http2Connection == null) return false  // 2. The routes must share an IP address.  if (routes == null || !routeMatchesAny(routes)) return false  // 3. This connection&#x27;s server certificate&#x27;s must cover the new host.  if (address.hostnameVerifier !== OkHostnameVerifier) return false  if (!supportsUrl(address.url)) return false  // 4. Certificate pinning must match the host.  try &#123;    address.certificatePinner!!.check(address.url.host, handshake()!!.peerCertificates)  &#125; catch (_: SSLPeerUnverifiedException) &#123;    return false  &#125;  return true // The caller&#x27;s address can be carried by this connection.&#125;\n这个函数并不复杂，我们一点点看：\n\n\n这个函数接受两个参数 address 和 routes\n\n\naddress 有两个最关键的成员变量 uriHost 和 uriPort\nclass Address(  uriHost: String,  uriPort: Int,  @get:JvmName(&quot;dns&quot;) val dns: Dns,  @get:JvmName(&quot;socketFactory&quot;) val socketFactory: SocketFactory,  @get:JvmName(&quot;sslSocketFactory&quot;) val sslSocketFactory: SSLSocketFactory?,  @get:JvmName(&quot;hostnameVerifier&quot;) val hostnameVerifier: HostnameVerifier?,  @get:JvmName(&quot;certificatePinner&quot;) val certificatePinner: CertificatePinner?,  @get:JvmName(&quot;proxyAuthenticator&quot;) val proxyAuthenticator: Authenticator,  @get:JvmName(&quot;proxy&quot;) val proxy: Proxy?,  protocols: List&lt;Protocol&gt;,  connectionSpecs: List&lt;ConnectionSpec&gt;,  @get:JvmName(&quot;proxySelector&quot;) val proxySelector: ProxySelector)\n\n其余的成员都是从 OkHttpClient 抽出来的，而 host 和 port 是最关键的两个\nAddress 是什么时候传进来的？是从 RetryAndFollowUpInterceptor 创建 ExchangeFinder 的时候创建的\n\n\n\nroutes 是 List&lt;Route&gt;\n那么 Route 是什么呢？它包含三个部分 address、proxy 和 socketAddress\nclass Route(  @get:JvmName(&quot;address&quot;) val address: Address,  /**   * Returns the [Proxy] of this route.   *   * **Warning:** This may disagree with [Address.proxy] when it is null. When   * the address&#x27;s proxy is null, the proxy selector is used.   */  @get:JvmName(&quot;proxy&quot;) val proxy: Proxy,  @get:JvmName(&quot;socketAddress&quot;) val socketAddress: InetSocketAddress)\n\n\n\n\n首先就是判断这个 call 能承受的最大连接数（HTTP2 之前都是一个）以及是否能接受新的请求（noNewExchange 为 true 说明不再接受新的请求），只要有一个返回 false，就证明这个连接不可用\n\n\n然后我们继续看，下面两个 if 就是看这个连接和我的请求是不是同一个非主机地址，包括更多，比如：端口，tls 版本，代理配置等等…我们点进去看看\ninternal fun equalsNonHost(that: Address): Boolean &#123;  return this.dns == that.dns &amp;&amp;      this.proxyAuthenticator == that.proxyAuthenticator &amp;&amp;      this.protocols == that.protocols &amp;&amp;      this.connectionSpecs == that.connectionSpecs &amp;&amp;      this.proxySelector == that.proxySelector &amp;&amp;      this.proxy == that.proxy &amp;&amp;      this.sslSocketFactory == that.sslSocketFactory &amp;&amp;      this.hostnameVerifier == that.hostnameVerifier &amp;&amp;      this.certificatePinner == that.certificatePinner &amp;&amp;      this.url.port == that.url.port&#125;\n可以看到他没有对比 host\n而下面这个 if 就直接对比了 host 是否一致，如果一致那就直接返回 true\n整合起来就是，如果其他的配置有一个不一致就返回 false ，如果上面的匹配一致，就再去判断 host 是否一致，host 也一致就直接返回 true\n\n\n如果 host 不匹配，就再进行最后的判断 connection coalescing\n\nConnection coalescing（连接合并）是 HTTP/2 协议中的一个关键特性，它允许多个不同主机名（host）的请求复用同一个底层 TCP 连接，只要它们满足某些安全和配置上的条件。\n\n下面的就是几步，判断是否满足连接合并：\n\n是 HTTP/2\nIP 地址一致\nhostnameVerifier 是 OkHostnameVerifier\nurl 满足要求，包括端口一样，host 一样，证书匹配\n证书固定必须与主机匹配\n\n判断到最后就可以认定这个连接是可用的了\n但是这个 routes 是传入的，并且是 null ！！！\n所以本次就无法返回 HTTP/2 的 connection\n\n\n另一个 callAcquirePooledConnection()\n再往下找，你会看到还有一个 connectionPool.callAcquirePooledConnection(address, call, routes, false)\n这个和上面的请求参数不一样，上面的参数是 address, call, null, false 这个是 address, call, routes, false ，此次 routes 参数 不为 null 了\n也就是说，当上面的非 HTTP/2 的 connection 拿不到，我们再在这里用路由信息，拿 HTTP/1 或者 HTTP/2 的 connection\n最后一个 callAcquirePooledConnection()\n此次的参数，又变了，它将 requireMultiplexed 设为 true\n但是此次建立了 connection ，直接拿来用并把它放进连接池不就行了，这是为了避免，连接建立完成之后，防止其他请求抢先复用了连接池的新连接\n\n但是！！！\n我感觉 4.12.0 这个版本的 OkHttp 或许有点问题，因为这个最终的判断并没有加锁，只在将 newConnection 放进 connectionPool 的时候会加锁，那么怎么确定这个这两段代码之间，不会因多线程导致连接多次创建但是没有被获取到呢？\n在之前的某个版本，是直接将 connectionPool 加锁进行判断并添加的，我感觉那个才是更稳妥的，如图：\n\n\nnewConnection.connect\n我们最后看一下这个新的连接是如何建立的\nfun connect(  connectTimeout: Int,  readTimeout: Int,  writeTimeout: Int,  pingIntervalMillis: Int,  connectionRetryEnabled: Boolean,  call: Call,  eventListener: EventListener) &#123;  check(protocol == null) &#123; &quot;already connected&quot; &#125;  var routeException: RouteException? = null  val connectionSpecs = route.address.connectionSpecs  val connectionSpecSelector = ConnectionSpecSelector(connectionSpecs)  if (route.address.sslSocketFactory == null) &#123;    if (ConnectionSpec.CLEARTEXT !in connectionSpecs) &#123;      throw RouteException(UnknownServiceException(          &quot;CLEARTEXT communication not enabled for client&quot;))    &#125;    val host = route.address.url.host    if (!Platform.get().isCleartextTrafficPermitted(host)) &#123;      throw RouteException(UnknownServiceException(          &quot;CLEARTEXT communication to $host not permitted by network security policy&quot;))    &#125;  &#125; else &#123;    if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) &#123;      throw RouteException(UnknownServiceException(          &quot;H2_PRIOR_KNOWLEDGE cannot be used with HTTPS&quot;))    &#125;  &#125;  while (true) &#123;    try &#123;      if (route.requiresTunnel()) &#123;        connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)        if (rawSocket == null) &#123;          // We were unable to connect the tunnel but properly closed down our resources.          break        &#125;      &#125; else &#123;        connectSocket(connectTimeout, readTimeout, call, eventListener)      &#125;      establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)      eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)      break    &#125; catch (e: IOException) &#123;      socket?.closeQuietly()      rawSocket?.closeQuietly()      socket = null      rawSocket = null      source = null      sink = null      handshake = null      protocol = null      http2Connection = null      allocationLimit = 1      eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)      if (routeException == null) &#123;        routeException = RouteException(e)      &#125; else &#123;        routeException.addConnectException(e)      &#125;      if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123;        throw routeException      &#125;    &#125;  &#125;  if (route.requiresTunnel() &amp;&amp; rawSocket == null) &#123;    throw RouteException(ProtocolException(        &quot;Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS&quot;))  &#125;  idleAtNs = System.nanoTime()&#125;\n这里面有个 while(true) 循环，里面涉及一个 Tunnel 的概念，这个感觉有点超纲了，而且我也不是很懂，就不做解释了\n大部分情况下，就直接 connectSocket 就行\n@Throws(IOException::class)private fun connectSocket(  connectTimeout: Int,  readTimeout: Int,  call: Call,  eventListener: EventListener) &#123;  val proxy = route.proxy  val address = route.address  val rawSocket = when (proxy.type()) &#123;    Proxy.Type.DIRECT, Proxy.Type.HTTP -&gt; address.socketFactory.createSocket()!!    else -&gt; Socket(proxy)  &#125;  this.rawSocket = rawSocket  eventListener.connectStart(call, route.socketAddress, proxy)  rawSocket.soTimeout = readTimeout  try &#123;    Platform.get().connectSocket(rawSocket, route.socketAddress, connectTimeout)  &#125; catch (e: ConnectException) &#123;    throw ConnectException(&quot;Failed to connect to $&#123;route.socketAddress&#125;&quot;).apply &#123;      initCause(e)    &#125;  &#125;  // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0  // More details:  // https://github.com/square/okhttp/issues/3245  // https://android-review.googlesource.com/#/c/271775/  try &#123;    source = rawSocket.source().buffer()    sink = rawSocket.sink().buffer()  &#125; catch (npe: NullPointerException) &#123;    if (npe.message == NPE_THROW_WITH_NULL) &#123;      throw IOException(npe)    &#125;  &#125;&#125;\n这里面有个 rawSocket 就是 Connection 里面实际的 TCP 端口\nconnectSocket 之后，就需要建立 Http 连接了，establishProtocol 建立协议\n@Throws(IOException::class)private fun establishProtocol(  connectionSpecSelector: ConnectionSpecSelector,  pingIntervalMillis: Int,  call: Call,  eventListener: EventListener) &#123;  if (route.address.sslSocketFactory == null) &#123;    if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) &#123;      socket = rawSocket      protocol = Protocol.H2_PRIOR_KNOWLEDGE      startHttp2(pingIntervalMillis)      return    &#125;    socket = rawSocket    protocol = Protocol.HTTP_1_1    return  &#125;  eventListener.secureConnectStart(call)  connectTls(connectionSpecSelector)  eventListener.secureConnectEnd(call, handshake)  if (protocol === Protocol.HTTP_2) &#123;    startHttp2(pingIntervalMillis)  &#125;&#125;\n这里可以简单看一下，就是 Http 的标准操作\n总结\n\n有没有可用 connection ，val callConnection = call.connection\n通过地址获取一次连接 connectionPool.callAcquirePooledConnection(address, call, null, false)\n通过路由再获取一次 connectionPool.callAcquirePooledConnection(address, call, routes, false)\n自己创建连接\n最后在只获取多路复用的连接 connectionPool.callAcquirePooledConnection(address, call, routes, true)\n\n\n作为 Android 程序员，可能对于路由比较陌生的，下面知识尝试解决一下这个问题：\n在 OkHttp 中，Route 是网络请求的底层通信路径信息，它代表一次连接的完整“路径”\nRouteSelector 是 OkHttp 内部用于 选择可用连接路径（Route） 的核心组件，它根据你请求的目标地址、代理配置、DNS 解析结果等，生成一组可能的 Route，并按顺序尝试连接，直到成功或失败。\nRouteSelector 用于 批量返回可尝试的 Routes 的临时封装。\nRouteSelection selection = routeSelector.next();List&lt;Route&gt; allRoutes = selection.getAll();Route nextRoute = selection.next();  // 依次尝试\n\n它内部维护一个 List&lt;Route&gt;\n每次调用 .next() 就返回下一个尚未尝试的 Route\n\n              Address                 |         +----------------+         |  RouteSelector |         +----------------+                 |   ┌──────────────┴──────────────┐   |                             |选择代理                    DNS解析目标地址   |                             |生成所有可用的 Route（IP + 端口 + 代理）                 |       按顺序返回 RouteSelection                 |        客户端依次尝试连接 Route                 |       成功 → 使用连接       失败 → 记录失败 → 继续尝试\n\nconnection.isHealthy\n获得 connection 之后，我们还需要判断它是否健康\n// RealConnection.ktfun isHealthy(doExtensiveChecks: Boolean): Boolean &#123;  assertThreadDoesntHoldLock()  val nowNs = System.nanoTime()  val rawSocket = this.rawSocket!!  val socket = this.socket!!  val source = this.source!!  if (rawSocket.isClosed || socket.isClosed || socket.isInputShutdown ||          socket.isOutputShutdown) &#123;    return false  &#125;  val http2Connection = this.http2Connection  if (http2Connection != null) &#123;    return http2Connection.isHealthy(nowNs)  &#125;  val idleDurationNs = synchronized(this) &#123; nowNs - idleAtNs &#125;  if (idleDurationNs &gt;= IDLE_CONNECTION_HEALTHY_NS &amp;&amp; doExtensiveChecks) &#123;    return socket.isHealthy(source)  &#125;  return true&#125;\n就是看看 socket 有没有关闭，还需要判断 http2Connection 健不健康，ping-pong 是否正常\n获得一个既可用又健康的连接之后，就返回它\nExchange.find\n回到这里，然后生成一个 Codec 这个 Codec 就是用来编写 Request 以及解析 Response 的工具\ninitExchange\n这里获得 Codec 之后，然后生成一个 Exchange ，就可以用 codec 来生成 Request 然后发请求了\n最后就直接返回到 ConnectInterceptor 了\nCallServerInterceptor\n@Throws(IOException::class)override fun intercept(chain: Interceptor.Chain): Response &#123;  val realChain = chain as RealInterceptorChain  val exchange = realChain.exchange!!  val request = realChain.request  val requestBody = request.body  val sentRequestMillis = System.currentTimeMillis()  var invokeStartEvent = true  var responseBuilder: Response.Builder? = null  var sendRequestException: IOException? = null  try &#123;    exchange.writeRequestHeaders(request)    if (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody != null) &#123;      // If there&#x27;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100      // Continue&quot; response before transmitting the request body. If we don&#x27;t get that, return      // what we did get (such as a 4xx response) without ever transmitting the request body.      if (&quot;100-continue&quot;.equals(request.header(&quot;Expect&quot;), ignoreCase = true)) &#123;        exchange.flushRequest()        responseBuilder = exchange.readResponseHeaders(expectContinue = true)        exchange.responseHeadersStart()        invokeStartEvent = false      &#125;      if (responseBuilder == null) &#123;        if (requestBody.isDuplex()) &#123;          // Prepare a duplex body so that the application can send a request body later.          exchange.flushRequest()          val bufferedRequestBody = exchange.createRequestBody(request, true).buffer()          requestBody.writeTo(bufferedRequestBody)        &#125; else &#123;          // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.          val bufferedRequestBody = exchange.createRequestBody(request, false).buffer()          requestBody.writeTo(bufferedRequestBody)          bufferedRequestBody.close()        &#125;      &#125; else &#123;        exchange.noRequestBody()        if (!exchange.connection.isMultiplexed) &#123;          // If the &quot;Expect: 100-continue&quot; expectation wasn&#x27;t met, prevent the HTTP/1 connection          // from being reused. Otherwise we&#x27;re still obligated to transmit the request body to          // leave the connection in a consistent state.          exchange.noNewExchangesOnConnection()        &#125;      &#125;    &#125; else &#123;      exchange.noRequestBody()    &#125;    if (requestBody == null || !requestBody.isDuplex()) &#123;      exchange.finishRequest()    &#125;  &#125; catch (e: IOException) &#123;    if (e is ConnectionShutdownException) &#123;      throw e // No request was sent so there&#x27;s no response to read.    &#125;    if (!exchange.hasFailure) &#123;      throw e // Don&#x27;t attempt to read the response; we failed to send the request.    &#125;    sendRequestException = e  &#125;  try &#123;    if (responseBuilder == null) &#123;      responseBuilder = exchange.readResponseHeaders(expectContinue = false)!!      if (invokeStartEvent) &#123;        exchange.responseHeadersStart()        invokeStartEvent = false      &#125;    &#125;    var response = responseBuilder        .request(request)        .handshake(exchange.connection.handshake())        .sentRequestAtMillis(sentRequestMillis)        .receivedResponseAtMillis(System.currentTimeMillis())        .build()    var code = response.code    if (shouldIgnoreAndWaitForRealResponse(code)) &#123;      responseBuilder = exchange.readResponseHeaders(expectContinue = false)!!      if (invokeStartEvent) &#123;        exchange.responseHeadersStart()      &#125;      response = responseBuilder          .request(request)          .handshake(exchange.connection.handshake())          .sentRequestAtMillis(sentRequestMillis)          .receivedResponseAtMillis(System.currentTimeMillis())          .build()      code = response.code    &#125;    exchange.responseHeadersEnd(response)    response = if (forWebSocket &amp;&amp; code == 101) &#123;      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.      response.newBuilder()          .body(EMPTY_RESPONSE)          .build()    &#125; else &#123;      response.newBuilder()          .body(exchange.openResponseBody(response))          .build()    &#125;    if (&quot;close&quot;.equals(response.request.header(&quot;Connection&quot;), ignoreCase = true) ||        &quot;close&quot;.equals(response.header(&quot;Connection&quot;), ignoreCase = true)) &#123;      exchange.noNewExchangesOnConnection()    &#125;    if ((code == 204 || code == 205) &amp;&amp; response.body?.contentLength() ?: -1L &gt; 0L) &#123;      throw ProtocolException(          &quot;HTTP $code had non-zero Content-Length: $&#123;response.body?.contentLength()&#125;&quot;)    &#125;    return response  &#125; catch (e: IOException) &#123;    if (sendRequestException != null) &#123;      sendRequestException.addSuppressed(e)      throw sendRequestException    &#125;    throw e  &#125;&#125;\n这个 Interceptor 的工作就是在构建 Request 然后接收到数据并组装 Response\n然后就到了最后，\n\n也就是返回 Response 之后，就会返回给上个 Interceptor 也就是 ConnectionInterceptor\nConnectionInterceptor 没有后置工作，继续向上返回，返回到 CacheInterceptor\nCacheInterceptor 拿到 Response 之后看看需不需要往缓存里放，如果需要就放进缓存，然后返回到 BridgeInterceptor\nBridgeInterceptor 会读 Response 的各种 Header ，还有解压缩，再返回到 RetryAndFollowUpInterceptor\nRetryAndFollowUpInterceptor 就是重试和重连\n\nOVER\n以上就是 OkHttp 的源码阅读过程，确实有点费劲，但是还是值得的\n","tags":["kotlin","java","OkHttp","http","网络","框架","源码"]},{"title":"阅读 Retrofit 源码","url":"/2025/04/02/%E9%98%85%E8%AF%BB-Retrofit-%E6%BA%90%E7%A0%81/","content":"Retrofit 简介\nRetrofit 是 Square 公司开发的一款针对 Android 和 Java 的类型安全的网络请求框架。\n官网说的是：A type-safe HTTP client for Android and Java\ntype-safe（类型安全）：一个框架类型安全指的是它会在编译期间就将类型错误，不会在运行时报类型错误。\n所以他会有大量的类型检查，在编译期间\nOkHttp 和 Retrofit 的区别，Retrofit 是 OKHttp 的功能细分，Retrofit 实现网络请求更便携，相当于 Square 帮你把很多代码提前写好了，但 OKHttp 更灵活\n源码开读\n以下我使用的是 Retrofit 2.11.0 不同版本有些许差异，但我只以 2.11.0 为例\n首先我们从 Retrofit.create() 开始读\npublic &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;    validateServiceInterface(service);    return (T)        Proxy.newProxyInstance(            service.getClassLoader(),            new Class&lt;?&gt;[] &#123;service&#125;,            new InvocationHandler() &#123;              private final Object[] emptyArgs = new Object[0];              @Override              public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args)                  throws Throwable &#123;                // If the method is a method from Object then defer to normal invocation.                if (method.getDeclaringClass() == Object.class) &#123;                  return method.invoke(this, args);                &#125;                args = args != null ? args : emptyArgs;                Reflection reflection = Platform.reflection;                return reflection.isDefaultMethod(method)                    ? reflection.invokeDefaultMethod(method, service, proxy, args)                    : loadServiceMethod(service, method).invoke(proxy, args);              &#125;            &#125;);&#125;\n总体他一共就两行代码，第一行是 this.validateServiceInterface(service);，第二行是 return Proxy.newProxyInstance(...) 下面的都是他的参数\nvalidateServiceInterface（验证）\n首先我们看 this.validateServiceInterface(service);\nprivate void validateServiceInterface(Class&lt;?&gt; service) &#123;  if (!service.isInterface()) &#123;    throw new IllegalArgumentException(&quot;API declarations must be interfaces.&quot;);  &#125;  Deque&lt;Class&lt;?&gt;&gt; check = new ArrayDeque&lt;&gt;(1);  check.add(service);  while (!check.isEmpty()) &#123;    Class&lt;?&gt; candidate = check.removeFirst();    if (candidate.getTypeParameters().length != 0) &#123;      StringBuilder message =          new StringBuilder(&quot;Type parameters are unsupported on &quot;).append(candidate.getName());      if (candidate != service) &#123;        message.append(&quot; which is an interface of &quot;).append(service.getName());      &#125;      throw new IllegalArgumentException(message.toString());    &#125;    Collections.addAll(check, candidate.getInterfaces());  &#125;  if (validateEagerly) &#123;    Reflection reflection = Platform.reflection;    for (Method method : service.getDeclaredMethods()) &#123;      if (!reflection.isDefaultMethod(method)          &amp;&amp; !Modifier.isStatic(method.getModifiers())          &amp;&amp; !method.isSynthetic()) &#123;        loadServiceMethod(service, method);      &#125;    &#125;  &#125;&#125;\n\n\n一开始它进行了 service.isInterface() 的判断，这个 service 就是我们在调用 Retrofit.create() 传入的参数，也就是我们自己声明的接口，比如：\ninterface GitHubService &#123;  @GET(&quot;users/&#123;user&#125;/repos&quot;)  fun listRepos(@Path(&quot;user&quot;) user: String?): Call&lt;List&lt;Repo&gt;&gt;&#125;\n\n为什么要判断这个是不是接口呢？因为 Retrofit 只允许你声明接口，这是它的设计意图，也是后面使用动态代理的条件\n\n\n\n后面它在确认你声明的是接口之后，生成了一个叫 check 的 Deque（双端队列），紧接着进行了一个 while 循环，判断条件是当 check 为空的时候结束循环。\n\n这个循环里它先将 check 的第一个元素取出，判断它有没有泛型类型参数（详见我的泛型文章），因为泛型会类型擦除，导致动态代理的时候没办法生成具体的类型，会影响 HTTP 的响应和类型转换。\n\n\n\nCollections.addAll(check, candidate.getInterfaces()); 是在判断完当前接口之后，将它直接实现的接口放进 check 里面。依次判断，直到 check 为空。\n\n\n下面是判断 validateEagerly (提前验证、提前确认) ，这是个控制开发者声明的接口什么时候初始化的一个开关\n\n默认 validateEagerly = false 开发者声明的接口方法会在首次调用的时候调用 loadServiceMethod 方法，但如果将 validateEagerly 设为 true，那就会在调用 Retrofit.create() 的时候进行 loadServiceMethod\n由于 loadServiceMethod 内部实现涉及到反射，所以集中将所有声明的接口方法初始化会可能会导致性能问题\n但开启 validateEagerly 可以在调用方法之前，进行检查，这样避免在调用方法的时候再发现问题，方便测试或者提前处理异常，对稳定有帮助\n\n\n\nOK！这样我们就看完了 validate 的流程，接下来该看 newProxyInstance（动态代理）了\nnewProxyInstance（动态代理）\n动态代理可能对于部分人有些陌生\n我觉的有必要从代理模式来讲解\n静态代理\n代理模式（Proxy Pattern）是一种结构型设计模式，它通过为目标对象（真实对象）提供一个代理对象，以控制对目标对象的访问。代理对象与真实对象实现相同的接口，调用代理对象的方法时，实际上可以在内部做一些额外的处理，然后再调用真实对象的方法。\n所以，有一个实际的类，它的方法需要被隔离或者扩展，所以生成一个代理类，这个类的方法签名（函数名和参数列表）和实际的类一致，调用这个代理类的方法来影响实际类的方法。\n也就是说，你想调用一个方法 RealImage.displsy() ，也就是想让 RealImage 显示在屏幕上。可是你又想让它在现实的时候，做一些其他的操作。\n此时你就可以写一个代理类 ProxyImage 这个类和 RealImage 一样，都实现了同一个接口，或者干脆 ProxyImage 继承 RealImage，或者更干脆一点，两个类的函数签名（函数名和参数列表）一致就行。\n\n注意\n保持的继承关系可以让代码在结构上更稳定，索然让两个类的函数签名一致也可以达到代理的目的，但是有继承关系的代码更加稳定\n\ninterface Image &#123;    void display();&#125;class RealImage implements Image &#123;    private String fileName;    public RealImage(String fileName) &#123;        this.fileName = fileName;        loadFromDisk(fileName);    &#125;    @Override    public void display() &#123;        System.out.println(&quot;Displaying &quot; + fileName);    &#125;    private void loadFromDisk(String fileName) &#123;        System.out.println(&quot;Loading &quot; + fileName);    &#125;&#125;class ImageInvocationHandler implements InvocationHandler &#123;    private RealImage realImage;    private String fileName;    public ImageInvocationHandler(String fileName) &#123;        this.fileName = fileName;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        if (realImage == null) &#123;            realImage = new RealImage(fileName);        &#125;        System.out.println(&quot;图片正在加载，请等待&quot;);        return method.invoke(realImage, args);    &#125;&#125;public class DynamicProxyImageDemo &#123;    public static void main(String[] args) &#123;        Image image = (Image) Proxy.newProxyInstance(                Image.class.getClassLoader(),                new Class&lt;?&gt;[]&#123;Image.class&#125;,                new ImageInvocationHandler(&quot;wallpaper.png&quot;)        );        // 图像将从磁盘加载        image.display();        ProxyUtils.generateClassFile(RealImage.class, &quot;ImageDynamicProxy&quot;);    &#125;&#125;\n输出结果：\nLoading wallpaper.png图片正在加载，请等待Displaying wallpaper.png\n你会发现，在 Main 函数里，你使用了 ProxyImage 但却最终实际上调用了 RealImage 的 display() ，这就是代理模式中的静态代理\n那么动态代理呢?\n动态代理\n和静态代理类似，动态代理是在运行的时候，生成 ProxyImage 来代理 ReadImage 处理一些代码逻辑。\ninterface Image &#123;    void display();&#125;// 真实的 Image 类class RealImage implements Image &#123;    String fileName;    public RealImage(String fileName) &#123;        this.fileName = fileName;        loadFromDisk(fileName);    &#125;    @Override    public void display() &#123;        System.out.println(&quot;Displaying &quot; + fileName);    &#125;    private void loadFromDisk(String fileName) &#123;        System.out.println(&quot;Loading &quot; + fileName);    &#125;&#125;// 方法调用类 InvocationHandlerclass ImageInvocationHandler implements InvocationHandler &#123;    private RealImage realImage;    private String fileName;    public ImageInvocationHandler(RealImage realImage, String fileName) &#123;        this.realImage = realImage;        this.fileName = fileName;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        if (realImage == null) &#123;            realImage = new RealImage(fileName);        &#125;        System.out.println(&quot;图片正在加载，请等待&quot;);        return method.invoke(realImage, args);    &#125;&#125;// 调用代理类的地方public class DynamicProxyImageDemo &#123;    public static void main(String[] args) &#123;        RealImage realImage = new RealImage(&quot;D:\\\\1.jpg&quot;);        Image image = (Image) Proxy.newProxyInstance(                Image.class.getClassLoader(),                new Class&lt;?&gt;[]&#123;Image.class&#125;,                new ImageInvocationHandler(realImage,realImage.fileName)        );        // 图像将从磁盘加载        image.display();    &#125;&#125;\n同样，输出结果如下：\nLoading wallpaper.png图片正在加载，请等待Displaying wallpaper.png\n动态代理也是一样，用一个代理类来代理实际的对象，可以看到在 Main 函数中也是用了 Proxy.newProxyInstance 第一个参数是需要一个能够加载需要被代理的接口的 ClassLoader，一般使用需要代理的接口的类加载器就可以。第二个参数是我们要代理的接口 Class 对象，第三个就是代理的核心逻辑 InvocationHandler\n\n使用哪个 ClassLoader ？\n\nClassLoader 一般只要使用 MyInterface.class.getClassLoader() 就行了\n但由于一些其他的特殊情况，使用其他的 ClassLoader 也是有可能的，比如：你不知道要代理的类是来自哪里，你可以使用 Thread.currentThread().getContextClassLoader()\n为什么 java 就不能将ClassLoader默认赋给你，而是要你显式传入呢？\n\n这就涉及到 java ClassLoader 的设计哲学了，这里就不再岔开话题，想了解的移步隔壁 java ClassLoader 哲学\n\n\n\n\n但这段代码确实对于刚接触的人来说有点陌生，到底是怎么代理呢？我们直接输出这个动态生成的类，一探究竟\n我们切到 java8 使用 sun.misc.ProxyGenerator 来输出这个动态代理生成的类\nimport sun.misc.ProxyGenerator;import java.io.FileOutputStream;import java.io.IOException;public class ProxyUtils &#123;    /**     * 将根据类信息动态生成的二进制字节码保存到硬盘中，默认的是clazz目录下     * params: clazz 需要生成动态代理类的类     * proxyName: 为动态生成的代理类的名称     */    public static void generateClassFile(Class clazz, String proxyName) &#123;        // 根据类信息和提供的代理类名称，生成字节码        byte[] classFile = ProxyGenerator.generateProxyClass(proxyName, clazz.getInterfaces());        String paths = clazz.getResource(&quot;.&quot;).getPath();        System.out.println(paths);        FileOutputStream out = null;        try &#123;            //保留到硬盘中            out = new FileOutputStream(paths + proxyName + &quot;.class&quot;);            out.write(classFile);            out.flush();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                out.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;\n这是用来生成动态代理生成类的工具类\n\n关于贴源码的提示\n我一直认为贴出 import 是很重要的，因为 java 里也很有很多重复的同名类名，贴出来 import 可以帮阅读者\n\npublic final class ImageDynamicProxy extends Proxy implements Image &#123;    private static Method m1;    private static Method m3;    private static Method m2;    private static Method m0;    public ImageDynamicProxy(InvocationHandler var1) throws  &#123;        super(var1);    &#125;    // super.h.invoke 就是使用 InvocationHandler.invoke()    public final boolean equals(Object var1) throws  &#123;        try &#123;            return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;);        &#125; catch (RuntimeException | Error var3) &#123;            throw var3;        &#125; catch (Throwable var4) &#123;            throw new UndeclaredThrowableException(var4);        &#125;    &#125;    // super.h.invoke 就是使用 InvocationHandler.invoke()    public final void display() throws  &#123;        try &#123;            super.h.invoke(this, m3, (Object[])null);        &#125; catch (RuntimeException | Error var2) &#123;            throw var2;        &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);        &#125;    &#125;    // super.h.invoke 就是使用 InvocationHandler.invoke()    public final String toString() throws  &#123;        try &#123;            return (String)super.h.invoke(this, m2, (Object[])null);        &#125; catch (RuntimeException | Error var2) &#123;            throw var2;        &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);        &#125;    &#125;    // super.h.invoke 就是使用 InvocationHandler.invoke()    public final int hashCode() throws  &#123;        try &#123;            return (Integer)super.h.invoke(this, m0, (Object[])null);        &#125; catch (RuntimeException | Error var2) &#123;            throw var2;        &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);        &#125;    &#125;    static &#123;        try &#123;            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));            m3 = Class.forName(&quot;org.czb.dynamic_proxy.Image&quot;).getMethod(&quot;display&quot;);            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);        &#125; catch (NoSuchMethodException var2) &#123;            throw new NoSuchMethodError(((Throwable)var2).getMessage());        &#125; catch (ClassNotFoundException var3) &#123;            throw new NoClassDefFoundError(((Throwable)var3).getMessage());        &#125;    &#125;&#125;\n可以看到，这个动态生成的类，继承了 Proxy 类，实现了 Image 接口，并且重写了接口的所有方法\n在最下面有一个 static 代码块，在类加载时自动执行一次，初始化了里面的所有方法（equals，display，toString，hashCode）的 Method 静态对象\n在重写的每个接口的方法里，主要方法内容都是 super.h.invoke，也就是 InvocationHandler.invoke()\n所以对于所有的方法都会调用 invoke，如果你要在遇到不同的方法时处理不同的逻辑，就在 invoke 的实现里可以使用 switch-case 对不同的方法进行不同的实现\n这就是所有动态代理的内部原理\n\n代理模式的主要意义：\n\n控制访问\n代理对象可以对客户端的请求进行拦截和控制。比如，可以在调用真实对象的方法之前进行权限校验、延迟加载、日志记 录或事务控制等操作，从而增加额外的安全性和灵活性。\n解耦与增强扩展性\n通过引入代理层，可以将一些横切关注点（例如日志记录、缓存、远程通信等）从核心业务逻辑中分离出来，降低系统耦 合度，增强代码的可维护性和扩展性。\n统一接口\n无论是直接访问真实对象，还是通过代理对象访问，都对客户端透明。客户端只需依赖接口，不必关心对象是代理还是具 体实现，简化了程序设计和后期维护。\n\n\n\n继续看 Retrofit\nnewProxyInstance\n\n\n在 newProxyInstance 中，声明了一个 emptyArgs 这个一看就是要在 args 为 null 的时候，传入的方法参数（来自第 11 行最后面）\n\n\n在 invoke 方法里，使用 getDeclaringClass 判断这个方法的声明类是不是 Object 声明的方法，也就是 toString() HashCode() 这类函数，如果是的话就直接调用\n\n\n而后是一个 Reflection 对象，通过 Platform.reflection 来获得，这个其实很好理解我们看下里面的代码实现：\nfinal class Platform &#123;  static final @Nullable Executor callbackExecutor;  static final Reflection reflection;  static final BuiltInFactories builtInFactories;  static &#123;    switch (System.getProperty(&quot;java.vm.name&quot;)) &#123;      case &quot;Dalvik&quot;:        callbackExecutor = new AndroidMainExecutor();        if (SDK_INT &gt;= 24) &#123;          reflection = new Reflection.Android24();          builtInFactories = new BuiltInFactories.Java8();        &#125; else &#123;          reflection = new Reflection();          builtInFactories = new BuiltInFactories();        &#125;        break;      case &quot;RoboVM&quot;:        callbackExecutor = null;        reflection = new Reflection();        builtInFactories = new BuiltInFactories();        break;      default:        callbackExecutor = null;        reflection = new Reflection.Java8();        builtInFactories = new BuiltInFactories.Java8();        break;    &#125;  &#125;  private Platform() &#123;&#125;&#125;\nPlatform 顾名思义就是平台，里面的 reflection 是一个 Android api 等级的对象，通过判断 java.vm.name 来获得，也就是说这是个判断你使用的是哪个 Android 版本的对象\n\n\n最后这个 return 里面是一个判断，如果 reflection.isDefaultMethod(method) 为 true，就返回 reflection.invokeDefaultMethod(method, service, proxy, args) 否则就返回 loadServiceMethod(service, method).invoke(proxy, args);\n我们先看 reflection.isDefaultMethod(method) 这里一共只有三种 reflection 分别是 Android24 Reflection 和 Java8，我们一个个看\n\n\nAndroid24\nstatic final class Android24 extends Reflection &#123;    @Override    boolean isDefaultMethod(Method method) &#123;        return method.isDefault();    &#125;    ......&#125;\n这个方法调用的是用于判断是不是接口声明时候的实现的 default 方法\n\n\nReflection\nclass Reflection &#123;    boolean isDefaultMethod(Method method) &#123;        return false;    &#125;    ......&#125;\n这里直接返回了 false\n\n\nJava8\n@IgnoreJRERequirement // Only used on JVM.static class Java8 extends Reflection &#123;    @Override    boolean isDefaultMethod(Method method) &#123;        return method.isDefault();    &#125;    ......&#125;\n这里也是直接判断是不是接口实现的 default 方法\n\nmethod.isDefault()\n从 Java 8 开始，接口（interface）中可以包含带有实现的方法，这种方法通过关键字 default 声明。例如：\n\n@IgnoreJRERequirement // Only used on Android API 24+.public interface MyInterface &#123;    default void sayHello() &#123;        System.out.println(&quot;Hello from default method!&quot;);    &#125;&#125;\n这个就是用来判断是不是接口声明的时候，写的 default 方法\n所以你应该就明白了，就是判断是不是支持 java8 （原生 Android api 24 开始支持 java8 特性），支持就判断是不是接口的 default 方法，不支持，那就不可能是接口的 default 方法，干脆直接返回 false\n\n提示\n\n如果你在看过其他的 Retrofit 源码，你可能会发现有一个 hasJava8Types 的字段，其实效果是一样的，都是为了判断是否有接口的 default 实现\n\n\n\n\n\n\n我们继续看，当判断了接口里有默认实现，我们这里就直接调用 invokeDefaultMethod 方法，这个方法又是什么呢？\n我们还是看看实现，这次我们直接放结论，如果是 Reflection，就直接抛出 AssertionError因为他没法声明 default 方法，如果是 Java8 或者 Android24 就直接使用 DefaultMethodSupport.invoke 调用 default 方法，也就是说，Retrofit 会认为你自己实现好了方法调用逻辑而不会帮你生成内部实现。\n\n\n最后，如果你没有接口的 default 实现，那么就轮到 Retrofit 来帮你实现了，也就是最后的 loadServiceMethod\n\n\nloadServiceMethod\n我们看到最后一行，loadServiceMethod(service, method).invoke(proxy, args); 这里调用了两个方法，第一个 loadServiceMethod 返回一个 ServiceMethod，然后调用 ServiceMethod 的 invoke 方法，我直接进去看看源码\nServiceMethod&lt;?&gt; loadServiceMethod(Class&lt;?&gt; service, Method method) &#123;  while (true) &#123;    // Note: Once we are minSdk 24 this whole method can be replaced by computeIfAbsent.    Object lookup = serviceMethodCache.get(method);    if (lookup instanceof ServiceMethod&lt;?&gt;) &#123;      // Happy path: method is already parsed into the model.      return (ServiceMethod&lt;?&gt;) lookup;    &#125;    if (lookup == null) &#123;      // Map does not contain any value. Try to put in a lock for this method. We MUST synchronize      // on the lock before it is visible to others via the map to signal we are doing the work.      Object lock = new Object();      synchronized (lock) &#123;        lookup = serviceMethodCache.putIfAbsent(method, lock);        if (lookup == null) &#123;          // On successful lock insertion, perform the work and update the map before releasing.          // Other threads may be waiting on lock now and will expect the parsed model.          ServiceMethod&lt;Object&gt; result;          try &#123;            result = ServiceMethod.parseAnnotations(this, service, method);          &#125; catch (Throwable e) &#123;            // Remove the lock on failure. Any other locked threads will retry as a result.            serviceMethodCache.remove(method);            throw e;          &#125;          serviceMethodCache.put(method, result);          return result;        &#125;      &#125;    &#125;    // Either the initial lookup or the attempt to put our lock in the map has returned someone    // else&#x27;s lock. This means they are doing the parsing, and will update the map before    // releasing    // the lock. Once we can take the lock, the map is guaranteed to contain the model or null.    // Note: There&#x27;s a chance that our effort to put a lock into the map has actually returned a    // finished model instead of a lock. In that case this code will perform a pointless lock and    // redundant lookup in the map of the same instance. This is rare, and ultimately harmless.    synchronized (lookup) &#123;      Object result = serviceMethodCache.get(method);      if (result == null) &#123;        // The other thread failed its parsing. We will retry (and probably also fail).        continue;      &#125;      return (ServiceMethod&lt;?&gt;) result;    &#125;  &#125;&#125;\n\n我们发现这个 loadServiceMethod 方法总体来说就是返回了一个 ServiceMethod，我们先看它怎么实现的，再看 invoke\n这个方法里是一整个 while 循环\n先是在 serviceMethodCache 里取出一个 Object\n\n如果这个 Object 的类型是 ServiceMethod，那就说明这个方法就已经被加载了，就会直接返回这个对象。\n如果它是空的，那就说明方法还没被加载，就会 new 一个 Object lock\n\n然后紧接着我们对这个 lock 加锁，调用 putIfAbsent 将这个 method 作为 key 放进去，value 是 lock，再次判断 lookup 为空（这里 putIfAbsent 放进去 method 之后，如果之前没有这个 key 就会返回 null，然后使用 if (lookup == null) 所以这里不仅进行了双重锁检验还将 method 放进去了，value 是 lock）\n然后 result = ServiceMethod.parseAnnotations(this, service, method); 生成一个名为 result 的 ServiceMethod 的对象，也就是初始化这个方法。\n如果这里 catch 到问题，会把刚才添加进去的 method移除掉\n如果初始化成功，就更新缓存，也就是将刚才初始化的 result 放进 serviceMethodCache 里面\n\n\n\n\n\n寻找 invoke\n\n\n看明白可这个方法我们先回过头看看 invoke\nabstract @Nullable T invoke(Object instance, Object[] args);\n发现他就是一个抽象方法，没有实现，那我们就得找找这个类的实现了，所以继续看 loadServiceMethod 返回的对象，也就是最后的那个 ServiceMethod.parseAnnotations\n\n\nServiceMethod.parseAnnotations\n进入这个源码我们发现，他和 invoke 在一个类里实现，那我们看 ServiceMethod.parseAnnotations 它内部是怎么实现的\nstatic &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Class&lt;?&gt; service, Method method) &#123;    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, service, method);    Type returnType = method.getGenericReturnType();    if (Utils.hasUnresolvableType(returnType)) &#123;        throw methodError(            method,            &quot;Method return type must not include a type variable or wildcard: %s&quot;,            returnType);    &#125;    if (returnType == void.class) &#123;        throw methodError(method, &quot;Service methods cannot return void.&quot;);    &#125;    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);&#125;\n这个方法很简单，我们一步步看\n\n\n一开始生成了一个 RequestFactory 这个就是来生成 HTTP 请求报文的\n简单看一下这个类，里面使用了 Builder ，并且有一些分析注解的方法\n\n\ngetGenericReturnType 是在方法的获取返回类型\n\n\n然后判断这个 returnType 是否是没法处理的类型，我们看看它内部实现\nstatic boolean hasUnresolvableType(@Nullable Type type) &#123;  if (type instanceof Class&lt;?&gt;) &#123;    return false;  &#125;  if (type instanceof ParameterizedType) &#123;    ParameterizedType parameterizedType = (ParameterizedType) type;    for (Type typeArgument : parameterizedType.getActualTypeArguments()) &#123;      if (hasUnresolvableType(typeArgument)) &#123;        return true;      &#125;    &#125;    return false;  &#125;  if (type instanceof GenericArrayType) &#123;    return hasUnresolvableType(((GenericArrayType) type).getGenericComponentType());  &#125;  if (type instanceof TypeVariable) &#123;    return true;  &#125;  if (type instanceof WildcardType) &#123;    return true;  &#125;  String className = type == null ? &quot;null&quot; : type.getClass().getName();  throw new IllegalArgumentException(      &quot;Expected a Class, ParameterizedType, or &quot;          + &quot;GenericArrayType, but &lt;&quot;          + type          + &quot;&gt; is of type &quot;          + className);&#125;\n\n第一个判断，是判断这个类型是不是 Class 类型，如果是就返回 false，也就是没有无法处理的类型\n第二个判断，是判断是否是 ParameterizedType 也就是泛型类型，如果是就进入循环，进入泛型类型参数里递归检查类型是否是不可处理的，只要有一个不可处理，就返回 true。\n第三个判断，泛型数组，取出泛型类型，递归判断这个泛型类型是否不可处理，也就是回到了第二个判断\n第四个判断，类型变量，也就是泛型类型参数类型，就返回 true。\n第五个判断，通配符类型，也就是 ?,? extends,? super，这种也不能判断，所以返回 true\n最后如果以上判断都没有，就最后抛出异常，提示需要以上类型中的一个\n\n\n\n继续回看 parseAnnotations ，判断返回类型是否为 void 类型，如果就是就抛出异常“不允许返回 void”\n\n\n最后返回 HttpServiceMethod.parseAnnotations，我们继续查看 HttpServiceMethod 发现他继承了 ServiceMethod 类似，也是一个抽象类。\n\n\n所以最后还是又套了一层，调用了 HttpServiceMethod.parseAnnotations 那我们继续看 HttpServiceMethod 吧\n我们进入 HttpServiceMethod.parseAnnotations 这个方法之后太长了，我们先看有没有简单的，比如 invoke\n\n\n找到 invoke\nHttpServiceMethod 确实有实现 invoke 方法\n@Overridefinal @Nullable ReturnT invoke(Object instance, Object[] args) &#123;      Call&lt;ResponseT&gt; call =          new OkHttpCall&lt;&gt;(requestFactory, instance, args, callFactory, responseConverter);    return adapt(call, args);&#125;\n\n这个方法是创建饿了一个 Call 而且还是一个 OkHttpCall 我们简单看一下，它实现了 Call 接口，如果你看过 OkHttp 的源码， 这里应该会感觉很熟悉，我们后面再分析，再继续看 invoke\n然后调用了 adapt 方法，那 adapt 方法又是怎么实现的，我们继续看\n\n寻找 adapt\nprotected abstract @Nullable ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args);\n又是抽象方法，所以我们需要像找 invoke 一样找找这个 HttpServiceMethod 的具体实现了，回去继续看它的 HttpServiceMethod.parseAnnotations\nHttpServiceMethod.parseAnnotations\nstatic &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations(      Retrofit retrofit, Method method, RequestFactory requestFactory) &#123;    boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;    boolean continuationWantsResponse = false;    boolean continuationBodyNullable = false;    boolean continuationIsUnit = false;    Annotation[] annotations = method.getAnnotations();    Type adapterType;    if (isKotlinSuspendFunction) &#123;      Type[] parameterTypes = method.getGenericParameterTypes();      Type responseType =          Utils.getParameterLowerBound(              0, (ParameterizedType) parameterTypes[parameterTypes.length - 1]);      if (getRawType(responseType) == Response.class &amp;&amp; responseType instanceof ParameterizedType) &#123;        // Unwrap the actual body type from Response&lt;T&gt;.        responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType);        continuationWantsResponse = true;      &#125; else &#123;        if (getRawType(responseType) == Call.class) &#123;          throw methodError(              method,              &quot;Suspend functions should not return Call, as they already execute asynchronously.\\n&quot;                  + &quot;Change its return type to %s&quot;,              Utils.getParameterUpperBound(0, (ParameterizedType) responseType));        &#125;        continuationIsUnit = Utils.isUnit(responseType);        // TODO figure out if type is nullable or not        // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class)        // Find the entry for method        // Determine if return type is nullable or not      &#125;      adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);      annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);    &#125; else &#123;      adapterType = method.getGenericReturnType();    &#125;    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =        createCallAdapter(retrofit, method, adapterType, annotations);    Type responseType = callAdapter.responseType();    if (responseType == okhttp3.Response.class) &#123;      throw methodError(          method,          &quot;&#x27;&quot;              + getRawType(responseType).getName()              + &quot;&#x27; is not a valid response body type. Did you mean ResponseBody?&quot;);    &#125;    if (responseType == Response.class) &#123;      throw methodError(method, &quot;Response must include generic type (e.g., Response&lt;String&gt;)&quot;);    &#125;    if (requestFactory.httpMethod.equals(&quot;HEAD&quot;)        &amp;&amp; !Void.class.equals(responseType)        &amp;&amp; !Utils.isUnit(responseType)) &#123;      throw methodError(method, &quot;HEAD method must use Void or Unit as response type.&quot;);    &#125;    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =        createResponseConverter(retrofit, method, responseType);    okhttp3.Call.Factory callFactory = retrofit.callFactory;    if (!isKotlinSuspendFunction) &#123;      return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);    &#125; else if (continuationWantsResponse) &#123;      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.      return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)          new SuspendForResponse&lt;&gt;(              requestFactory,              callFactory,              responseConverter,              (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);    &#125; else &#123;      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.      return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)          new SuspendForBody&lt;&gt;(              requestFactory,              callFactory,              responseConverter,              (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,              continuationBodyNullable,              continuationIsUnit);    &#125;&#125;\n这个方法确实有点长，我们粗略看一下，我们直接找 return，也就是看看他到底是怎么返回一个 HttpServiceMethod 的\n也就是最后一段：\nif (!isKotlinSuspendFunction) &#123;        return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);&#125; else if (continuationWantsResponse) &#123;    //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.    return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)        new SuspendForResponse&lt;&gt;(            requestFactory,            callFactory,            responseConverter,            (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);&#125; else &#123;    //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.    return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;)        new SuspendForBody&lt;&gt;(            requestFactory,            callFactory,            responseConverter,            (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,            continuationBodyNullable,            continuationIsUnit);&#125;\n也就是说，这里通过判断是否是 suspend 方法来生成对应的 HttpServiceMethod，既然是 suspend 方法，那肯定也得生成 suspend 方法啊，这是对于 kotlin 协程的适配\n我们直接看对于普通方法的实现，这篇文章就先不管 suspend 方法，我们直接看 CallAdapted\n找到 adapt\nstatic final class CallAdapted&lt;ResponseT, ReturnT&gt; extends HttpServiceMethod&lt;ResponseT, ReturnT&gt; &#123;    private final CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter;    CallAdapted(            RequestFactory requestFactory,            okhttp3.Call.Factory callFactory,            Converter&lt;ResponseBody, ResponseT&gt; responseConverter,            CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter) &#123;        super(requestFactory, callFactory, responseConverter);        this.callAdapter = callAdapter;    &#125;    @Override    protected ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args) &#123;        return callAdapter.adapt(call);    &#125;&#125;\n这个 CallAdapted 实现了 HttpServiceMethod 并且实现了 adapt\n\n注意\n\nCallAdapted 的含义就是被适配的 Call ，很多英语层面的含义还是可以看出来一些代码的设计意图的\n\n\n然后我们此时可以继续往源码内部深入，找到 retrofit.callAdapter，Retrofit 类里面有一个 callAdapterFactories 而这个 callAdapterFactories 会在 Retrofit 的构造函数里初始化，然后我们想到 Retrofit 我们平时不都是 build 出来的吗？！就像这样\nval retrofit = Retrofit.Builder()    .baseUrl(&quot;https://api.github.com/&quot;)    .addConverterFactory(GsonConverterFactory.create())    .build()\n然后我们发现这文件里确实有 build 方法，这里一下子就串起来了。\n我们继续深入挖掘，找找这个 callAdapterFactories 是这么初始化的，找到 DefaultCallAdapterFactory，并发现如下代码\nreturn new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;    @Override    public Type responseType() &#123;      return responseType;    &#125;        @Override    public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;      return executor == null ? call : new ExecutorCallbackCall&lt;&gt;(executor, call);    &#125;&#125;;\n然后大致就知道这个就是返回一个 Call 的实例（在这里是 ExecutorCallbackCall），返回看代码注释里写的就是\n\n闭环了\n所以我们挖了这么久回头梳理一下，就是要搞明白 loadServiceMethod(service, method).invoke(proxy, args) 这行代码最终干了什么————就是返回了一个 ExecutorCallbackCall\n\nloadServiceMethod 会返回一个 CallAdapted ，这个 CallAdapted 继承了 HttpServiceMethod\n返回他之后，会调用 invoke，这个 invoke 会调用 adapt，最终调用 AdapterFactory 的 get 返回一个 ExecutorCallbackCall\n总结就是动态代理的 InvocationHandler 的 invoke 方法会返回一个 ExecutorCallbackCall，也就是我们写的 val service = retrofit.create(GitHubService::class.java) 的 service 里面会调用 invoke 并返回一个 ExecutorCallbackCall\n我们看看 ExecutorCallbackCall 这个方法里面也有 enqueue 那么既然动态代理就是为了生成这个 ExecutorCallbackCall 是不是就意味着这个 enqueue 就是我们开发的时候写的那个 enqueue————还真是！！！！\n我们看看这个 enqueue 实现了什么吧\n\npublic Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;    return (Call&lt;Object&gt;)(executor == null ? call : new ExecutorCallbackCall(executor, call));&#125;// ...代码隔离...ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;    this.callbackExecutor = callbackExecutor;    this.delegate = delegate;&#125;@Overridepublic void enqueue(final Callback&lt;T&gt; callback) &#123;  Objects.requireNonNull(callback, &quot;callback == null&quot;);  delegate.enqueue(      new Callback&lt;T&gt;() &#123;        @Override        public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;          callbackExecutor.execute(              () -&gt; &#123;                if (delegate.isCanceled()) &#123;                  // Emulate OkHttp&#x27;s behavior of throwing/delivering an IOException on                  // cancellation.                  callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));                &#125; else &#123;                  callback.onResponse(ExecutorCallbackCall.this, response);                &#125;              &#125;);        &#125;        @Override        public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;          callbackExecutor.execute(() -&gt; callback.onFailure(ExecutorCallbackCall.this, t));        &#125;      &#125;);&#125;\n\n这个 delegate 就是我们一开始调用 adapt 填入的那个 Call，也就是 OkHttpCall，一会儿我们再看 OkHttpCall 我们先把这个看完\n也就是说这个 ExecutorCallbackCall 把这个 OkHttpCall 包了一层\n这个 ExecutorCallbackCall 的 enqueue 里面使用了一个 Executor 切了线程，并调用了 callback 的 onFailure 和 onResponse（也就是开发时候写的 callback）\n这里切线程是有点奇怪的，因为如果最终使用的是 OkHttp 的 enqueue，那就没有必要在这里切线程了，所以我们再深挖一下，看看这个 callbackExecutor 里面是怎么操作的\n我们找到这个 callbackExecutor 是在 Retrofit 的构造方法里初始化的 callbackExecutor = Platform.callbackExecutor; 点进去发现是这样的\n\nstatic &#123;    switch (System.getProperty(&quot;java.vm.name&quot;)) &#123;        case &quot;Dalvik&quot;:            callbackExecutor = new AndroidMainExecutor();            if (VERSION.SDK_INT &gt;= 24) &#123;                reflection = new Reflection.Android24();                builtInFactories = new BuiltInFactories.Java8();            &#125; else &#123;                reflection = new Reflection();                builtInFactories = new BuiltInFactories();            &#125;            break;        case &quot;RoboVM&quot;:            callbackExecutor = null;            reflection = new Reflection();            builtInFactories = new BuiltInFactories();            break;        default:            callbackExecutor = null;            reflection = new Reflection.Java8();            builtInFactories = new BuiltInFactories.Java8();    &#125;&#125;\n\n\n又是熟悉的代码，我们看看这个 AndroidMainExecutor 的实现\nfinal class AndroidMainExecutor implements Executor &#123;    private final Handler handler = new Handler(Looper.getMainLooper());    AndroidMainExecutor() &#123;    &#125;    public void execute(Runnable r) &#123;        this.handler.post(r);    &#125;&#125;\n这里就看出来，原来没有切线程，而是在主线程里，这是再往前台切线程\n所以这就是为什么 Retrofit 的 callback 里面的代码可以更新界面（Android 更新界面需要在主线程）\n\n\n所以这个 adapt 的作用还有将线程切回主线程的作用\n回看 OkHttpCall\n然后我们继续返回 HttpServiceMethod 里面回看 invoke 里的 OkHttpCall\n\n注意\n这个 OkHttpCall 和 Call 都是 Retrofit 里面的，并非 OkHttp 里面的\n\n我们挑一个关键函数看，比如经常使用的 enqueue\npublic void enqueue(final Callback&lt;T&gt; callback) &#123;    Objects.requireNonNull(callback, &quot;callback == null&quot;);    okhttp3.Call call;    Throwable failure;    synchronized(this) &#123;        if (this.executed) &#123;            throw new IllegalStateException(&quot;Already executed.&quot;);        &#125;        this.executed = true;        call = this.rawCall;        failure = this.creationFailure;        if (call == null &amp;&amp; failure == null) &#123;            try &#123;                call = this.rawCall = this.createRawCall();            &#125; catch (Throwable t) &#123;                Utils.throwIfFatal(t);                failure = this.creationFailure = t;            &#125;        &#125;    &#125;    if (failure != null) &#123;        callback.onFailure(this, failure);    &#125; else &#123;        if (this.canceled) &#123;            call.cancel();        &#125;        call.enqueue(new okhttp3.Callback() &#123;            public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123;                Response&lt;T&gt; response;                try &#123;                    response = OkHttpCall.this.parseResponse(rawResponse);                &#125; catch (Throwable e) &#123;                    Utils.throwIfFatal(e);                    this.callFailure(e);                    return;                &#125;                try &#123;                    callback.onResponse(OkHttpCall.this, response);                &#125; catch (Throwable t) &#123;                    Utils.throwIfFatal(t);                    t.printStackTrace();                &#125;            &#125;            public void onFailure(okhttp3.Call call, IOException e) &#123;                this.callFailure(e);            &#125;            private void callFailure(Throwable e) &#123;                try &#123;                    callback.onFailure(OkHttpCall.this, e);                &#125; catch (Throwable t) &#123;                    Utils.throwIfFatal(t);                    t.printStackTrace();                &#125;            &#125;        &#125;);    &#125;&#125;\n\n\n代码有点长，但其实并不复杂，做了一些判断，然后调用 createRawCall 创建一个 okhttp3.Call\n哎！！(ｷ｀ﾟДﾟ´)!!最终还是调用了 okhttp3.Call\n\n\n创建成功就是调用 call.enqueue 也就是我们自己写 OkHttp 的时候使用的 enqueue，写个 Callback 接收 Response。\n\n\n我们可以发现，有一个 response = OkHttpCall.this.parseResponse(rawResponse); 也就是说 Retrofit 帮你处理了 rawResponse 并不是直接丢给你，具体怎么处理的一看就懂，这里贴一下代码\nResponse&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;    ResponseBody rawBody = rawResponse.body();    rawResponse = rawResponse.newBuilder().body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())).build();    int code = rawResponse.code();    if (code &gt;= 200 &amp;&amp; code &lt; 300) &#123;        if (code != 204 &amp;&amp; code != 205) &#123;            ExceptionCatchingResponseBody catchingBody = new ExceptionCatchingResponseBody(rawBody);            try &#123;                T body = (T)this.responseConverter.convert(catchingBody);                return Response.success(body, rawResponse);            &#125; catch (RuntimeException e) &#123;                catchingBody.throwIfCaught();                throw e;            &#125;        &#125; else &#123;            rawBody.close();            return Response.success((Object)null, rawResponse);        &#125;    &#125; else &#123;        Response e;        try &#123;            ResponseBody bufferedBody = Utils.buffer(rawBody);            e = Response.error(bufferedBody, rawResponse);        &#125; finally &#123;            rawBody.close();        &#125;        return e;    &#125;&#125;\n\n\n里面有一个比较关键的对象 responseConverter\n\n\n它刚才我们就见过，在 OkHttpCall 被创建的时候，再往上追溯会在 HttpServiceMethod.parseAnnotations 里找到\nnew CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);\n\n\n以及调用方法\nConverter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType);\n\n\n我们看 createResponseConverter\nprivate static &lt;ResponseT&gt; Converter&lt;ResponseBody, ResponseT&gt; createResponseConverter(    Retrofit retrofit, Method method, Type responseType) &#123;    Annotation[] annotations = method.getAnnotations();    try &#123;        return retrofit.responseBodyConverter(responseType, annotations);    &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code.        throw methodError(method, e, &quot;Unable to create converter for %s&quot;, responseType);    &#125;&#125;\n\n\n也就是这个 responseBodyConverter 实际来自 retrofit.responseBodyConverter，也就是我们开发的时候写的那个 Converter\nOK！完美了！基本就差不多了。\n","tags":["kotlin","java","OkHttp","http","网络","框架","源码","Retrofit"]}]